/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!******************************!*\
  !*** ./~/mithril/mithril.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tif (!isEmpty(state.attrs) && !isEmpty(attrs)) {\n\t\tvar newAttrs = {}\n\t\tfor(var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key)) {\n\t\t\t\tnewAttrs[key] = attrs[key]\n\t\t\t}\n\t\t}\n\t\tattrs = newAttrs\n\t}\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty(\"Content-Type\"))) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty(\"Accept\"))) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\tif (typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\t} else {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === \"value\") {\n\t\t\t\tvar normalized0 = \"\" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"select\") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"option\" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\t// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n\t\tif (active != null && $doc.activeElement !== active) active.focus()\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.6\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 18).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWl0aHJpbC9taXRocmlsLmpzP2JkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBrZXkpKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIHRydWVcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuXHR2YXIgbWF0Y2gsIHRhZyA9IFwiZGl2XCIsIGNsYXNzZXMgPSBbXSwgYXR0cnMgPSB7fVxuXHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclBhcnNlci5leGVjKHNlbGVjdG9yKSkge1xuXHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHZhbHVlID0gbWF0Y2hbMl1cblx0XHRpZiAodHlwZSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIikgdGFnID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIiNcIikgYXR0cnMuaWQgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiLlwiKSBjbGFzc2VzLnB1c2godmFsdWUpXG5cdFx0ZWxzZSBpZiAobWF0Y2hbM11bMF0gPT09IFwiW1wiKSB7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gbWF0Y2hbNl1cblx0XHRcdGlmIChhdHRyVmFsdWUpIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKVxuXHRcdFx0aWYgKG1hdGNoWzRdID09PSBcImNsYXNzXCIpIGNsYXNzZXMucHVzaChhdHRyVmFsdWUpXG5cdFx0XHRlbHNlIGF0dHJzW21hdGNoWzRdXSA9IGF0dHJWYWx1ZSA9PT0gXCJcIiA/IGF0dHJWYWx1ZSA6IGF0dHJWYWx1ZSB8fCB0cnVlXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIilcblx0cmV0dXJuIHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdID0ge3RhZzogdGFnLCBhdHRyczogYXR0cnN9XG59XG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3Ncblx0aWYgKCFpc0VtcHR5KHN0YXRlLmF0dHJzKSAmJiAhaXNFbXB0eShhdHRycykpIHtcblx0XHR2YXIgbmV3QXR0cnMgPSB7fVxuXHRcdGZvcih2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkpIHtcblx0XHRcdFx0bmV3QXR0cnNba2V5XSA9IGF0dHJzW2tleV1cblx0XHRcdH1cblx0XHR9XG5cdFx0YXR0cnMgPSBuZXdBdHRyc1xuXHR9XG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSAmJiAhKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoXCJDb250ZW50LVR5cGVcIikpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGVzZXJpYWxpemUgPT09IGRlc2VyaWFsaXplICYmICEoYXJncy5oZWFkZXJzICYmIGFyZ3MuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShcIkFjY2VwdFwiKSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0LypcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLndpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJncy5oZWFkZXJzKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcmdzLmhlYWRlcnMsIGtleSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBhcmdzLmhlYWRlcnNba2V5XSlcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgYXJncy5jb25maWcgPT09IFwiZnVuY3Rpb25cIikgeGhyID0gYXJncy5jb25maWcoeGhyLCBhcmdzKSB8fCB4aHJcblx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgdGhyb3cgZXJyb3JzIG9uIHhoci5hYm9ydCgpLlxuXHRcdFx0XHRpZihhYm9ydGVkKSByZXR1cm5cblx0XHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciByZXNwb25zZSA9IChhcmdzLmV4dHJhY3QgIT09IGV4dHJhY3QpID8gYXJncy5leHRyYWN0KHhociwgYXJncykgOiBhcmdzLmRlc2VyaWFsaXplKGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpKVxuXHRcdFx0XHRcdFx0aWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQgfHwgRklMRV9QUk9UT0NPTF9SRUdFWC50ZXN0KGFyZ3MudXJsKSkge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCByZXNwb25zZSkpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKHhoci5yZXNwb25zZVRleHQpXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiByZXNwb25zZSkgZXJyb3Jba2V5XSA9IHJlc3BvbnNlW2tleV1cblx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlQm9keSAmJiAoYXJncy5kYXRhICE9IG51bGwpKSB4aHIuc2VuZChhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIHhoci5zZW5kKClcblx0XHR9KVxuXHRcdHJldHVybiBhcmdzLmJhY2tncm91bmQgPT09IHRydWUgPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGpzb25wKGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0dmFyIGNhbGxiYWNrTmFtZSA9IGFyZ3MuY2FsbGJhY2tOYW1lIHx8IFwiX21pdGhyaWxfXCIgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTE2KSArIFwiX1wiICsgY2FsbGJhY2tDb3VudCsrXG5cdFx0XHR2YXIgc2NyaXB0ID0gJHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpXG5cdFx0XHQkd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdClcblx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgZGF0YSkpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdClcblx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIkpTT05QIHJlcXVlc3QgZmFpbGVkXCIpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5kYXRhID09IG51bGwpIGFyZ3MuZGF0YSA9IHt9XG5cdFx0XHRhcmdzLnVybCA9IGludGVycG9sYXRlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHRhcmdzLmRhdGFbYXJncy5jYWxsYmFja0tleSB8fCBcImNhbGxiYWNrXCJdID0gY2FsbGJhY2tOYW1lXG5cdFx0XHRzY3JpcHQuc3JjID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdCR3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdClcblx0XHR9KVxuXHRcdHJldHVybiBhcmdzLmJhY2tncm91bmQgPT09IHRydWU/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUodXJsLCBkYXRhKSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkgcmV0dXJuIHVybFxuXHRcdHZhciB0b2tlbnMgPSB1cmwubWF0Y2goLzpbXlxcL10rL2dpKSB8fCBbXVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gdG9rZW5zW2ldLnNsaWNlKDEpXG5cdFx0XHRpZiAoZGF0YVtrZXldICE9IG51bGwpIHtcblx0XHRcdFx0dXJsID0gdXJsLnJlcGxhY2UodG9rZW5zW2ldLCBkYXRhW2tleV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBhc3NlbWJsZSh1cmwsIGRhdGEpIHtcblx0XHR2YXIgcXVlcnlzdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nKGRhdGEpXG5cdFx0aWYgKHF1ZXJ5c3RyaW5nICE9PSBcIlwiKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gdXJsLmluZGV4T2YoXCI/XCIpIDwgMCA/IFwiP1wiIDogXCImXCJcblx0XHRcdHVybCArPSBwcmVmaXggKyBxdWVyeXN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemUoZGF0YSkge1xuXHRcdHRyeSB7cmV0dXJuIGRhdGEgIT09IFwiXCIgPyBKU09OLnBhcnNlKGRhdGEpIDogbnVsbH1cblx0XHRjYXRjaCAoZSkge3Rocm93IG5ldyBFcnJvcihkYXRhKX1cblx0fVxuXHRmdW5jdGlvbiBleHRyYWN0KHhocikge3JldHVybiB4aHIucmVzcG9uc2VUZXh0fVxuXHRmdW5jdGlvbiBjYXN0KHR5cGUwLCBkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlMCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhW2ldID0gbmV3IHR5cGUwKGRhdGFbaV0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgcmV0dXJuIG5ldyB0eXBlMChkYXRhKVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHJldHVybiB7cmVxdWVzdDogcmVxdWVzdCwganNvbnA6IGpzb25wLCBzZXRDb21wbGV0aW9uQ2FsbGJhY2s6IHNldENvbXBsZXRpb25DYWxsYmFja31cbn1cbnZhciByZXF1ZXN0U2VydmljZSA9IF84KHdpbmRvdywgUHJvbWlzZVBvbHlmaWxsKVxudmFyIGNvcmVSZW5kZXJlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyICRkb2MgPSAkd2luZG93LmRvY3VtZW50XG5cdHZhciAkZW1wdHlGcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdHZhciBuYW1lU3BhY2UgPSB7XG5cdFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG5cdFx0bWF0aDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJcblx0fVxuXHR2YXIgb25ldmVudFxuXHRmdW5jdGlvbiBzZXRFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7cmV0dXJuIG9uZXZlbnQgPSBjYWxsYmFja31cblx0ZnVuY3Rpb24gZ2V0TmFtZVNwYWNlKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzICYmIHZub2RlLmF0dHJzLnhtbG5zIHx8IG5hbWVTcGFjZVt2bm9kZS50YWddXG5cdH1cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoMSA9IHZub2RlLmNoaWxkcmVuLm1hdGNoKC9eXFxzKj88KFxcdyspL2ltKSB8fCBbXVxuXHRcdHZhciBwYXJlbnQxID0ge2NhcHRpb246IFwidGFibGVcIiwgdGhlYWQ6IFwidGFibGVcIiwgdGJvZHk6IFwidGFibGVcIiwgdGZvb3Q6IFwidGFibGVcIiwgdHI6IFwidGJvZHlcIiwgdGg6IFwidHJcIiwgdGQ6IFwidHJcIiwgY29sZ3JvdXA6IFwidGFibGVcIiwgY29sOiBcImNvbGdyb3VwXCJ9W21hdGNoMVsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRuZXh0U2libGluZyA9IGRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmQgPCBzdGFydCkgYnJlYWtcblx0XHRcdH1cblx0XHRcdGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kICsgMSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEsIHZub2Rlcylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTm9kZShwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdHZhciBvbGRUYWcgPSBvbGQudGFnLCB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAob2xkVGFnID09PSB0YWcpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gb2xkLnN0YXRlXG5cdFx0XHR2bm9kZS5fc3RhdGUgPSBvbGQuX3N0YXRlXG5cdFx0XHR2bm9kZS5ldmVudHMgPSBvbGQuZXZlbnRzXG5cdFx0XHRpZiAoIXJlY3ljbGluZyAmJiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkpIHJldHVyblxuXHRcdFx0aWYgKHR5cGVvZiBvbGRUYWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRcdFx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChvbGRUYWcpIHtcblx0XHRcdFx0XHRjYXNlIFwiI1wiOiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCI8XCI6IHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIltcIjogdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpOyBicmVha1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLCBudWxsKVxuXHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuLnRvU3RyaW5nKCkgIT09IHZub2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkpIHtcblx0XHRcdG9sZC5kb20ubm9kZVZhbHVlID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4gIT09IHZub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHR0b0ZyYWdtZW50KG9sZClcblx0XHRcdGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHRcdGVsc2Ugdm5vZGUuZG9tID0gb2xkLmRvbSwgdm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHR1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR2YXIgZG9tU2l6ZSA9IDAsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSBudWxsXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuZG9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodm5vZGUuZG9tID09IG51bGwpIHZub2RlLmRvbSA9IGNoaWxkLmRvbVxuXHRcdFx0XHRcdGRvbVNpemUgKz0gY2hpbGQuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb21TaXplICE9PSAxKSB2bm9kZS5kb21TaXplID0gZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgPT0gbnVsbCkgdm5vZGUuYXR0cnMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5hdHRycy52YWx1ZSA9IHZub2RlLnRleHQgLy9GSVhNRSBoYW5kbGUwIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleTIgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleTIgIT0gbnVsbCkgbWFwW2tleTJdID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50MCAhPSBudWxsIHx8IHZub2RlLmRvbSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0aWYgKGNvdW50MCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cdGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50LCBkb20sIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudE5vZGUpIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9tLCBuZXh0U2libGluZylcblx0XHRlbHNlIHBhcmVudC5hcHBlbmRDaGlsZChkb20pXG5cdH1cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemUgfHwgMVxuXHRcdFx0XHRcdGlmIChjb3VudDAgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudDApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vYXR0cnMyXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG51bGwsIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5MiA9PT0gXCJrZXlcIiB8fCBrZXkyID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5MikpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHJldHVyblxuXHRcdHZhciBuc0xhc3RJbmRleCA9IGtleTIuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkyLnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5Mi5zbGljZShuc0xhc3RJbmRleCArIDEpLCB2YWx1ZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkyKSAmJiBucyA9PT0gdW5kZWZpbmVkICYmICFpc0N1c3RvbUVsZW1lbnQodm5vZGUpKSB7XG5cdFx0XHRpZiAoa2V5MiA9PT0gXCJ2YWx1ZVwiKSB7XG5cdFx0XHRcdHZhciBub3JtYWxpemVkMCA9IFwiXCIgKyB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0XHRcdC8vc2V0dGluZyBpbnB1dFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSBieSB0eXBpbmcgb24gZm9jdXNlZCBlbGVtZW50IG1vdmVzIGN1cnNvciB0byBlbmQgaW4gQ2hyb21lXG5cdFx0XHRcdGlmICgodm5vZGUudGFnID09PSBcImlucHV0XCIgfHwgdm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHQvL3NldHRpbmcgc2VsZWN0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUuZG9tLnNlbGVjdGVkSW5kZXggPT09IC0xICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9sZCAhPT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBvbGQgIT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwKSByZXR1cm5cblx0XHRcdH1cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZTEgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExIHdpdGggYW4gYXNzaWdubWVudCBleHByZXNzaW9uLCBhbiBlcnJvcjAgd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50W2tleTJdID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdH1cblx0XHRcdGVsc2UgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleTIsIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRyczIudmFsdWUsIHVuZGVmaW5lZClcblx0XHRcdGlmIChcInNlbGVjdGVkSW5kZXhcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRyczIuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRyczIsIG5zKSB7XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQgJiYgb2xkW2tleTJdLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRyczIgPT0gbnVsbCB8fCAhKGtleTIgaW4gYXR0cnMyKSkge1xuXHRcdFx0XHRcdGlmIChrZXkyID09PSBcImNsYXNzTmFtZVwiKSBrZXkyID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmICFpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkyICE9PSBcImtleVwiKSB2bm9kZS5kb20ucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBzdHlsZSkge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleTJdID0gc3R5bGVba2V5Ml1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleTIgaW4gb2xkKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5MiBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9ldmVudFxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleTIgaW4gZWxlbWVudCkgZWxlbWVudFtrZXkyXSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2FsbGJhY2sgOiBudWxsXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0ga2V5Mi5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXkyXSAhPSBudWxsKSBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXkyXSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGRvbS5uYW1lc3BhY2VVUklcblx0XHQvLyBGaXJzdCB0aW1lMCByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgbmFtZXNwYWNlID09PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Ly8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gcmV0dXJuIG51bGwgaW4gSUUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcblx0XHRpZiAoYWN0aXZlICE9IG51bGwgJiYgJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS42XCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!***************************!*\
  !*** ./assets/app/app.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.restart = exports.reset = exports.byId = exports.estimateLadda = exports.d3mProblemDescription = exports.d3mMetrics = exports.d3mTaskSubtype = exports.d3mTaskType = exports.domainIdentifier = exports.callHistory = exports.links = exports.nodes = exports.allResults = exports.allNodes = exports.valueKey = exports.modelCount = exports.zparams = exports.logArray = exports.locktoggle = exports.transformList = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.cdb = exports.pip_prop = exports.is_results_mode = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _arguments = arguments;\nexports.main = main;\nexports.findNodeIndex = findNodeIndex;\nexports.findNode = findNode;\nexports.clickVar = clickVar;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.helpmaterials = helpmaterials;\nexports.lockDescription = lockDescription;\nexports.zPop = zPop;\nexports.downloadIncomplete = downloadIncomplete;\nexports.estimate = estimate;\nexports.ta2stuff = ta2stuff;\nexports.makeRequest = makeRequest;\nexports.legend = legend;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.endsession = endsession;\nexports.deletepipelines = deletepipelines;\nexports.cancelpipelines = cancelpipelines;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.expandrightpanel = expandrightpanel;\nexports.btnWidths = btnWidths;\nexports.resultsplotinit = resultsplotinit;\nexports.genconfdata = genconfdata;\nexports.confusionmatrix = confusionmatrix;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\nexports.exportpipeline = exportpipeline;\nexports.deletepipeline = deletepipeline;\nexports.ta3_search_message = ta3_search_message;\nexports.test_msg_ta3_search = test_msg_ta3_search;\nexports.end_ta3_search = end_ta3_search;\nexports.record_user_metadata = record_user_metadata;\n\nvar _hopscotch = __webpack_require__(/*! hopscotch */ 15);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(/*! ./plots.js */ 2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn't.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn't supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\nvar is_results_mode = exports.is_results_mode = true;\nvar pip_prop = exports.pip_prop = [];\n// for debugging - if not in PRODUCTION, prints args\nvar cdb = exports.cdb = function cdb(_) {\n    var _console;\n\n    return PRODUCTION || (_console = console).log.apply(_console, _arguments);\n};\n\nvar k = 4; // strength parameter for group attraction/repulsion\nvar tutorial_mode = false;\nvar first_load = true;\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = '#419641';\nvar dvColor = exports.dvColor = '#28a4c9';\nvar gr1Color = exports.gr1Color = '#14bdcc'; // initially was #24a4c9', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = '#ffcccc';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = '#c0c0c0';\nvar nomColor = exports.nomColor = '#ff6600';\nvar varColor = exports.varColor = '#f0f8ff'; // d3.rgb(\"aliceblue\");\nvar taggedColor = '#f5f5f5'; // d3.rgb(\"whitesmoke\");\nvar timeColor = exports.timeColor = '#2d6ca2';\n\nvar lefttab = exports.lefttab = 'tab1'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\nvar righttab = exports.righttab = 'btnModels'; // current tab in right panel\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = exports.transformList = 'log(d) exp(d) d^2 sqrt(d) interact(d,e)'.split(' ');\nvar transformVar = '';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = \"add\";\nvar layoutMove = \"move\";\n\n// radius of circle\nvar RADIUS = 40;\n\n// cx, cy, r values for indicator lights\nvar ind1 = [(RADIUS + 30) * Math.cos(1.3), -1 * (RADIUS + 30) * Math.sin(1.3), 5];\nvar ind2 = [(RADIUS + 30) * Math.cos(1.1), -1 * (RADIUS + 30) * Math.sin(1.1), 5];\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = [\"true\"];\nvar locktoggle = exports.locktoggle = true;\nvar priv = true;\n\n// swandive is our graceful fail for d3m\n// swandive set to true if task is in failset\nvar swandive = false;\nvar failset = [\"TIMESERIESFORECASTING\", \"GRAPHMATCHING\", \"LINKPREDICTION\", \"timeSeriesForecasting\", \"graphMatching\", \"linkPrediction\"];\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: \"\",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.lenght the number of groups\n    zdataurl: \"\",\n    zd3mdata: \"\", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: \"\",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: \"\",\n    zdatacite: '...',\n    zcrosstab: [],\n    zusername: ''\n};\n\nvar modelCount = exports.modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = exports.allResults = [];\nvar nodes = exports.nodes = [];\nvar links = exports.links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = exports.callHistory = []; // transform and subset calls\nvar mytarget = '';\n\nvar configurations = {};\nvar datadocument = {};\n\nvar domainIdentifier = exports.domainIdentifier = null; // available throughout apps js; used for saving workspace\n\n// eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mTaskType = exports.d3mTaskType = {\n    taskTypeUndefined: [\"description\", \"TASK_TYPE_UNDEFINED\", 0],\n    classification: [\"description\", \"CLASSIFICATION\", 1],\n    regression: [\"description\", \"REGRESSION\", 2],\n    clustering: [\"description\", \"CLUSTERING\", 3],\n    linkPrediction: [\"description\", \"LINK_PREDICTION\", 4],\n    vertexNomination: [\"description\", \"VERTEX_NOMINATION\", 5],\n    communityDetection: [\"description\", \"COMMUNITY_DETECTION\", 6],\n    graphClustering: [\"description\", \"GRAPH_CLUSTERING\", 7],\n    graphMatching: [\"description\", \"GRAPH_MATCHING\", 8],\n    timeSeriesForecasting: [\"description\", \"TIME_SERIES_FORECASTING\", 9],\n    collaborativeFiltering: [\"description\", \"COLLABORATIVE_FILTERING\", 10]\n};\n\nvar d3mTaskSubtype = exports.d3mTaskSubtype = {\n    taskSubtypeUndefined: [\"description\", \"TASK_SUBTYPE_UNDEFINED\", 0],\n    subtypeNone: [\"description\", \"NONE\", 1],\n    binary: [\"description\", \"BINARY\", 2],\n    multiClass: [\"description\", \"MULTICLASS\", 3],\n    multiLabel: [\"description\", \"MULTILABEL\", 4],\n    univariate: [\"description\", \"UNIVARIATE\", 5],\n    multivariate: [\"description\", \"MULTIVARIATE\", 6],\n    overlapping: [\"description\", \"OVERLAPPING\", 7],\n    nonOverlapping: [\"description\", \"NONOVERLAPPING\", 8]\n};\n/*export let d3mOutputType = {\n    outputUndefined:[\"description\",\"OUTPUT_TYPE_UNDEFINED \", 0],\n    predictionsFile:[\"description\",\"PREDICTIONS_FILE\",1],\n    scoresFile:[\"description\",\"SCORES_FILE\",2]\n}; */\nvar d3mMetrics = exports.d3mMetrics = {\n    metricUndefined: [\"description\", \"METRIC_UNDEFINED\", 0],\n    executionTime: [\"description\", \"EXECUTION_TIME\", 1],\n    accuracy: [\"description\", \"ACCURACY\", 2],\n    f1: [\"description\", \"F1\", 3],\n    f1Micro: [\"description\", \"F1_MICRO\", 4],\n    f1Macro: [\"description\", \"F1_MACRO\", 5],\n    rocAuc: [\"description\", \"ROC_AUC\", 6],\n    rocAucMicro: [\"description\", \"ROC_AUC_MICRO\", 7],\n    rocAucMacro: [\"description\", \"ROC_AUC_MACRO\", 8],\n    meanSquaredError: [\"description\", \"MEAN_SQUARED_ERROR\", 9],\n    rootMeanSquaredError: [\"description\", \"ROOT_MEAN_SQUARED_ERROR\", 10],\n    rootMeanSquaredErrorAvg: [\"description\", \"ROOT_MEAN_SQUARED_ERROR_AVG\", 11],\n    meanAbsoluteError: [\"description\", \"MEAN_ABSOLUTE_ERROR\", 12],\n    rSquared: [\"description\", \"R_SQUARED\", 13],\n    normalizedMutualInformation: [\"description\", \"NORMALIZED_MUTUAL_INFORMATION\", 14],\n    jaccardSimilarityScore: [\"description\", \"JACCARD_SIMILARITY_SCORE\", 15]\n};\n\nvar d3mProblemDescription = exports.d3mProblemDescription = {\n    taskType: [2, \"DEFAULT\"],\n    taskSubtype: [1, \"DEFAULT\"],\n    //   outputType: [3,\"DEFAULT\"],\n    metric: [3, \"DEFAULT\"],\n    taskDescription: \"\"\n};\n\nvar svg = void 0,\n    width = void 0,\n    height = void 0,\n    div = void 0,\n    selectLadda = void 0;\nvar estimateLadda = exports.estimateLadda = void 0;\n\n// arcs for denoting pebble characteristics\nvar arc = function arc(start, end) {\n    return d3.svg.arc().innerRadius(RADIUS + 5).outerRadius(RADIUS + 20).startAngle(start).endAngle(end);\n};\nvar _ref = [arc(0, 3.2), arc(0, 1), arc(1.1, 2.2), arc(2.3, 3.3), arc(4.3, 5.3)],\n    arc0 = _ref[0],\n    arc1 = _ref[1],\n    arc2 = _ref[2],\n    arc3 = _ref[3],\n    arc4 = _ref[4];\n\nvar arcInd = function arcInd(arclimits) {\n    return d3.svg.arc().innerRadius(RADIUS + 22).outerRadius(RADIUS + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n};\n\nvar arcInd1Limits = [0, 0.3],\n    arcInd2Limits = [0.35, 0.65];\nvar _ref2 = [arcInd(arcInd1Limits), arcInd(arcInd2Limits)],\n    arcInd1 = _ref2[0],\n    arcInd2 = _ref2[1];\nvar byId = exports.byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n/**\n   page reload linked to btnReset\n*/\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\nvar _restart2 = void 0;\n\nexports.restart = _restart2;\nvar dataurl = '';\n\n/**\n  called by main\n  Loads all external data in the following order (logic is not included):\n  1. Retrieve the configuration information\n  2. Set 'configurations'\n  3. Read the problem schema and set 'd3mProblemDescription'\n  4. Read the data document and set 'datadocument'\n  5. Read in zelig models (not for d3m)\n  6. Read in zeligchoice models (not for d3m)\n  7. Start the user session\n  8. Read preprocess data or (if necessary) run preprocess\n  9. Build allNodes[] using preprocessed information\n  10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n  11. Call layout() and start up\n*/\nasync function load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL) {\n    if (!IS_D3M_DOMAIN) {\n        return;\n    }\n\n    // 1. Retrieve the configuration information\n    var res = await _mithril2.default.request({\n        method: \"POST\",\n        url: \"/config/d3m-config/json/latest\"\n    });\n    console.log(res);\n    // 2. Set 'configurations'\n    configurations = JSON.parse(JSON.stringify(res)); // this is just copying res\n    d3mRootPath = configurations.training_data_root.replace(/\\/data/, '');\n    d3mDataName = configurations.name;\n\n    // scopes at app.js level; used for saving workspace\n    exports.domainIdentifier = domainIdentifier = { name: configurations.name,\n        source_url: configurations.config_url,\n        description: 'D3M config file' };\n    //id: configurations.id};\n\n    d3mPS = \"/config/d3m-config/get-problem-schema/json\";\n    d3mDS = \"/config/d3m-config/get-dataset-schema/json\";\n    console.log(\"Configurations: \", configurations);\n    d3mPreprocess = pURL = 'rook-custom/rook-files/' + d3mDataName + '/preprocess/preprocess.json';\n\n    // 3. Read the problem schema and set 'd3mProblemDescription'\n    // ...and make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n\n    res = await _mithril2.default.request(\"/config/d3m-config/get-problem-data-file-info\");\n\n    // some simple logic to get the paths right\n    // note that if neither exist, stay as default which is null\n\n    var set = function set(field, val) {\n        return res.data[field].exists ? res.data[field].path : res.data[field + '.gz'].exists ? res.data[field + '.gz'].path : val;\n    };\n\n    zparams.zd3mdata = d3mData = set('learningData.csv', d3mData);\n    zparams.zd3mtarget = set('learningData.csv', d3mData);\n\n    // hardcoding this, once get-problem-data-file-info is revised this hardcode can go away and use the previous two LOC\n    //  zparams.zd3mdata = d3mData = d3mRootPath+\"/dataset_TRAIN/tables/learningData.csv\";\n    //  zparams.zd3mtarget = d3mRootPath+\"/dataset_TRAIN/tables/learningData.csv\";\n\n    res = await _mithril2.default.request(d3mPS);\n    console.log(\"prob schema data: \", res);\n\n    mytarget = res.inputs.data[0].targets[0].colName; // easier way to access target name?\n\n    //  set = (field, arr) => d3mProblemDescription[field] = res[field] in arr ? res[field] : field + 'Undefined';\n    d3mProblemDescription.taskType = res.about.taskType;\n    d3mProblemDescription.taskSubtype = res.about.taskSubType;\n    d3mProblemDescription.metric = res.inputs.performanceMetrics[0].metric;\n    //   d3mProblemDescription.outputType = res.expectedOutputs.predictionsFile;\n    //   set('taskType', d3mTaskType);\n    //   set('taskSubtype', d3mTaskSubtype);\n    //   set('metric', d3mMetrics);\n    //   set('outputType', d3mOutputType);\n    d3mProblemDescription.taskDescription = res.descriptionFile;\n    byId(\"btnType\").click();\n\n    // making it case insensitive because the case seems to disagree all too often\n    if (failset.includes(d3mProblemDescription.taskType.toUpperCase())) {\n        swandive = true;\n    }\n\n    // 4. Read the data document and set 'datadocument'\n    datadocument = await _mithril2.default.request(d3mDS);\n\n    if (IS_D3M_DOMAIN) {\n        var datasetName = datadocument.about.datasetName; // Use \"datasetName\" field in dataset document\n        zparams.zdata = datasetName.charAt(0).toUpperCase() + datasetName.slice(1); // Make sure to capitalize;\n        var cite = datadocument.about.citation;\n        console.log(cite);\n        var newcite = cite.match(/{\\s*[\\w\\.]+\\s*}/g).map(function (x) {\n            return x.match(/[\\w\\.]+/)[0];\n        });\n        console.log(newcite);\n        /*\n        // clean citation\n        zparams.zdatacite = cite\n            .replace(/\\&/g, \"and\")\n            .replace(/\\;/g, \",\")\n            .replace(/\\%/g, \"-\");\n        // fill in citation in header\n        $('#cite div.panel-body').text(zparams.zdatacite);\n        */\n    } else {\n        // Note: presently xml is no longer being read from Dataverse metadata anywhere\n        var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n        zparams.zdata = temp[0].childNodes[0].nodeValue;\n        var _cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n        // clean citation so POST is valid json\n        zparams.zdatacite = _cite[0].childNodes[0].nodeValue.replace(/\\&/g, \"and\").replace(/\\;/g, \",\").replace(/\\%/g, \"-\");\n        // fill in citation in header\n        $('#cite div.panel-body').text(zparams.zdatacite);\n    }\n    // drop file extension\n    var dataname = IS_D3M_DOMAIN ? zparams.zdata : zparams.zdata.replace(/\\.(.*)/, '');\n\n    d3.select(\"#dataName\").html(dataname);\n\n    // put dataset name, from meta-data, into page title\n    d3.select(\"title\").html(\"TwoRavens \" + dataname);\n\n    // if swandive, we have to set valueKey here so that left panel can populate\n    if (swandive) {\n        [datadocument.trainData.trainData, datadocument.trainData.trainTargets].forEach(function (vars) {\n            return vars && vars.forEach(function (v) {\n                return valueKey.push(v.varName);\n            });\n        });\n        // end session if neither trainData nor trainTargets?\n        valueKey.length === 0 && alert(\"no trainData or trainTargest in data description file. valueKey length is 0\");\n        // perhaps allow users to unlock and select things?\n        byId('btnLock').classList.add('noshow');\n        byId('btnForce').classList.add('noshow');\n        byId('btnEraser').classList.add('noshow');\n        byId('btnSubset').classList.add('noshow');\n        byId('main').style.backgroundColor = 'grey';\n        byId('whitespace').style.backgroundColor = 'grey';\n    }\n\n    console.log(\"data schema data: \", datadocument);\n\n    // 5. Read in zelig models (not for d3m)\n    // 6. Read in zeligchoice models (not for d3m)\n    if (!IS_D3M_DOMAIN) {\n        var _arr = ['zelig5models', 'zelig5choicemodels'];\n\n        var _loop = async function _loop() {\n            var field = _arr[_i];\n            try {\n                res = await _mithril2.default.request('data/' + field + '.json');\n                cdb(field + ' json: ', res);\n                res[field].filter(function (key) {\n                    return res[field].hasOwnProperty(key);\n                }).forEach(function (key) {\n                    return mods[key.name[0]] = key.description[0];\n                });\n            } catch (_) {\n                console.log(\"can't load \" + field);\n            }\n        };\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n            await _loop();\n        }\n    }\n    // 7. Start the user session\n    // rpc StartSession(SessionRequest) returns (SessionResponse) {}\n    res = await makeRequest(D3M_SVC_URL + '/startsession', { user_agent: 'some agent', version: 'some version' });\n    if (res) {\n        zparams.zsessionid = res.context.sessionId;\n    }\n\n    // hopscotch tutorial\n    if (tutorial_mode) {\n        console.log('Starting Hopscotch Tour');\n        var step = function step(target, placement, title, content) {\n            return {\n                target: target,\n                placement: placement,\n                title: title,\n                content: content,\n                showCTAButton: true,\n                ctaLabel: 'Disable these messages',\n                onCTA: function onCTA() {\n                    _hopscotch2.default.endTour(true);\n                    tutorial_mode = false;\n                }\n            };\n        };\n        _hopscotch2.default.startTour({\n            id: \"dataset_launch\",\n            i18n: { doneBtn: 'Ok' },\n            showCloseButton: false,\n            scrollDuration: 300,\n            onEnd: function onEnd() {\n                return first_load = false;\n            },\n            steps: [step(\"dataName\", \"bottom\", \"Welcome to TwoRavens Solver\", '<p>This tool can guide you to solve an empirical problem in the dataset above.</p>\\n                      <p>These messages will teach you the steps to take to find and submit a solution.</p>'), step(\"btnReset\", \"bottom\", \"Restart Any Problem Here\", '<p>You can always start a problem over by using this reset button.</p>'), step(\"btnEstimate\", \"left\", \"Solve Problem\", '<p>The current green button is generally the next step to follow to move the system forward.</p>\\n                      <p>Click this Solve button to tell the tool to find a solution to the problem.</p>'), step(mytarget + 'biggroup', \"left\", \"Target Variable\", 'This is the variable, ' + mytarget + ', we are trying to predict.\\n                      This center panel graphically represents the problem currently being attempted.'), step(\"gr1hull\", \"right\", \"Explanation Set\", \"This set of variables can potentially predict the target.\"), step(\"displacement\", \"right\", \"Variable List\", '<p>Click on any variable name here if you wish to remove it from the problem solution.</p>\\n                      <p>You likely do not need to adjust the problem representation in the center panel.</p>'), step(\"btnEndSession\", \"bottom\", \"Finish Problem\", \"If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.\")]\n        });\n        console.log('Ending Hopscotch Tour');\n    }\n\n    // 8. read preprocess data or (if necessary) run preprocess\n    // NOTE: preprocess.json is now guaranteed to exist...\n\n    //mital : Custom pipeline object\n    var pipeline_obj = [{\n        \"pipelineId\": \"pipeline_1\",\n        \"modules\": [{\n            \"id\": \"module_id 0\",\n            \"type\": \"module_type 0\",\n            \"label\": \"module_label 0\",\n            \"inputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\",\n                \"value\": \"value 0\"\n            }],\n            \"outputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\"\n            }]\n        }, {\n            \"id\": \"module_id 1\",\n            \"type\": \"module_type 1\",\n            \"label\": \"module_label 1\",\n            \"inputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\",\n                \"value\": \"value 0\"\n            }],\n            \"outputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\"\n            }]\n        }],\n        \"connections\": [{\n            \"fromModuleId\": \"module 0\",\n            \"fromOutputName\": \"from_output_name 0\",\n            \"toModuleId\": \"to_module_id 0\",\n            \"toInputName\": \"to_input_name 0\"\n        }, {\n            \"fromModuleId\": \"module 1\",\n            \"fromOutputName\": \"from_output_name 1\",\n            \"toModuleId\": \"to_module_id 1\",\n            \"toInputName\": \"to_input_name 1\"\n        }],\n        \"responseInfo\": {\n            \"status\": {\n                \"code\": \"OK\",\n                \"details\": \"(static test response)\"\n            }\n        }\n    }, {\n        \"pipelineId\": \"pipeline_2\",\n        \"modules\": [{\n            \"id\": \"module_id 0\",\n            \"type\": \"module_type 0\",\n            \"label\": \"module_label 0\",\n            \"inputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\",\n                \"value\": \"value 0\"\n            }],\n            \"outputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\"\n            }]\n        }, {\n            \"id\": \"module_id 1\",\n            \"type\": \"module_type 1\",\n            \"label\": \"module_label 1\",\n            \"inputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\",\n                \"value\": \"value 0\"\n            }],\n            \"outputs\": [{\n                \"name\": \"nome 0\",\n                \"type\": \"type 0\"\n            }]\n        }],\n        \"connections\": [{\n            \"fromModuleId\": \"module 0\",\n            \"fromOutputName\": \"from_output_name 0\",\n            \"toModuleId\": \"to_module_id 0\",\n            \"toInputName\": \"to_input_name 0\"\n        }, {\n            \"fromModuleId\": \"module 1\",\n            \"fromOutputName\": \"from_output_name 1\",\n            \"toModuleId\": \"to_module_id 1\",\n            \"toInputName\": \"to_input_name 1\"\n        }],\n        \"responseInfo\": {\n            \"status\": {\n                \"code\": \"OK\",\n                \"details\": \"(static test response)\"\n            }\n        }\n    }];\n    // console.log(\"pipeline\")\n    // console.log(pipeline_obj[0].pipelineId)\n    var count = 0;\n    if (is_results_mode) {\n        pipeline_obj.forEach(function (pipe) {\n            // console.log('pipe')\n            // console.log(pipe)\n            preprocess[count++] = pipe;\n            console.log(preprocess);\n        });\n    } else {\n\n        var read = function read(res) {\n            priv = res.dataset.private || priv;\n            console.log('res piplies');\n            console.log(res);\n            Object.keys(res.variables).forEach(function (k) {\n                return preprocess[k] = res.variables[k];\n            });\n            return res;\n        };\n        try {\n            console.log('attempt to read preprocess file (which may not exist): ' + pURL);\n            if (is_results_mode) {\n                res = read((await pipeline_obj)); //await m.request(pURL));\n            } else {\n                res = read((await _mithril2.default.request(pURL)));\n            }\n            console.log(\"res..\");\n            console.log(res);\n        } catch (_) {\n            console.log(\"Ok, preprocess not found, try to RUN THE PREPROCESSAPP\");\n            var url = ROOK_SVC_URL + 'preprocessapp';\n            var json_input;\n            if (IS_D3M_DOMAIN) {\n                // For D3M inputs, change the preprocess input data\n                //\n                json_input = JSON.stringify({ data: d3mData, datastub: d3mDataName });\n            } else {\n                json_input = JSON.stringify({ data: dataloc, target: targetloc, datastub: datastub });\n            }\n\n            console.log('json_input: ', json_input);\n            console.log('url: ', url);\n            var data = new FormData();\n            try {\n                res = read((await _mithril2.default.request({ method: 'POST', url: url, data: json_input })));\n            } catch (_) {\n                console.log('preprocess failed');\n                alert('preprocess failed. ending user session.');\n                endsession();\n            }\n        }\n    }\n\n    // 9. Build allNodes[] using preprocessed information\n    var vars = Object.keys(preprocess);\n    console.log(\"preprocess-vars\");\n    console.log(preprocess);\n    // vars = [\"pipeline_1\", \"pipeline_2\"]\n\n    // temporary values for hold that correspond to histogram bins\n    hold = [.6, .2, .9, .8, .1, .3, .4];\n    for (var i = 0; i < vars.length; i++) {\n        // valueKey[i] = vars[i].attributes.name.nodeValue;\n        // lablArray[i] = varsXML[i].getElementsByTagName(\"labl\").length == 0 ?\n        // \"no label\" :\n        // varsXML[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n        // let datasetcount = d3.layout.histogram()\n        //     .bins(barnumber).frequency(false)\n        //     ([0, 0, 0, 0, 0]);\n        valueKey[i] = vars[i];\n        lablArray[i] = \"no label\";\n        // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n        // such as setx values (if the user has selected them) and pebble coordinates\n        var obj = {\n            id: i,\n            reflexive: false,\n            name: preprocess[valueKey[i]].pipelineId,\n            labl: lablArray[i],\n            data: [5, 15, 20, 0, 5, 15, 20],\n            count: hold,\n            nodeCol: colors(i),\n            baseCol: colors(i),\n            strokeColor: _plots.selVarColor,\n            strokeWidth: \"1\",\n            subsetplot: false,\n            subsetrange: [\"\", \"\"],\n            setxplot: false,\n            setxvals: [\"\", \"\"],\n            grayout: false,\n            group1: false,\n            group2: false,\n            forefront: false,\n            expand: false\n        };\n        console.log(\"obj before merge\");\n        console.log(obj);\n        console.log(\"preprocess\");\n        console.log(preprocess[valueKey[i]]);\n        console.log(\"value Key\");\n        console.log(valueKey[i]);\n        jQuery.extend(true, obj, preprocess[valueKey[i]]);\n        console.log(\"obj after merge\");\n        console.log(obj);\n        allNodes.push(obj);\n\n        //\n    }\n    console.log(\"...All nodes\");\n    console.log(allNodes);\n\n    var len = allNodes.length;\n\n    for (var _i2 = 0; _i2 < allNodes.length; _i2++) {\n        for (var j = 0; j < allNodes[_i2].modules.length; j++) {\n            var _obj = {\n                id: len++,\n                reflexive: false,\n                name: allNodes[_i2].modules[j].id,\n                labl: \"no labels\",\n                data: [5, 15, 20, 0, 5, 15, 20],\n                count: hold,\n                nodeCol: allNodes[_i2].nodeCol, // Need to change to different shade ; add a function\n                baseCol: allNodes[_i2].nodeCol,\n                strokeColor: _plots.selVarColor,\n                strokeWidth: \"1\",\n                subsetplot: false,\n                subsetrange: [\"\", \"\"],\n                setxplot: false,\n                setxvals: [\"\", \"\"],\n                grayout: false,\n                group1: false,\n                group2: true,\n                forefront: false,\n                parent: allNodes[_i2].pipelineId\n\n            };\n            pip_prop.push(_obj);\n\n            // console.log(allNodes[i].properties[j]);\n        }\n        console.log(pip_prop);\n    }\n\n    console.log(\"allNodes\");\n    console.log(allNodes);\n    console.log(allNodes.length);\n\n    // 10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n    if (!is_results_mode) {\n        var datavars = datadocument.dataResources[0].columns;\n        datavars.forEach(function (v, i) {\n            var myi = findNodeIndex(v.colName);\n            allNodes[myi] = Object.assign(allNodes[myi], { d3mDescription: v });\n        });\n    }\n\n    // result_layout(false, true);\n    // 11. Call layout() and start uplayout\n    if (is_results_mode) {\n        result_layout(false, true);\n    } else {\n        layout(false, true);\n    }\n\n    IS_D3M_DOMAIN ? zPop() : dataDownload();\n}\n\n/**\n   called on app start\n   @param {string} fileid\n   @param {string} hostname\n   @param {string} ddiurl\n   @param {string} dataurl\n   @param {string} apikey\n*/\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    if (PRODUCTION && fileid === '') {\n        var msg = 'Error: No fileid has been provided.';\n        alert(msg);\n        throw new Error(msg);\n    }\n\n    var dataverseurl = hostname ? 'https://' + hostname : PRODUCTION ? DATAVERSE_URL : 'http://localhost:8080';\n    // if file id supplied, assume we are dealing with dataverse and cook a standard dataverse data access url\n    // with the fileid supplied and the hostname we have supplied or configured\n    dataurl = fileid && !dataurl ? dataverseurl + '/api/access/datafile/' + fileid + '?key=' + apikey : dataurl;\n    cdb('--dataurl: ' + dataurl);\n    cdb('--dataverseurl: ' + dataverseurl);\n\n    var tempWidth = d3.select('#main.left').style('width');\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // hard code header, footer, and bottom margin\n\n    exports.estimateLadda = estimateLadda = Ladda.create(byId(\"btnEstimate\"));\n    selectLadda = Ladda.create(byId(\"btnSelect\"));\n    svg = d3.select(\"#whitespace\");\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( RADIUS )//(RADIUS+35) * Math.sin(degree))\n    //     .cy( RADIUS )//(RADIUS+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var hold = [],\n        lablArray = [];\n\n    // assume locations are consistent based on d3m directory structure\n\n    var d3mRootPath = '';\n    var d3mDataName = '';\n    var d3mData = null;\n    var d3mPreprocess = '';\n    var d3mPS = '';\n    var d3mDS = '';\n\n    // default to Fearon Laitin\n    var data = 'data/' + (false ? 'PUMS5small' : 'fearonLaitin');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + '/api/meta/datafile/' + fileid : data + '.xml');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + '&format=prep' : data + '.json';\n\n    if (IS_D3M_DOMAIN) {\n        pURL = d3mPreprocess;\n    } else if (!PRODUCTION) {\n        zparams.zdataurl = 'data/fearonLaitin.tsv';\n    }\n\n    load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL);\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr('fill-opacity', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill('#' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n/**\n   deletes the item at index from array.\n   if object is provided, deletes first instance of object from array.\n   @param {Object[]} arr - array\n   @param {number} idx - index\n   @param {Object} [obj] - object\n*/\nfunction del(arr, idx, obj) {\n    idx = obj ? arr.indexOf(obj) : idx;\n    idx > -1 && arr.splice(idx, 1);\n}\n\n/** needs doc */\nfunction zparamsReset(text) {\n    'zdv zcross ztime znom'.split(' ').forEach(function (x) {\n        return del(zparams[x], -1, text);\n    });\n}\n//--- mital result layout function\n\nfunction result_layout(v, v2) {\n    console.log(\"in layout function\");\n    var pipeline_p = [];\n    exports.nodes = nodes = [];\n    exports.links = links = [];\n\n    svg.append(\"svg:defs\").append(\"svg:marker\").attr(\"id\", \"group1-arrow\").attr('viewBox', '0 -5 15 15').attr(\"refX\", 2.5).attr(\"refY\", 0).attr(\"markerWidth\", 3).attr(\"markerHeight\", 3).attr(\"orient\", \"auto\").append(\"path\").attr('d', 'M0,-5L10,0L0,5').style(\"fill\", gr1Color);\n\n    svg.append(\"svg:defs\").append(\"svg:marker\").attr(\"id\", \"group2-arrow\").attr('viewBox', '0 -5 15 15').attr(\"refX\", 2.5).attr(\"refY\", 0).attr(\"markerWidth\", 3).attr(\"markerHeight\", 3).attr(\"orient\", \"auto\").append(\"path\").attr('d', 'M0,-5L10,0L0,5').style(\"fill\", gr2Color);\n\n    var line = svg.append(\"line\").style('fill', 'none').style('stroke', gr1Color).style('stroke-width', 5).attr(\"marker-end\", \"url(#group1-arrow)\");\n\n    var line2 = svg.append(\"line\").style('fill', 'none').style('stroke', gr2Color).style('stroke-width', 5).attr(\"marker-end\", \"url(#group2-arrow)\");;\n\n    var visbackground = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    visbackground.append(\"path\") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr(\"id\", 'gr1background').style(\"fill\", '#ffffff').style(\"stroke\", '#ffffff').style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round').style(\"opacity\", 1);\n\n    var vis2background = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis2background.append(\"path\").attr(\"id\", 'gr1background').style(\"fill\", '#ffffff').style(\"stroke\", '#ffffff').style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round').style(\"opacity\", 1);\n\n    var vis = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis.append(\"path\").attr(\"id\", 'gr1hull').style(\"fill\", gr1Color).style(\"stroke\", gr1Color).style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round');\n\n    var vis2 = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis2.append(\"path\").style(\"fill\", gr2Color).style(\"stroke\", gr2Color).style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue; // here mital\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(0, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-function (d) {\n        return -100 * d.r;\n    }).on('tick', tick);\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n    //line = svg.append('svg:g').selectAll('line');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n                targetPadding = d.right ? RADIUS + 5 : RADIUS,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n\n        circle.selectAll('circle') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr('r', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = '';\n                return varColor;\n            }\n        });\n        _restart2();\n    });\n\n    d3.select(\"#types\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n        } else {\n            d3.select(\"#types\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"taskType\", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select(\"#subtypes\").selectAll(\"p\").on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n        } else {\n            d3.select(\"#subtypes\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"taskSubtype\", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select(\"#metrics\").selectAll(\"p\").on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n            // d3mProblemDescription.metric = [\"\",\"\"];\n            // this.className=\"item-default\";\n        } else {\n            d3.select(\"#metrics\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"metric\", d3mProblemDescription, d3mMetrics);\n    });\n\n    // update graph (called when needed)\n    exports.restart = _restart2 = function restart($links, is_explore) {\n        exports.links = links = $links || links;\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == \"true\") {\n            force.gravity(0.05);\n            force.charge(function (d) {\n                return setPebbleCharge(d * -5);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0.2);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return !is_explore && x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return !is_explore && x.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return !is_explore && x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return !is_explore && x.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) del(links, j);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll('circle').classed('reflexive', function (x) {\n            return x.reflexive;\n        }).style('fill', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style('stroke', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style('stroke-width', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append('svg:g').attr('id', function (x) {\n            return x.name + 'biggroup';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == 'continuous') (0, _plots.densityNode)(d, this);else if (d.plottype == 'bar') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || 'id'];\n            };\n        };\n\n        g.append(\"path\").attr(\"id\", append('dvArc')).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, 'dvText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, 'dvText', 0, 100, 500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            _restart2();\n            d.group1 = d.group2 = false;\n        });\n\n        g.append(\"text\").attr(\"id\", append('dvText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#dvArc')).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", append('nomArc')).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, \"nomText\", .9, 0, 100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, \"nomText\", 0, 100, 500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            _restart2();\n        });\n\n        g.append(\"text\").attr(\"id\", append(\"nomText\")).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append(\"#nomArc\")).text(\"Nominal\");\n\n        g.append(\"path\").attr(\"id\", append('grArc')).attr(\"d\", arc1).style(\"fill\", gr1Color).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fill(d, \"gr1indicator\", .3, 0, 100);\n            fill(d, \"gr2indicator\", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fill(d, \"gr1indicator\", 0, 100, 500);\n            fill(d, \"gr2indicator\", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart2();\n        });\n\n        g.append(\"path\").attr(\"id\", append('gr1indicator')).attr(\"d\", arcInd1).style(\"fill\", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \"grArc\", 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart2();\n        });\n\n        g.append(\"path\").attr(\"id\", append('gr2indicator')).attr(\"d\", arcInd2).style(\"fill\", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \"grArc\", 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            _restart2();\n        });\n\n        g.append(\"text\").attr(\"id\", append('grText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#grArc')).text(\"Groups\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', function (d) {\n            return setPebbleRadius(d);\n        }).style('pointer-events', 'inherit').style('fill', function (d) {\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (d) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n            console.log(\"pebble\");\n            console.log(nodes);\n            console.log(d);\n            console.log(pip_prop);\n            if (d.group1 && d.expand) {\n                d.expand = false;\n                //use pip_prop\n                for (var p = 0; p < d.modules.length; p++) {\n                    console.log(d.modules[p]);\n                    // if(){}\n                    exports.nodes = nodes = nodes.filter(function (node) {\n                        return node.name !== d.modules[p].id;\n                    });\n                    exports.links = links = links.filter(function (link) {\n                        return link.target.name !== d.modules[p].id;\n                    });\n                }\n                console.log(allNodes);\n                console.log(nodes);\n                _restart2();\n            } else if (d.group1 && !d.expand) {\n                d.expand = true;\n\n                for (var i = 0; i < pip_prop.length; i++) {\n                    console.log(pip_prop[i].parent + \" \" + i);\n                    if (pip_prop[i].parent == d.name) {\n                        console.log(pip_prop[i]);\n                        nodes.push(pip_prop[i]);\n\n                        links.push({\n                            source: nodes[d.id],\n                            target: nodes[nodes.length - 1], // not able to access with object id!!\n                            left: false,\n                            right: true\n                        });\n                    }\n                }\n\n                console.log(nodes);\n\n                _restart2();\n            }\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            _restart2();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            _restart2();\n        });\n\n        // show node names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft('tab3');\n            varSummary(d);\n            d.forefront = true;\n\n            byId('transformations').setAttribute('style', 'display:block');\n            byId(\"transSel\").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, \"dvArc\", .1, 0, 100);\n            fill(d, \"dvText\", .5, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, \"grText\", .5, 0, 100);\n            //fill(d, \"gr1indicator\", .1, 0, 100);\n            //fill(d, \"gr1indicatorText\", .1, 0, 100);\n            //fill(d, \"gr2indicator\", .1, 0, 100);\n            //fill(d, \"gr2indicatorText\", .1, 0, 100);\n\n            if (d.defaultNumchar == \"numeric\") {\n                fill(d, \"nomArc\", .1, 0, 100);\n                fill(d, \"nomText\", .5, 0, 100);\n            }\n            fill(d, \"csArc\", .1, 0, 100);\n            fill(d, \"csText\", .5, 0, 100);\n            fill(d, \"timeArc\", .1, 0, 100);\n            fill(d, \"timeText\", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on('mouseout', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? 'tab2' : 'tab1');\n            'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText'.split(' ').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        if (!IS_D3M_DOMAIN) {\n            $('#transSel li').click(function (evt) {\n                // if 'interaction' is the selected function, don't show the function list again\n                if (selInteract) {\n                    var n = $('#tInput').val().concat($(this).text());\n                    $('#tInput').val(n);\n                    evt.stopPropagation();\n                    var t = transParse(n = n);\n                    if (!t) return;\n                    $(this).parent().fadeOut(100);\n                    transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                    return;\n                }\n\n                $('#tInput').val($(this).text());\n                $(this).parent().fadeOut(100);\n                $('#transList').fadeIn(100);\n                evt.stopPropagation();\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n\n        // save workspaces\n        console.log('ok ws');\n        record_user_metadata();\n    };\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        _restart2();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    _restart2(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent(\"MouseEvents\");\n        // initialize the event\n        click_ev.initEvent(\"click\", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = \"dvArc\" + findNodeIndex(mytarget);\n        byId(clickID).dispatchEvent(click_ev);\n    }\n}\n\n/** needs doc */\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    exports.links = links = [];\n\n    svg.append(\"svg:defs\").append(\"svg:marker\").attr(\"id\", \"group1-arrow\").attr('viewBox', '0 -5 15 15').attr(\"refX\", 2.5).attr(\"refY\", 0).attr(\"markerWidth\", 3).attr(\"markerHeight\", 3).attr(\"orient\", \"auto\").append(\"path\").attr('d', 'M0,-5L10,0L0,5').style(\"fill\", gr1Color);\n\n    svg.append(\"svg:defs\").append(\"svg:marker\").attr(\"id\", \"group2-arrow\").attr('viewBox', '0 -5 15 15').attr(\"refX\", 2.5).attr(\"refY\", 0).attr(\"markerWidth\", 3).attr(\"markerHeight\", 3).attr(\"orient\", \"auto\").append(\"path\").attr('d', 'M0,-5L10,0L0,5').style(\"fill\", gr2Color);\n\n    var line = svg.append(\"line\").style('fill', 'none').style('stroke', gr1Color).style('stroke-width', 5).attr(\"marker-end\", \"url(#group1-arrow)\");\n\n    var line2 = svg.append(\"line\").style('fill', 'none').style('stroke', gr2Color).style('stroke-width', 5).attr(\"marker-end\", \"url(#group2-arrow)\");;\n\n    var visbackground = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    visbackground.append(\"path\") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr(\"id\", 'gr1background').style(\"fill\", '#ffffff').style(\"stroke\", '#ffffff').style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round').style(\"opacity\", 1);\n\n    var vis2background = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis2background.append(\"path\").attr(\"id\", 'gr1background').style(\"fill\", '#ffffff').style(\"stroke\", '#ffffff').style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round').style(\"opacity\", 1);\n\n    var vis = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis.append(\"path\").attr(\"id\", 'gr1hull').style(\"fill\", gr1Color).style(\"stroke\", gr1Color).style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round');\n\n    var vis2 = d3.select(\"#whitespace\").append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    vis2.append(\"path\").style(\"fill\", gr2Color).style(\"stroke\", gr2Color).style(\"stroke-width\", 2.5 * RADIUS).style('stroke-linejoin', 'round');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j2 = 0; _j2 < nodes.length; _j2++) {\n                //populate zvars array\n                if (nodes[_j2].name != mytarget) {\n                    nodes[_j2].group1 = true;\n                    zparams.zgroup1.push(nodes[_j2].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick);\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n    //line = svg.append('svg:g').selectAll('line');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = RADIUS * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = RADIUS * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style(\"opacity\", 1);\n            visbackground.style(\"opacity\", 1);\n            vis.style(\"opacity\", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll(\"path\").data([myhull]) // returns null if less than three coordinates\n            .attr(\"d\", function (d) {\n                return \"M\" + d.join(\"L\") + \"Z\";\n            });\n            visbackground.selectAll(\"path\").data([myhull]) // returns null if less than three coordinates\n            .attr(\"d\", function (d) {\n                return \"M\" + d.join(\"L\") + \"Z\";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr(\"x1\", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr(\"y1\", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr(\"x2\", q[0] - ltargetPadding * lnormX).attr(\"y2\", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style(\"opacity\", 0);\n\n            vis.style(\"opacity\", 0);\n            //            vis.style(\"opacity\", 0);\n            line.style(\"opacity\", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style(\"opacity\", 1);\n            vis2background.style(\"opacity\", 1);\n            vis2.style(\"opacity\", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll(\"path\").data([myhull]) // returns null if less than three coordinates\n            .attr(\"d\", function (d) {\n                return \"M\" + d.join(\"L\") + \"Z\";\n            });\n            vis2background.selectAll(\"path\").data([myhull]) // returns null if less than three coordinates\n            .attr(\"d\", function (d) {\n                return \"M\" + d.join(\"L\") + \"Z\";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                line2.attr(\"x1\", p[0] + lsourcePadding * lnormX).attr(\"y1\", p[1] + lsourcePadding * lnormY).attr(\"x2\", q[0] - ltargetPadding * lnormX).attr(\"y2\", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style(\"opacity\", 0);\n            vis2.style(\"opacity\", 0);\n            line2.style(\"opacity\", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n                targetPadding = d.right ? RADIUS + 5 : RADIUS,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n\n        circle.selectAll('circle') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr('r', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = '';\n                return varColor;\n            }\n        });\n        _restart2();\n    });\n\n    d3.select(\"#types\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n        } else {\n            d3.select(\"#types\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"taskType\", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select(\"#subtypes\").selectAll(\"p\").on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n        } else {\n            d3.select(\"#subtypes\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"taskSubtype\", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select(\"#metrics\").selectAll(\"p\").on(\"click\", function () {\n        if (locktoggle) return;\n        if (this.className == \"item-select\") {\n            return;\n            // d3mProblemDescription.metric = [\"\",\"\"];\n            // this.className=\"item-default\";\n        } else {\n            d3.select(\"#metrics\").select(\"p.item-select\").attr('class', 'item-default');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr('class', \"item-select\");\n        }\n        _restart2();\n        setProblemDefinition(\"metric\", d3mProblemDescription, d3mMetrics);\n    });\n\n    /*  d3.select(\"#outputs\").selectAll(\"p\")\n      .on(\"click\", function() {\n          if(locktoggle) return;\n          if(this.className==\"item-select\") {\n              return;\n          } else {\n              d3.select(\"#outputs\").select(\"p.item-select\")\n              .attr('class', 'item-default');\n              d3mProblemDescription.outputType = this.innerHTML.toString();\n              d3.select(this).attr('class',\"item-select\");\n          }\n          restart();\n          setProblemDefinition(\"outputType\", d3mProblemDescription, d3mOutputType);\n          });\n          */\n\n    // update graph (called when needed)\n    exports.restart = _restart2 = function _restart($links, is_explore) {\n        exports.links = links = $links || links;\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == \"true\") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return !is_explore && x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return !is_explore && x.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return !is_explore && x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return !is_explore && x.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) del(links, j);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll('circle').classed('reflexive', function (x) {\n            return x.reflexive;\n        }).style('fill', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style('stroke', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style('stroke-width', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append('svg:g').attr('id', function (x) {\n            return x.name + 'biggroup';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == 'continuous') (0, _plots.densityNode)(d, this);else if (d.plottype == 'bar') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || 'id'];\n            };\n        };\n\n        g.append(\"path\").attr(\"id\", append('dvArc')).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, 'dvText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, 'dvText', 0, 100, 500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            _restart2();\n            d.group1 = d.group2 = false;\n        });\n\n        g.append(\"text\").attr(\"id\", append('dvText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#dvArc')).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", append('nomArc')).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, \"nomText\", .9, 0, 100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, \"nomText\", 0, 100, 500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            _restart2();\n        });\n\n        g.append(\"text\").attr(\"id\", append(\"nomText\")).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append(\"#nomArc\")).text(\"Nominal\");\n\n        g.append(\"path\").attr(\"id\", append('grArc')).attr(\"d\", arc1).style(\"fill\", gr1Color).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fill(d, \"gr1indicator\", .3, 0, 100);\n            fill(d, \"gr2indicator\", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fill(d, \"gr1indicator\", 0, 100, 500);\n            fill(d, \"gr2indicator\", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart2();\n        });\n\n        g.append(\"path\").attr(\"id\", append('gr1indicator')).attr(\"d\", arcInd1).style(\"fill\", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \"grArc\", 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart2();\n        });\n\n        g.append(\"path\").attr(\"id\", append('gr2indicator')).attr(\"d\", arcInd2).style(\"fill\", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, 'grText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \"grArc\", 0, 100, 500);\n            fill(d, 'grText', 0, 100, 500);\n        }).on('click', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            _restart2();\n        });\n\n        g.append(\"text\").attr(\"id\", append('grText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#grArc')).text(\"Groups\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', function (d) {\n            return setPebbleRadius(d);\n        }).style('pointer-events', 'inherit').style('fill', function (d) {\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            _restart2();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            _restart2();\n        });\n\n        // show node names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft('tab3');\n            varSummary(d);\n            d.forefront = true;\n\n            byId('transformations').setAttribute('style', 'display:block');\n            byId(\"transSel\").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, \"dvArc\", .1, 0, 100);\n            fill(d, \"dvText\", .5, 0, 100);\n            fill(d, \"grArc\", .1, 0, 100);\n            fill(d, \"grText\", .5, 0, 100);\n            //fill(d, \"gr1indicator\", .1, 0, 100);\n            //fill(d, \"gr1indicatorText\", .1, 0, 100);\n            //fill(d, \"gr2indicator\", .1, 0, 100);\n            //fill(d, \"gr2indicatorText\", .1, 0, 100);\n\n            if (d.defaultNumchar == \"numeric\") {\n                fill(d, \"nomArc\", .1, 0, 100);\n                fill(d, \"nomText\", .5, 0, 100);\n            }\n            fill(d, \"csArc\", .1, 0, 100);\n            fill(d, \"csText\", .5, 0, 100);\n            fill(d, \"timeArc\", .1, 0, 100);\n            fill(d, \"timeText\", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on('mouseout', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? 'tab2' : 'tab1');\n            'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText'.split(' ').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        if (!IS_D3M_DOMAIN) {\n            $('#transSel li').click(function (evt) {\n                // if 'interaction' is the selected function, don't show the function list again\n                if (selInteract) {\n                    var n = $('#tInput').val().concat($(this).text());\n                    $('#tInput').val(n);\n                    evt.stopPropagation();\n                    var t = transParse(n = n);\n                    if (!t) return;\n                    $(this).parent().fadeOut(100);\n                    transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                    return;\n                }\n\n                $('#tInput').val($(this).text());\n                $(this).parent().fadeOut(100);\n                $('#transList').fadeIn(100);\n                evt.stopPropagation();\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n\n        // save workspaces\n        console.log('ok ws');\n        record_user_metadata();\n    };\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        _restart2();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    _restart2(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent(\"MouseEvents\");\n        // initialize the event\n        click_ev.initEvent(\"click\", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = \"dvArc\" + findNodeIndex(mytarget);\n        byId(clickID).dispatchEvent(click_ev);\n    }\n}\n\n/** needs doc */\nfunction find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n}\n\n/**\n   returns id\n*/\nfunction findNodeIndex(name, whole) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) return whole ? node : node.id;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name === nodeName) return i;\n    }\n}\n\n/** needs doc */\nfunction findNode(name) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = allNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var n = _step2.value;\n\n            if (n.name === name) return n;\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction updateNode(id) {\n    var node = findNode(id);\n    if (node.grayout) return false;\n\n    var name = node.name;\n    var names = function names() {\n        return nodes.map(function (n) {\n            return n.name;\n        });\n    };\n    if (names().includes(name)) {\n        del(nodes, node.index);\n        links.filter(function (l) {\n            return l.source === node || l.target === node;\n        }).forEach(function (l) {\n            return del(links, -1, l);\n        });\n        zparamsReset(name);\n\n        // remove node name from group lists\n        node.group1 && del(zparams.zgroup1, -1, name);\n        node.group2 && del(zparams.zgroup2, -1, name);\n        node.group1 = node.group2 = false;\n\n        // node reset - perhaps this will become a hard reset back to all original allNode values?\n        node.nodeCol = node.baseCol;\n        node.strokeColor = _plots.selVarColor;\n        node.strokeWidth = '1';\n\n        borderState();\n    } else {\n        nodes.push(node);\n    }\n    zparams.zvars = names();\n    return true;\n}\n\n/**\n   every time a variable in leftpanel is clicked, nodes updates and background color changes\n*/\nfunction clickVar(elem) {\n    if (updateNode(elem.target.id)) {\n        // panelPlots(); is this necessary?\n        _restart2();\n    }\n}\n\n/**\n  Retrieve the variable list from the preprocess data.\n  This helps handle the new format and (temporarily)\n  the older format in PRODUCTION (rp 8.14.2017)\n  \"new\" response:\n  {\n  \"dataset\" : {...}\n  \"variables\" : {\n  \"var1\" : {...},\n  (etc)\n  }\n  }\n  \"old\" response:\n  {\n  \"var1\" : {...},\n  (etc)\n  }\n*/\nfunction getVariableData(json) {\n    return json.hasOwnProperty('variables') ? json.variables : json;\n}\n\n/**\n   called by force button\n*/\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == 'true' ? 'false' : 'true'];\n    if (forcetoggle[0] === \"false\") {\n        byId('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        byId('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction helpmaterials(type) {\n    if (type == \"video\") {\n        var win = window.open(\"http://2ra.vn/demos/d3mintegrationdemo.mp4\", '_blank');\n        win.focus();\n    } else {\n        var win = window.open(\"http://2ra.vn/papers/tworavens-d3mguide.pdf\", '_blank');\n        win.focus();\n    }\n    console.log(type);\n}\n\n/** needs doc */\nfunction lockDescription() {\n    exports.locktoggle = locktoggle = locktoggle ? false : true;\n    var temp = void 0;\n    var i = void 0;\n    if (!locktoggle) {\n        byId('btnLock').setAttribute(\"class\", \"btn btn-default\");\n        temp = byId('rightContentArea').querySelectorAll(\"p.item-lineout\");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.remove(\"item-lineout\");\n        }\n    } else {\n        byId('btnLock').setAttribute(\"class\", \"btn active\");\n        temp = byId('metrics').querySelectorAll(\"p.item-default\");\n        console.log(temp);\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add(\"item-lineout\");\n        }\n        temp = byId('types').querySelectorAll(\"p.item-default\");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add(\"item-lineout\");\n        }\n        temp = byId('subtypes').querySelectorAll(\"p.item-default\");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add(\"item-lineout\");\n        }\n        /*    temp = byId('outputs').querySelectorAll(\"p.item-default\");\n            for (i = 0; i < temp.length; i++) {\n                temp[i].classList.add(\"item-lineout\");\n            }  */\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    zparams.znature = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        zparams.znature.push(nodes[j].nature);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j3 = 0; _j3 < links.length; _j3++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j3].left == false ? [links[_j3].source.name, links[_j3].target.name] : [links[_j3].target.name, links[_j3].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction tabulate(data, columns, divid) {\n    var table = d3.select(divid).append('table');\n    var thead = table.append('thead');\n    var tbody = table.append('tbody');\n\n    // append the header row\n    thead.append('tr').selectAll('th').data(columns).enter().append('th').text(function (column) {\n        return column;\n    });\n\n    // create a row for each object in the data\n    var rows = tbody.selectAll('tr').data(data).enter().append('tr').attr('class', function (d, i) {\n        if (i == 0) return 'item-select';else return 'item-default';\n    });\n\n    // create a cell in each row for each column\n    var cells = rows.selectAll('td').data(function (row) {\n        return columns.map(function (column) {\n            return { column: column, value: row[column] };\n        });\n    }).enter().append('td').text(function (d) {\n        return d.value;\n    }).on(\"click\", function (d) {\n        var myrow = this.parentElement;\n        if (myrow.className == \"item-select\") {\n            return;\n        } else {\n            d3.select(divid).select(\"tr.item-select\").attr('class', 'item-default');\n            d3.select(myrow).attr('class', \"item-select\");\n            if (divid == '#setxRight') {\n                resultsplotinit(allPipelineInfo[myrow.firstChild.innerText], dvvalues);\n            }\n        }\n    });\n\n    // this is code to add a checkbox to each row of pipeline results table\n    /*\n      d3.select(divid).selectAll(\"tr\")\n      .append(\"input\")\n      .attr(\"type\", \"checkbox\")\n      .style(\"float\",\"right\");\n    */\n\n    return table;\n}\n\nfunction onPipelineCreate(PipelineCreateResult) {\n    // rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n    estimateLadda.stop(); // stop spinner\n\n    // change status of buttons for estimating problem and marking problem as finished\n    $(\"#btnEstimate\").removeClass(\"btn-success\");\n    $(\"#btnEstimate\").addClass(\"btn-default\");\n    $(\"#btnEndSession\").removeClass(\"btn-default\");\n    $(\"#btnEndSession\").addClass(\"btn-success\");\n\n    var allPipelineInfo = {};\n    for (var i = 0; i < PipelineCreateResult.length; i++) {\n        if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n        } else {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n        }\n    }\n    console.log(allPipelineInfo);\n    // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n    var resultstable = [];\n    for (var key in allPipelineInfo) {\n        // don't report the pipeline to user if it has failed\n        if (allPipelineInfo[key].responseInfo.status.details == \"Pipeline Failed\") {\n            continue;\n        }\n        var myid = \"\";\n        var mymetric = \"\";\n        var myval = \"\";\n        console.log(allPipelineInfo);\n        var myscores = allPipelineInfo[key].pipelineInfo.scores;\n        for (var i = 0; i < myscores.length; i++) {\n            //if(i==0) {myid=key;}\n            //   else myid=\"\";\n            myid = key;\n            mymetric = myscores[i].metric;\n            myval = +myscores[i].value.toFixed(3);\n            resultstable.push({ \"PipelineID\": myid, \"Metric\": mymetric, \"Score\": myval });\n        }\n    }\n\n    // render the table\n    tabulate(resultstable, ['PipelineID', 'Metric', 'Score'], '#results');\n    tabulate(resultstable, ['PipelineID', 'Metric', 'Score'], '#setxRight');\n    /////////////////////////\n\n    toggleRightButtons(\"all\");\n    byId(\"btnResults\").click();\n\n    // this initializes the main\n    // this piece here is the first pipeline through: allPipelineInfo[resultstable[1].PipelineID]\n    //resultsplotinit(allPipelineInfo[resultstable[1].PipelineID], dvvalues);\n    exportpipeline(resultstable[1].PipelineID);\n\n    // I don't think we need these until we are handling streaming pipelines\n    // They are set up and called, but don't actually render anything for the user\n\n    // this is our function for the ListPipelines of API\n    listpipelines();\n\n    //let pipelineid = PipelineCreateResult.pipelineid;\n    // getexecutepipelineresults is the third to be called\n    makeRequest(D3M_SVC_URL + '/getexecutepipelineresults', { context: context, pipeline_ids: Object.keys(allPipelineInfo) });\n}\nfunction CreatePipelineData(predictors, depvar) {\n    var context = apiSession(zparams.zsessionid);\n    var uriCsv = zparams.zd3mdata;\n    var uriJson = uriCsv.substring(0, uriCsv.lastIndexOf(\"/tables\")) + \"/datasetDoc.json\";\n    var targetFeatures = [{ 'resource_id': \"0\", 'feature_name': depvar[0] }];\n    var predictFeatures = [];\n    for (var i = 0; i < predictors.length; i++) {\n        predictFeatures[i] = { 'resource_id': \"0\", 'feature_name': predictors[i] };\n    }\n    return {\n        context: context,\n        dataset_uri: uriJson, // uriCsv is also valid, but not currently accepted by ISI TA2\n        task: d3mTaskType[d3mProblemDescription.taskType][1],\n        taskSubtype: d3mTaskSubtype[d3mProblemDescription.taskSubtype][1],\n        taskDescription: d3mProblemDescription.taskDescription,\n        output: \"OUTPUT_TYPE_UNDEFINED\", // valid values will come in future API\n        metrics: [d3mMetrics[d3mProblemDescription.metric][1]],\n        targetFeatures: targetFeatures,\n        /* Example:\n          \"targetFeatures\": [\n          {\n              \"resource_id\": \"0\",\n              \"feature_name\": \"At_bats\"\n          }\n          ],\n        */\n        predictFeatures: predictFeatures,\n        /* Example:\n          \"predictReatures\": [\n          {\n            \"resource_id\": \"0\",\n            \"feature_name\": \"RBIs\"\n          }\n          ],\n        */\n        maxPipelines: 5 //user to specify this eventually?\n    };\n}\n\nfunction downloadIncomplete() {\n    if (PRODUCTION && zparams.zsessionid === '') {\n        alert('Warning: Data download is not complete. Try again soon.');\n        return true;\n    }\n    return false;\n}\n\n/**\n    called by clicking 'Solve This Problem' in model mode\n*/\nasync function estimate(btn) {\n    if (!IS_D3M_DOMAIN) {\n        if (downloadIncomplete()) {\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n\n        /* UNUSED\n        var selectorurlcall = ROOK_SVC_URL + \"selectorapp\";\n        function selectorSuccess(btn, json) {\n            d3.select(\"#ticker\")\n                .text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n            cdb(\"selectorSuccess: \", json);\n        }\n        function selectorFail(btn) {\n            alert(\"Selector Fail\");\n        }\n        */\n\n        estimateLadda.start(); // start spinner\n        var json = await makeRequest(ROOK_SVC_URL + 'zeligapp', zparams);\n        if (!json) {\n            estimated = true;\n        } else {\n            var modCol = function modCol() {\n                d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n            };\n\n            allResults.push(json);\n            if (!estimated) byId(\"results\").removeChild(byId(\"resultsHolder\"));\n\n            estimated = true;\n            d3.select(\"#results\").style(\"display\", \"block\");\n\n            d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n            d3.select(\"#modelView\").style(\"display\", \"block\");\n\n            // programmatic click on Results button\n            $(\"#btnResults\").trigger(\"click\");\n\n            var model = \"Model\".concat(exports.modelCount = modelCount = modelCount + 1);\n\n            modCol();\n\n            d3.select(\"#modelView\").insert(\"p\", \":first-child\") // top stack for results\n            .attr(\"id\", model).text(model).style('background-color', hexToRgba(_plots.selVarColor)).on(\"click\", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, \"\");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style('background-color', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [json.call];\n            showLog('estimate', rCall);\n\n            viz(model);\n        }\n    } else if (swandive) {\n        // IS_D3M_DOMAIN and swandive is true\n        zPop();\n        zparams.callHistory = callHistory;\n\n        var myvki = valueKey.indexOf(mytarget);\n        if (myvki != -1) {\n            del(valueKey, myvki);\n        }\n\n        estimateLadda.start(); // start spinner\n        var res = await makeRequest(D3M_SVC_URL + '/CreatePipelines', CreatePipelineData(valueKey, mytarget));\n        res && onPipelineCreate(res);\n    } else {\n        // we are in IS_D3M_DOMAIN no swandive\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n\n        // pipelineapp is a rook application that returns the dependent variable, the DV values, and the predictors. can think of it was a way to translate the potentially complex grammar from the UI\n\n        estimateLadda.start(); // start spinner\n        var _res = await makeRequest(ROOK_SVC_URL + 'pipelineapp', zparams);\n        if (!_res) {\n            estimated = true;\n        } else {\n            console.log(_res);\n            setxTable(_res.predictors);\n            var _dvvalues = _res.dvvalues;\n            _res = await makeRequest(D3M_SVC_URL + '/CreatePipelines', CreatePipelineData(_res.predictors, _res.depvar));\n            //   res = await makeRequest(ROOK_SVC_URL + 'createpipeline', zparams);\n            _res && onPipelineCreate(_res);\n        }\n    }\n}\n\n/** needs doc */\nfunction ta2stuff() {\n    console.log(d3mProblemDescription);\n}\n\n/** needs doc */\nasync function dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    var res = await makeRequest(ROOK_SVC_URL + 'dataapp', zparams);\n    if (!res) {\n        return;\n    }\n\n    zparams.zsessionid = res.sessionid[0];\n    // set link URL\n    byId(\"logID\").href = '' + (PRODUCTION ? ROOK_SVC_URL + 'log_dir/log_' : 'rook/log_') + zparams.zsessionid + '.txt';\n}\n\n/** needs doc */\nfunction viz(mym) {\n    mym = +mym.substr(5, 5) - 1;\n\n    var removeKids = function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    };\n    removeKids(byId(\"resultsView\"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        byId(\"resultsView\").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == 'colnames') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\").append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n/**\n   parses the transformation input.\n   variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\n*/\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    cdb(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, \" is nested in \", j);\n                del(out2, i);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\n/**\n   n = name of column/node\n   t = selected transformation\n*/\nasync function transform(n, t, typeTransform) {\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    if (!typeTransform) t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n\n    cdb('name of col: ' + n);\n    cdb('transformation: ' + t);\n\n    var btn = byId('btnEstimate');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === \"undefined\") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    estimateLadda.start(); // start spinner\n    var json = await makeRequest(ROOK_SVC_URL + 'transformapp', { zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes });\n    if (!json) {\n        return;\n    }\n\n    // Is this a typeTransform?\n    if (json.typeTransform[0]) {\n        // Yes. We're updating an existing node\n        d3.json(json.url, function (err, data) {\n            if (err) return console.warn(err);\n            var node = void 0;\n            for (var key in data) {\n                node = findNodeIndex(key, true);\n                if (!node) continue;\n                jQuery.extend(true, node, data[key]);\n                node.plottype === \"continuous\" ? (0, _plots.densityNode)(node) : node.plottype === \"bar\" ? (0, _plots.barsNode)(node) : null;\n            }\n            fakeClick();\n            panelPlots();\n            node && cdb(node);\n        });\n    } else {\n        /* No, we have a new node here--e.g. the transformed column\n           example response: {\n           \"call\":[\"t_year_2\"],\n           \"url\":[\"data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt\"],\n           \"trans\":[\"year\",\"_transvar0^2\"],\n           \"typeTransform\":[false]\n           }\n        */\n        callHistory.push({\n            func: \"transform\",\n            zvars: n,\n            transform: t\n        });\n\n        var subseted = false;\n        var rCall = [];\n\n        rCall[0] = json.call;\n        var newVar = rCall[0][0];\n\n        trans.push(newVar);\n\n        // Read the preprocess file containing values\n        // for the transformed variable\n        //\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n                if (typeof myIndex !== \"undefined\") {\n                    alert(\"Invalid transformation: this variable name already exists.\");\n                    return;\n                }\n                // add transformed variable to the current space\n                var i = allNodes.length; // get new index\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    name: key,\n                    labl: \"transformlabel\",\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: [.6, .2, .9, .8, .1, .3, .4],\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: \"1\",\n                    subsetplot: false,\n                    subsetrange: [\"\", \"\"],\n                    setxplot: false,\n                    setxvals: [\"\", \"\"],\n                    grayout: false,\n                    defaultInterval: jsondata[key].interval,\n                    defaultNumchar: jsondata[key].numchar,\n                    defaultNature: jsondata[key].nature,\n                    defaultBinary: jsondata[key].binary\n                };\n\n                jQuery.extend(true, obj1, jsondata[key]);\n                allNodes.push(obj1);\n                valueKey.push(newVar);\n                nodes.push(allNodes[i]);\n                fakeClick();\n                panelPlots();\n\n                if (allNodes[i].plottype === \"continuous\") {\n                    (0, _plots.densityNode)(allNodes[i]);\n                } else if (allNodes[i].plottype === \"bar\") {\n                    (0, _plots.barsNode)(allNodes[i]);\n                }\n\n                _mithril2.default.redraw();\n            }\n        });\n\n        showLog('transform', rCall);\n    }\n}\n\nasync function makeRequest(url, data) {\n    console.log('url:', url);\n    console.log('POST:', data);\n    var res = void 0;\n    try {\n        res = await _mithril2.default.request(url, { method: 'POST', data: data });\n        console.log('response:', res);\n        if (Object.keys(res)[0] === 'warning') {\n            alert('Warning: ' + res.warning);\n            end_ta3_search(false, res.warning);\n        }\n    } catch (err) {\n        end_ta3_search(false, err);\n        cdb(err);\n        alert('Error: call to ' + url + ' failed');\n    }\n\n    /*\n     // call end_ta3_search if status != OK\n     // status may be in different places for different calls though, and this is not worth doing at the moment\n     let myreg = /d3m-service/g;\n     let isd3mcall = myreg.test(url);\n     if(isd3mcall) {\n         let mystatus = res.responseInfo.status.code.toUpperCase();\n         if(mystatus != \"OK\") {\n             end_ta3_search(false, \"grpc response status not ok\");\n         }\n     }\n     */\n\n    estimateLadda.stop();\n    selectLadda.stop();\n    return res;\n}\n\n/** needs doc */\nfunction legend() {\n    borderState();\n    _mithril2.default.redraw();\n}\n\n/**\n   programmatically deselect every selected variable\n*/\nfunction erase() {\n    ['#leftpanel', '#rightpanel'].forEach(function (id) {\n        return d3.select(id).attr('class', 'sidepanel container clearfix');\n    });\n    tabLeft('tab1');\n    $(\"#varList\").children().each(function () {\n        if (zparams.zdv.concat(zparams.znom, zparams.zvars).includes(this.id)) clickVar({ target: this });\n    });\n}\n\n/** needs doc */\nfunction tabLeft(tab) {\n    byId('tab1').style.display = 'none';\n    byId('tab2').style.display = 'none';\n    byId('tab3').style.display = 'none';\n    byId(tab).style.display = 'block';\n    if (tab != 'tab3') {\n        exports.subset = subset = tab == 'tab2';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\n/** needs doc */\nfunction tabRight(tab) {\n    var select = function select(cls) {\n        var panel = d3.select(\"#rightpanel\");\n        return cls ? panel.attr('class', cls) : panel.attr('class');\n    };\n    var cls = \"sidepanel container clearfix\";\n    var toggleR = function toggleR(full) {\n        select(function () {\n            return cls + this.getAttribute(\"class\") === cls ? '' : cls + ' expandpanel' + full;\n        });\n    };\n    if (tab === \"btnModels\") select(cls);else if (tab === \"btnSetx\") righttab === \"btnSetx\" || select() === cls && toggleR('full');else if (tab === \"btnResults\") !estimated ? select(cls) : righttab === \"btnResults\" || select() === cls && toggleR();else if (tab === \"btnUnivariate\") select(cls);\n    exports.righttab = righttab = tab;\n}\n\nvar summary = exports.summary = { data: [] };\n\n/** needs doc */\nfunction varSummary(d) {\n    var t1 = 'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl'.split(', ');\n\n    var rint = d3.format('r');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + ' (' + str(d.meanCI.lowerBound, 2) + ' - ' + str(d.meanCI.upperBound, 2) + ')', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes('NaN') && t2[i] != 'NA' && t2[i] != '' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select('#tab3').selectAll('svg').remove();\n\n    if (!d.plottype) return;\n    d.plottype == 'continuous' ? (0, _plots.density)(d, 'varSummary', priv) : d.plottype == \"bar\" ? (0, _plots.bars)(d, 'varSummary', priv) : d3.select(\"#tab3\") // no graph to draw, but still need to remove previous graph\n    .selectAll(\"svg\").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    if (swandive) return;\n    var text = '';\n    var _ref3 = [d3.format('r'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref3[0],\n        prec = _ref3[1];\n\n    var div = function div(field, name, val) {\n        if (field != 'NA') text += '<div class=\\'form-group\\'><label class=\\'col-sm-4 control-label\\'>' + name + '</label><div class=\\'col-sm-6\\'><p class=\\'form-control-static\\'>' + (val || field) + '</p></div></div>';\n    };\n    d.labl != '' && div(d.labl, 'Label');\n    div(d.mean, 'Mean', priv && d.meanCI ? prec(d.mean, 2) + ' (' + prec(d.meanCI.lowerBound, 2) + ' - ' + prec(d.meanCI.upperBound, 2) + ')' : prec(d.mean, 4));\n    div(d.median, 'Median', prec(d.median, 4));\n    div(d.mode, 'Most Freq');\n    div(d.freqmode, 'Occurrences', rint(d.freqmode));\n    div(d.mid, 'Median Freq');\n    div(d.freqmid, 'Occurrences', rint(d.freqmid));\n    div(d.fewest, 'Least Freq');\n    div(d.freqfewest, 'Occurrences', rint(d.freqfewest));\n    div(d.sd, 'Stand Dev', prec(d.sd, 4));\n    div(d.max, 'Maximum', prec(d.max, 4));\n    div(d.min, 'Minimum', prec(d.min, 4));\n    div(d.invalid, 'Invalid', rint(d.invalid));\n    div(d.valid, 'Valid', rint(d.valid));\n    div(d.uniques, 'Uniques', rint(d.uniques));\n    div(d.herfindahl, 'Herfindahl', prec(d.herfindahl, 4));\n    return text;\n};\n\n/** needs doc */\nfunction panelPlots() {\n    if (IS_D3M_DOMAIN) {\n        byId('btnSubset').classList.add('noshow');\n    }\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, ''));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select('#setxLeft').selectAll('svg').remove();\n    d3.select('#tab2').selectAll('svg').remove();\n    for (var i = 0; i < vars.length; i++) {\n        if (allNodes[ids[i]].valid == 0) // this was a silent error... very frustrating...\n            continue;\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === \"continuous\" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = \"setxLeft\", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = \"subset\", priv);\n        } else if (node.plottype === \"bar\" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = \"setxLeft\", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select(\"#setxLeft\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setxLeft_\", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n/**\n   converts color codes\n*/\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace('#', ''), 16);\n    return 'rgba(' + [int >> 16 & 255, int >> 8 & 255, int & 255, '0.5'].join(',') + ')';\n};\n\n/**\n   takes node and color and updates zparams\n*/\nfunction setColors(n, c) {\n    if (n.strokeWidth == '1') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                del(zparams.zgroup1, tempindex);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                del(zparams.zgroup2, tempindex);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = '4';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref4) {\n                var _ref5 = _slicedToArray(_ref4, 2),\n                    color = _ref5[0],\n                    key = _ref5[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == 'znom') {\n                    findNodeIndex(n.name, true).nature = \"nominal\";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == 'zdv') {\n                    // remove group memberships from dv's\n                    if (n.group1) {\n                        n.group1 = false;\n                        del(zparams.zgroup1, -1, n.name);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        del(zparams.zgroup2, -1, n.name);\n                    };\n                }\n            };\n            [[dvColor, 'zdv'], [csColor, 'zcross'], [timeColor, 'ztime'], [nomColor, 'znom']].forEach(push);\n        }\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            zparamsReset(n.name);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            zparamsReset(n.name);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv's\n                    ngroup1 = false;\n                    del(zparams.zgroup1, -1, dvname);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    del(zparams.zgroup2, -1, dvname);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction borderState() {\n    zparams.zdv.length > 0 ? $('#dvButton .rectColor svg circle').attr('stroke', dvColor) : $('#dvButton').css('border-color', '#ccc');\n    zparams.zcross.length > 0 ? $('#csButton .rectColor svg circle').attr('stroke', csColor) : $('#csButton').css('border-color', '#ccc');\n    zparams.ztime.length > 0 ? $('#timeButton .rectColor svg circle').attr('stroke', timeColor) : $('#timeButton').css('border-color', '#ccc');\n    zparams.znom.length > 0 ? $('#nomButton .rectColor svg circle').attr('stroke', nomColor) : $('#nomButton').css('border-color', '#ccc');\n    zparams.zgroup1.length > 0 ? $('#gr1Button .rectColor svg circle').attr('stroke', gr1Color).attr('fill', gr1Color).attr('fill-opacity', 0.6).attr('stroke-opacity', 0) : $('#gr1Button').css('border-color', '#ccc');\n    zparams.zgroup2.length > 0 ? $('#gr2Button .rectColor svg circle').attr('stroke', gr2Color).attr('fill', gr2Color).attr('fill-opacity', 0.6).attr('stroke-opacity', 0) : $('#gr2Button').css('border-color', '#ccc');\n}\n\n/** needs doc */\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != \"\") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    selectLadda.start(); // start button motion\n    var json = makeRequest(ROOK_SVC_URL + 'subsetSelect', { zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes });\n    selectLadda.stop();\n    if (!json) {\n        return;\n    }\n\n    $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n    $(\"#btnModels\").trigger(\"click\");\n\n    var grayOuts = [];\n    var rCall = [];\n    rCall[0] = json.call;\n\n    // store contents of the pre-subset space\n    zPop();\n    var myNodes = jQuery.extend(true, [], allNodes);\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n\n    spaces[myspace] = {\n        \"allNodes\": myNodes,\n        \"zparams\": myParams,\n        \"trans\": myTrans,\n        \"force\": myForce,\n        \"preprocess\": myPreprocess,\n        \"logArray\": myLog,\n        \"callHistory\": myHistory\n    };\n\n    // remove pre-subset svg\n    var selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe).attr('class', 'item');\n    selectMe = \"#whitespace\".concat(myspace);\n    d3.select(selectMe).remove();\n\n    myspace = spaces.length;\n    callHistory.push({\n        func: \"subset\",\n        zvars: jQuery.extend(true, [], zparams.zvars),\n        zsubset: jQuery.extend(true, [], zparams.zsubset),\n        zplot: jQuery.extend(true, [], zparams.zplot)\n    });\n\n    // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n    function varOut(v) {\n        // if in nodes, remove gray out in left panel\n        // make unclickable in left panel\n        for (var i = 0; i < v.length; i++) {\n            var selectMe = v[i].replace(/\\W/g, \"_\");\n            byId(selectMe).style.color = hexToRgba(grayColor);\n            selectMe = \"p#\".concat(selectMe);\n            d3.select(selectMe).on(\"click\", null);\n        }\n    }\n\n    showLog('subset', rCall);\n\n    d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n        return \"m\".concat(myspace.toString());\n    }).append('svg').attr('id', 'whitespace');\n    svg = d3.select(\"#whitespace\");\n\n    d3.json(json.url, function (error, json) {\n        if (error) {\n            return console.warn(error);\n        }\n        var jsondata = getVariableData(json);\n\n        for (var key in jsondata) {\n            var myIndex = findNodeIndex(key);\n\n            allNodes[myIndex].plotx = undefined;\n            allNodes[myIndex].ploty = undefined;\n            allNodes[myIndex].plotvalues = undefined;\n            allNodes[myIndex].plottype = \"\";\n\n            jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n            allNodes[myIndex].subsetplot = false;\n            allNodes[myIndex].subsetrange = [\"\", \"\"];\n            allNodes[myIndex].setxplot = false;\n            allNodes[myIndex].setxvals = [\"\", \"\"];\n\n            if (allNodes[myIndex].valid == 0) {\n                grayOuts.push(allNodes[myIndex].name);\n                allNodes[myIndex].grayout = true;\n            }\n        }\n        rePlot();\n        layout(layoutAdd);\n    });\n\n    varOut(grayOuts);\n}\n\n/**\n   removes all the children svgs inside subset and setx divs\n*/\nfunction rePlot() {\n    d3.select('#tab2').selectAll('svg').remove();\n    d3.select('#setx').selectAll('svg').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed('active', false);\n};\n\n/**\n   EndSession(SessionContext) returns (Response) {}\n*/\nasync function endsession() {\n    // makeRequest(D3M_SVC_URL + '/endsession', apiSession(zparams.zsessionid));\n    var res = await makeRequest(D3M_SVC_URL + '/endsession', apiSession(zparams.zsessionid));\n    var mystatus = res.status.code.toUpperCase();\n    if (mystatus == \"OK\") {\n        end_ta3_search(true, \"Problem marked as complete.\");\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction deletepipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + '/DeletePipelines', { context: apiSession(zparams.zsessionid), deletePipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction cancelpipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + '/CancelPipelines', { context: apiSession(zparams.zsessionid), cancelPipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n   rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\n   pipes is an array of pipeline IDs\n*/\nfunction listpipelines() {\n    var res = makeRequest(D3M_SVC_URL + '/listpipelines', { context: apiSession(zparams.zsessionid) });\n    if (!res) {\n        return;\n    }\n\n    //hardcoded pipes for now\n    var pipes = res.pipelineIds;\n\n    /*\n      pipes.unshift(\"place\");\n      console.log(pipes);\n      d3.select(\"#results\").selectAll(\"p\")\n      .data(pipes)\n      .enter()\n      .append(\"p\")\n      .attr(\"id\", \"_pipe_\".concat)\n      .text(d => d)\n      .attr('class', 'item-default')\n      .on(\"click\", function() {\n      if(this.className==\"item-select\") {\n      return;\n      } else {\n      d3.select(\"#results\").select(\"p.item-select\")\n      .attr('class', 'item-default');\n      d3.select(this).attr('class',\"item-select\");\n      }});\n       pipes.shift();\n        d3.select(\"#setxRight\").selectAll(\"p\")\n      .data(pipes)\n      .enter()\n      .append(\"p\")\n      .attr(\"id\", \"_setxpipe_\".concat)\n      .text(d => d)\n      .attr('class', 'item-default')\n      .on(\"click\", function() {\n      if(this.className==\"item-select\") {\n      return;\n      } else {\n      d3.select(\"#setxRight\").select(\"p.item-select\")\n      .attr('class', 'item-default');\n      d3.select(this).attr('class',\"item-select\");\n      }});\n    */\n}\n\n/**\n   rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\n*/\nfunction executepipeline() {\n    var context = apiSession(zparams.zsessionid);\n    var tablerow = byId('setxRight').querySelector('tr.item-select');\n    if (tablerow == null) {\n        alert(\"Please select a pipeline to execute on.\");return;\n    }\n    var pipelineId = tablerow.firstChild.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    //let predictFeatures = apiFeature(zparams.zvars,\"<<DATA_URI>>\");\n    dataset_uri = \"<<DATA_URI>>\"; // should perhaps adjust call to datasetUri to follow syntax norms on other calls to Django\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == \"\" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == \"\") {\n            mydata[0] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[0] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == \"\") {\n            mydata[1] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[1] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    makeRequest(D3M_SVC_URL + '/executepipeline', { context: context, pipelineId: pipelineId, dataset_uri: dataset_uri, data: data });\n}\n\n/**\n    call to django to update the problem definition in the problem document \n    rpc SetProblemDoc(SetProblemDocRequest) returns (Response) {}\n*/\nfunction setProblemDefinition(type, updates, lookup) {\n    makeRequest(D3M_SVC_URL + \"/SetProblemDoc\", { replaceProblemSchemaField: _defineProperty({}, type, lookup[updates[type]][1]), context: apiSession(zparams.zsessionid) });\n}\n\n/**\n   find something centerish to the vertices of a convex hull\n   (specifically, the center of the bounding box)\n*/\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n/**\n   Define each pebble radius.\n   Presently, most pebbles are scaled to radius set by global RADIUS.\n   Members of groups are scaled down if group gets large.\n*/\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? RADIUS * Math.sqrt(uppersize / maxng) : RADIUS; // keep total area of pebbles bounded to pi * RADIUS^2 * uppersize, thus shrinking radius for pebbles in larger groups\n    } else {\n        return RADIUS; // nongroup members get the common global radius\n    }\n};\n\n/**\n   Define each pebble charge.\n*/\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n};\n\n/** needs doc */\nfunction expandrightpanel() {\n    byId('rightpanel').classList.add(\"expandpanelfull\");\n}\n\nfunction btnWidths(btns) {\n    var width = 100 / btns.length + '%';\n    var expandwidth = '35%';\n    var shrinkwidth = 65 / (btns.length - 1) + '%';\n    var lis = byId('rightpanel').querySelectorAll(\".accordion li\");\n    // hardly ever runs on the page\n    lis.forEach(function (li) {\n        li.style.width = width;\n        li.addEventListener('mouseover', function () {\n            lis.forEach(function (li) {\n                return li.style.width = shrinkwidth;\n            });\n            this.style.width = expandwidth;\n        });\n        li.addEventListener('mouseout', function () {\n            return lis.forEach(function (li) {\n                return li.style.width = width;\n            });\n        });\n    });\n}\n\n/** needs doc */\nfunction toggleRightButtons(set) {\n    if (set == \"all\") {\n        // first remove noshow class\n        var btns = byId('rightpanelbuttons').querySelectorAll(\".noshow\");\n        btns.forEach(function (b) {\n            return b.classList.remove(\"noshow\");\n        });\n\n        // dropping models for IS_D3M_DOMAIN\n        byId('btnModels').classList.add(\"noshow\");\n\n        // if swandive, dropping setx\n        if (swandive) byId('btnSetx').classList.add(\"noshow\");\n\n        // then select all the buttons\n        btns = byId('rightpanelbuttons').querySelectorAll(\".btn:not(.noshow)\");\n        btnWidths(btns);\n    } else if (set == \"models\") {\n        byId('btnModels').style.display = 'inline';\n        byId('btnSetx').style.display = 'inline';\n        byId('btnResults').style.display = 'inline';\n        byId('btnType').style.display = 'none';\n        byId('btnSubtype').style.display = 'none';\n        byId('btnMetrics').style.display = 'none';\n        // byId('btnOutputs').style.display = 'none';\n    }\n}\n\n/** needs doc */\nfunction resultsplotinit(pid, dvvalues) {\n    // presumably we'll be reading in results from a path\n    // for now it's just hardcoded\n    console.log(pid);\n    var predfile = pid.pipelineInfo.predictResultData.file_1;\n    var predvals = [];\n\n    for (var i = 0; i < predfile.length; i++) {\n        predvals.push(Number(predfile[i].preds));\n    }\n\n    // only do this for classification tasks\n    if (d3mTaskType[d3mProblemDescription.taskType][1] == \"CLASSIFICATION\") {\n        genconfdata(dvvalues, predvals);\n    } else {\n        var xdata = \"Actual\";\n        var ydata = \"Predicted\";\n        bivariatePlot(dvvalues, predvals, xdata, ydata);\n    }\n}\n\n/** needs doc */\nfunction genconfdata(dvvalues, predvals) {\n    // FOR TESTING\n    dvvalues = predvals.slice(0);\n    for (var i = 0; i < dvvalues.length; i++) {\n        var randomnumber = Math.floor(Math.random() * (2 - -2 + 1)) + -2;\n        dvvalues[i] = dvvalues[i] + randomnumber;\n    }\n\n    // done for testing. drop above when dvvalues are real values returned by R when pipeline is constructed\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    var mycounts = [];\n    var mypairs = [];\n\n    // this should eventually be just read from the URI in pipeline\n    // let dvvalues = [1,1,1,2,3,2,3,3,3,3,3,2,3,2,1,2,3,4,4];\n    // let predvals = [1,2,3,2,3,1,3,3,3,2,2,1,3,3,1,2,3,4,3];\n\n    // combine actuals and predicted, and get all unique elements\n    var myuniques = dvvalues.concat(predvals);\n    myuniques = myuniques.filter(onlyUnique);\n\n    // create two arrays: mycounts initialized to 0, mypairs have elements set to all possible pairs of uniques\n    // looked into solutions other than nested fors, but Internet suggest performance is just fine this way\n    for (var _i3 = 0; _i3 < myuniques.length; _i3++) {\n        var tempcount = [];\n        var temppair = [];\n        for (var j = 0; j < myuniques.length; j++) {\n            mycounts.push(0);\n            mypairs.push(+myuniques[_i3] + ',' + myuniques[j]);\n        }\n    }\n\n    // line up actuals and predicted, and increment mycounts at index where mypair has a match for the 'actual,predicted'\n    for (var _i4 = 0; _i4 < dvvalues.length; _i4++) {\n        var _temppair = +dvvalues[_i4] + ',' + predvals[_i4];\n        var myindex = mypairs.indexOf(_temppair);\n        mycounts[myindex] += 1;\n    }\n\n    var confdata = [],\n        size = myuniques.length;\n    // another loop... this builds the array of arrays from the flat array mycounts for input to confusionsmatrix function\n    while (mycounts.length > 0) {\n        confdata.push(mycounts.splice(0, size));\n    }confusionmatrix(confdata, myuniques);\n}\n\n/** needs doc */\nfunction confusionmatrix(matrixdata, classes) {\n    d3.select(\"#setxMiddle\").html(\"\");\n    d3.select(\"#setxMiddle\").select(\"svg\").remove();\n\n    // adapted from this block: https://bl.ocks.org/arpitnarechania/dbf03d8ef7fffa446379d59db6354bac\n    var mainwidth = byId('main').clientWidth;\n    var mainheight = byId('main').clientHeight;\n\n    var condiv = document.createElement('div');\n    condiv.id = \"confusioncontainer\";\n    condiv.style.display = \"inline-block\";\n    condiv.style.width = +(mainwidth * .25) + 'px';\n    condiv.style.marginLeft = '20px';\n    condiv.style.height = +(mainheight * .4) + 'px';\n    condiv.style.float = \"left\";\n    byId('setxMiddle').appendChild(condiv);\n\n    var legdiv = document.createElement('div');\n    legdiv.id = \"confusionlegend\";\n    legdiv.style.width = +(mainwidth * .07) + 'px';\n    legdiv.style.marginLeft = '20px';\n    legdiv.style.height = +(mainheight * .4) + 'px';\n    legdiv.style.display = \"inline-block\";\n    byId('setxMiddle').appendChild(legdiv);\n\n    var margin = { top: 20, right: 10, bottom: 0, left: 50 };\n    function Matrix(options) {\n        var width = options.width,\n            height = options.height,\n            data = options.data,\n            container = options.container,\n            labelsData = options.labels,\n            startColor = options.start_color,\n            endColor = options.end_color;\n\n        var widthLegend = options.widthLegend;\n\n        if (!data) {\n            throw new Error('Please pass data');\n        }\n\n        if (!Array.isArray(data) || !data.length || !Array.isArray(data[0])) {\n            throw new Error('It should be a 2-D array');\n        }\n\n        var maxValue = d3.max(data, function (layer) {\n            return d3.max(layer, function (d) {\n                return d;\n            });\n        });\n        var minValue = d3.min(data, function (layer) {\n            return d3.min(layer, function (d) {\n                return d;\n            });\n        });\n\n        var numrows = data.length;\n        var numcols = data[0].length;\n\n        var svg = d3.select(container).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        var background = svg.append(\"rect\").style(\"stroke\", \"black\").style(\"stroke-width\", \"2px\").attr(\"width\", width).attr(\"height\", height);\n\n        var x = d3.scale.ordinal().domain(d3.range(numcols)).rangeBands([0, width]);\n\n        var y = d3.scale.ordinal().domain(d3.range(numrows)).rangeBands([0, height]);\n\n        var colorMap = d3.scale.linear().domain([minValue, maxValue]).range([startColor, endColor]);\n\n        var row = svg.selectAll(\".row\").data(data).enter().append(\"g\").attr(\"class\", \"row\").attr(\"transform\", function (d, i) {\n            return \"translate(0,\" + y(i) + \")\";\n        });\n\n        var cell = row.selectAll(\".cell\").data(function (d) {\n            return d;\n        }).enter().append(\"g\").attr(\"class\", \"cell\").attr(\"transform\", function (d, i) {\n            return \"translate(\" + x(i) + \", 0)\";\n        });\n\n        cell.append('rect').attr(\"width\", x.rangeBand()).attr(\"height\", y.rangeBand()).style(\"stroke-width\", 0);\n\n        cell.append(\"text\").attr(\"dy\", \".32em\").attr(\"x\", x.rangeBand() / 2).attr(\"y\", y.rangeBand() / 2).attr(\"text-anchor\", \"middle\").style(\"fill\", function (d, i) {\n            return d >= maxValue / 2 ? 'white' : 'black';\n        }).text(function (d, i) {\n            return d;\n        });\n\n        row.selectAll(\".cell\").data(function (d, i) {\n            return data[i];\n        }).style(\"fill\", colorMap);\n\n        // this portion of the code isn't as robust to sizing. column labels not rendering in the right place\n        var labels = svg.append('g').attr('class', \"labels\");\n\n        var columnLabels = labels.selectAll(\".column-label\").data(labelsData).enter().append(\"g\").attr(\"class\", \"column-label\").attr(\"transform\", function (d, i) {\n            // let temp = \"translate(\" + x(i) + \",\" + (height+20) + \")\"; // this in particular looks to be the cause\n            //  console.log(temp);\n            return \"translate(\" + x(i) + \",\" + (height + 30) + \")\";\n        });\n\n        columnLabels.append(\"line\").style(\"stroke\", \"black\").style(\"stroke-width\", \"1px\").attr(\"x1\", x.rangeBand() / 2).attr(\"x2\", x.rangeBand() / 2).attr(\"y1\", 0).attr(\"y2\", 5);\n\n        columnLabels.append(\"text\").attr(\"x\", 30).attr(\"y\", y.rangeBand() / 2).attr(\"dy\", \".22em\").attr(\"text-anchor\", \"end\").attr(\"transform\", \"rotate(-60)\").text(function (d, i) {\n            return d;\n        });\n\n        var rowLabels = labels.selectAll(\".row-label\").data(labelsData).enter().append(\"g\").attr(\"class\", \"row-label\").attr(\"transform\", function (d, i) {\n            return \"translate(\" + 0 + \",\" + y(i) + \")\";\n        });\n\n        rowLabels.append(\"line\").style(\"stroke\", \"black\").style(\"stroke-width\", \"1px\").attr(\"x1\", 0).attr(\"x2\", -5).attr(\"y1\", y.rangeBand() / 2).attr(\"y2\", y.rangeBand() / 2);\n\n        rowLabels.append(\"text\").attr(\"x\", -8).attr(\"y\", y.rangeBand() / 2).attr(\"dy\", \".32em\").attr(\"text-anchor\", \"end\").text(function (d, i) {\n            return d;\n        });\n\n        var key = d3.select(\"#confusionlegend\").append(\"svg\").attr(\"width\", widthLegend).attr(\"height\", height + margin.top + margin.bottom);\n\n        var legend = key.append(\"defs\").append(\"svg:linearGradient\").attr(\"id\", \"gradient\").attr(\"x1\", \"100%\").attr(\"y1\", \"0%\").attr(\"x2\", \"100%\").attr(\"y2\", \"100%\").attr(\"spreadMethod\", \"pad\");\n\n        legend.append(\"stop\").attr(\"offset\", \"0%\").attr(\"stop-color\", endColor).attr(\"stop-opacity\", 1);\n\n        legend.append(\"stop\").attr(\"offset\", \"100%\").attr(\"stop-color\", startColor).attr(\"stop-opacity\", 1);\n\n        key.append(\"rect\").attr(\"width\", widthLegend / 2 - 10).attr(\"height\", height).style(\"fill\", \"url(#gradient)\").attr(\"transform\", \"translate(0,\" + margin.top + \")\");\n\n        // this y is for the legend\n        y = d3.scale.linear().range([height, 0]).domain([minValue, maxValue]);\n\n        var yAxis = d3.svg.axis().scale(y).orient(\"right\");\n\n        key.append(\"g\").attr(\"class\", \"y axis\").attr(\"transform\", \"translate(41,\" + margin.top + \")\").call(yAxis);\n    }\n\n    // The table generation function. Used for the table of performance measures, not the confusion matrix\n    function tabulate(data, columns) {\n        var table = d3.select(\"#setxMiddle\").append(\"table\").attr(\"style\", \"margin-left: \" + margin.left + \"px\"),\n            thead = table.append(\"thead\"),\n            tbody = table.append(\"tbody\");\n\n        // append the header row\n        thead.append(\"tr\").selectAll(\"th\").data(columns).enter().append(\"th\").text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\"tr\").data(data).enter().append(\"tr\");\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\"td\").data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\"td\").attr(\"style\", \"font-family: Courier\") // sets the font style\n        .html(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    // this code is all for producing a table with performance measures\n    //var confusionMatrix = [[169, 10],[7, 46]];\n    var tp = matrixdata[0][0];\n    var fn = matrixdata[0][1];\n    var fp = matrixdata[1][0];\n    var tn = matrixdata[1][1];\n\n    var p = tp + fn;\n    var n = fp + tn;\n\n    var accuracy = (tp + tn) / (p + n);\n    var f1 = 2 * tp / (2 * tp + fp + fn);\n    var precision = tp / (tp + fp);\n    var recall = tp / (tp + fn);\n\n    accuracy = Math.round(accuracy * 100) / 100;\n    f1 = Math.round(f1 * 100) / 100;\n    precision = Math.round(precision * 100) / 100;\n    recall = Math.round(recall * 100) / 100;\n\n    var computedData = [];\n    computedData.push({ \"F1\": f1, \"PRECISION\": precision, \"RECALL\": recall, \"ACCURACY\": accuracy });\n\n    Matrix({\n        container: '#confusioncontainer',\n        data: matrixdata,\n        labels: classes,\n        start_color: '#ffffff',\n        end_color: '#e67e22',\n        width: mainwidth * .15,\n        height: mainheight * .25,\n        widthLegend: mainwidth * .05\n    });\n\n    // not rendering this table for right now, left all the code in place though. maybe we use it eventually\n    // var table = tabulate(computedData, [\"F1\", \"PRECISION\",\"RECALL\",\"ACCURACY\"]);\n}\n\n/**\n   scatterplot function to go to plots.js to be reused\n*/\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    d3.select(\"#setxMiddle\").html(\"\");\n    d3.select(\"#setxMiddle\").select(\"svg\").remove();\n\n    var mainwidth = byId('main').clientWidth;\n    var mainheight = byId('main').clientHeight;\n\n    // scatter plot\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < x_Axis.length; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 35, right: 35, bottom: 35, left: 35 },\n        width = mainwidth * .25 - margin.left - margin.right,\n        height = mainwidth * .25 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on(\"zoom\", zoomed);\n\n    var chart_scatter = d3.select('#setxMiddle').append('svg:svg').attr('width', width + margin.right + margin.left).attr('height', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('width', width + margin.right + margin.left).attr('height', height + margin.top + margin.bottom).attr('class', 'main');\n\n    var gX = main1.append('g').attr('transform', 'translate(0,' + height + ')').attr('class', 'x axis').call(xAxis);\n\n    var gY = main1.append('g').attr('transform', 'translate(0,0)').attr('class', 'y axis').call(yAxis);\n\n    var clip = main1.append(\"defs\").append(\"svg:clipPath\").attr(\"id\", \"clip\").append(\"svg:rect\").attr(\"id\", \"clip-rect\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr('width', width).attr('height', height);\n\n    main1.append(\"g\").attr(\"clip-path\", \"url(#clip)\").selectAll(\"circle\").data(data_plot).enter().append(\"circle\").attr(\"cx\", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr(\"cy\", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr(\"r\", 2).style(\"fill\", \"#B71C1C\");\n\n    chart_scatter.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + padding / 5 + \",\" + height / 2 + \")rotate(-90)\") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    chart_scatter.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height + padding / 2) + \")\") // centre below axis\n    .text(x_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    main1.append(\"line\").attr(\"x1\", xScale(min_x)).attr(\"y1\", yScale(min_x)).attr(\"x2\", xScale(max_x)).attr(\"y2\", yScale(max_x)).attr(\"stroke-width\", 2).attr(\"stroke\", \"black\");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(\".x.axis\").call(xAxis);\n        main1.select(\".y.axis\").call(yAxis);\n        main1.selectAll(\"circle\").attr(\"cx\", function (d, i) {\n            console.log(\"circle x \", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr(\"cy\", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr(\"r\", 2.5).style(\"fill\", \"#B71C1C\");\n\n        // below doesn't work, so I'm just dropping the zoom\n        main1.select(\"line\").attr(\"x1\", function (d, i) {\n            return xScale(min_x);\n        }).attr(\"y1\", function (d, i) {\n            return xScale(min_x);\n        }).attr(\"x2\", function (d, i) {\n            return xScale(max_x);\n        }).attr(\"y2\", function (d, i) {\n            return yScale(max_x);\n        }).attr(\"stroke-width\", 2).attr(\"stroke\", \"black\");\n    }\n    //  d3.select(\"#NAcount\").text(\"There are \" + nanCount + \" number of NA values in the relation.\");\n}\n\n/** needs doc */\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select('#setxRightBottomLeft').append('table');\n        var thead = table.append('thead');\n        var tbody = table.append('tbody');\n\n        // append the header row\n        thead.append('tr').selectAll('th').data(columns).enter().append('th').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll('tr').data(data).enter().append('tr');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll('td').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append('td').text(function (d) {\n            return d.value;\n        }).attr('id', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        if (allNodes[findNodeIndex(features[i])].valid == 0) {\n            xval = 0;\n            x1val = 0;\n            mydata.push({ \"Variables\": features[i], \"From\": xval, \"To\": x1val });\n            continue;\n        }\n\n        var myi = i + 1;\n        var mysvg = features[i] + \"_setxLeft_\" + myi;\n        var xval = byId(mysvg).querySelector('.xval').innerHTML;\n        var x1val = byId(mysvg).querySelector('.x1val').innerHTML;\n        xval = xval.split(\"x: \").pop();\n        x1val = x1val.split(\"x1: \").pop();\n        console.log(xval);\n        console.log(mysvg);\n\n        mydata.push({ \"Variables\": features[i], \"From\": xval, \"To\": x1val });\n    }\n\n    // render the table(s)\n    tabulate(mydata, ['Variables', 'From', 'To']); // 2 column table\n}\n\n/**\n  rpc ExportPipeline(PipelineExportRequest) returns (Response) {}\n*/\nasync function exportpipeline(pipelineId) {\n    console.log(pipelineId);\n    var res = await makeRequest(D3M_SVC_URL + 'exportpipeline', { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: '<<EXECUTABLE_URI>>' });\n    res && console.log('Executable for ' + pipelineId + ' has been written');\n}\n\n/** needs doc */\nfunction deletepipeline() {\n    console.log(\"DELETE CALLED\");\n}\n\n/**\n   D3M API HELPERS\n   because these get built in various places, pulling them out for easy manipulation\n*/\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\n/** needs doc */\nfunction apiFeatureShortPath(vars, uri) {\n    var out = [];\n    var shortUri = uri.substring(0, uri.lastIndexOf(\"/\"));\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: shortUri });\n    }\n    return out;\n}\n\n/**\n   silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\n*/\nfunction apiSession(context) {\n    return { session_id: context };\n}\n\n/**\n *  Send a status message to the TA3 console\n */\nfunction ta3_search_message(user_msg) {\n\n    var ta3_search_message = { 'message': user_msg };\n\n    var end_search_url = 'ta3-search/send-reviewer-message';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: 'POST', data: ta3_search_message });\n        console.log('ta3_search_message succeeded:' + res);\n    } catch (err) {\n        console.log('ta3_search_message failed: ' + err);\n    }\n}\n\nfunction test_msg_ta3_search() {}\n//end_ta3_search(true, 'it worked!');\n//end_ta3_search(false, 'it failed!');\n//ta3_search_message('just sending a message!');\n\n\n/**\n *  End the TA3 search.  This sends a message\n *  to the ta3_search console as well as message\n *  for the console to exit with a:\n *  - return code 0 for success\n *  - return code -1 for failure\n *\n *  > is_success - boolean\n *  > user_msg - string sent to the console\n */\nfunction end_ta3_search(is_success, user_msg) {\n\n    var end_search_msg = { 'is_success': is_success,\n        'message': user_msg };\n\n    var end_search_url = 'ta3-search/end-search';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: 'POST', data: end_search_msg });\n        console.log('end_ta3_search succeeded:' + res);\n    } catch (err) {\n        console.log('end_ta3_search failed: ' + err);\n    }\n}\n\n/**\n *  record user metadata\n */\nvar recorder_cnt = 0;\nvar save_workspace_url = '/workspaces/record-user-workspace';\n\nfunction record_user_metadata() {\n\n    // (1) Set domain identifier: differs for D3M, Dataverse, etc\n    //\n    var domain_identifier = 'unknown!';\n    if (IS_D3M_DOMAIN) {\n        // domain specific identifier\n        domain_identifier = domainIdentifier;\n    } /*else if (IS_DATAVERSE_DOMAIN){\n       domain_identifier = 'TODO: DV IDENTIFIER';\n      }else if (IS_EVENTDATA_DOMAIN){\n       domain_identifier = 'TODO: EVENTDATA IDENTIFIER';\n      }*/\n\n    if (zparams == null) {\n        console.log('No workspace recording. zparams not defined');\n        return;\n    }\n    if (allNodes == null) {\n        console.log('No workspace recording. zparams not defined');\n        return;\n    }\n\n    // (2) Format workspace data\n    //\n    var workspace_data = { 'app_domain': APP_DOMAIN,\n        'domain_identifier': domain_identifier,\n        'allnodes': allNodes,\n        'zparams': zparams\n\n        //console.log('workspace_data: ' + workspace_data);\n\n        // (3) Save workspace data\n        //\n    };try {\n        var res = _mithril2.default.request(save_workspace_url, { method: 'POST', data: workspace_data });\n        recorder_cnt++;\n        console.log('Session recorded: (cnt: ' + recorder_cnt + ') ' + res);\n    } catch (err) {\n        console.log('record_user_metadata failed: ' + err);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL2FwcC5qcz9mZTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBob3BzY290Y2ggZnJvbSAnaG9wc2NvdGNoJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHtiYXJzLCBiYXJzTm9kZSwgYmFyc1N1YnNldCwgZGVuc2l0eSwgZGVuc2l0eU5vZGUsIHNlbFZhckNvbG9yfSBmcm9tICcuL3Bsb3RzLmpzJztcblxuLy8gaG9zdG5hbWUgZGVmYXVsdCAtIHRoZSBhcHAgd2lsbCB1c2UgaXQgdG8gb2J0YWluIHRoZSB2YXJpYWJsZSBtZXRhZGF0YVxuLy8gKGRkaSkgYW5kIHByZS1wcm9jZXNzZWQgZGF0YSBpbmZvIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkIGFzIGFuXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC5cbi8vIEVkaXQgaXQgdG8gc3VpdCB5b3VyIGluc3RhbGxhdGlvbi5cbi8vIChOT1RFIHRoYXQgaWYgdGhlIGZpbGUgaWQgaXNuJ3Qgc3VwcGxpZWQsIHRoZSBhcHAgd2lsbCBkZWZhdWx0IHRvIHRoZVxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kXG4vLyB0aGUgdGFiLWRlbGltaXRlZCBkYXRhIGZpbGU7IHRoZSBwYXJhbWV0ZXJzIGFyZSBkZGl1cmwgYW5kIGRhdGF1cmwuXG4vLyBUaGVzZSBuZXcgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIElmIHRoZXkgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFwcFxuLy8gd2lsbCBnbyB0aGUgb2xkIHJvdXRlIC0gd2lsbCB0cnkgdG8gY29vayBzdGFuZGFyZCBkYXRhdmVyc2UgdXJsc1xuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlXG4vLyBsb2NhbCBmaWxlcyBpZiBub3RoaW5nIGlzIHN1cHBsaWVkLlxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE5PVEU6IGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdyBzZXQgaW4gdGhlIGluZGV4Lmh0bWwgZmlsZS5cbi8vICAgIERldmVsb3BlcnMsIHNlZSAvdGVtcGxhdGUvaW5kZXguaHRtbFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBsZXQgaXNfcmVzdWx0c19tb2RlID0gdHJ1ZTtcbmV4cG9ydCBsZXQgcGlwX3Byb3AgPSBbXTtcbi8vIGZvciBkZWJ1Z2dpbmcgLSBpZiBub3QgaW4gUFJPRFVDVElPTiwgcHJpbnRzIGFyZ3NcbmV4cG9ydCBsZXQgY2RiID0gXyA9PiBQUk9EVUNUSU9OIHx8IGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG5cbmxldCBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxubGV0IHR1dG9yaWFsX21vZGUgPSBmYWxzZTtcbmxldCBmaXJzdF9sb2FkID0gdHJ1ZTtcblxuLy8gaW5pdGlhbCBjb2xvciBzY2FsZSB1c2VkIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbCBjb2xvcnMgb2Ygbm9kZXNcbi8vIGFsbE5vZGVzLnB1c2goKSBiZWxvdyBlc3RhYmxpc2hlcyBhIGZpZWxkIGZvciB0aGUgbWFzdGVyIG5vZGUgYXJyYXkgYWxsTm9kZXMgY2FsbGVkIFwibm9kZUNvbFwiIGFuZCBhc3NpZ25zIGEgY29sb3IgZnJvbSB0aGlzIHNjYWxlIHRvIHRoYXQgZmllbGRcbi8vIGV2ZXJ5dGhpbmcgdGhlcmUgYWZ0ZXIgc2hvdWxkIHJlZmVyIHRvIHRoZSBub2RlQ29sIGFuZCBub3QgdGhlIGNvbG9yIHNjYWxlLCB0aGlzIGVuYWJsZXMgdXMgdG8gdXBkYXRlIGNvbG9ycyBhbmQgcGFzcyB0aGUgdmFyaWFibGUgdHlwZSB0byBSIGJhc2VkIG9uIGl0cyBjb2xvcmluZ1xubGV0IGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcbmV4cG9ydCBsZXQgY3NDb2xvciA9ICcjNDE5NjQxJztcbmV4cG9ydCBsZXQgZHZDb2xvciA9ICcjMjhhNGM5JztcbmV4cG9ydCBsZXQgZ3IxQ29sb3IgPSAnIzE0YmRjYyc7ICAvLyBpbml0aWFsbHkgd2FzICMyNGE0YzknLCBidXQgdGhhdCBpcyBkdkNvbG9yLCBhbmQgd2UgdHJhY2sgc29tZSBwcm9wZXJ0aWVzIGJ5IGNvbG9yIGFzc3VtaW5nIHRoZW0gdW5pcXVlXG5sZXQgZ3IxT3BhY2l0eSA9IFswLDFdO1xuZXhwb3J0IGxldCBncjJDb2xvciA9ICcjZmZjY2NjJztcbmxldCBncjJPcGFjaXR5ID0gWzAsMV07XG5cbmxldCBncmF5Q29sb3IgPSAnI2MwYzBjMCc7XG5leHBvcnQgbGV0IG5vbUNvbG9yID0gJyNmZjY2MDAnO1xuZXhwb3J0IGxldCB2YXJDb2xvciA9ICcjZjBmOGZmJzsgLy8gZDMucmdiKFwiYWxpY2VibHVlXCIpO1xubGV0IHRhZ2dlZENvbG9yID0gJyNmNWY1ZjUnOyAvLyBkMy5yZ2IoXCJ3aGl0ZXNtb2tlXCIpO1xuZXhwb3J0IGxldCB0aW1lQ29sb3IgPSAnIzJkNmNhMic7XG5cbmV4cG9ydCBsZXQgbGVmdHRhYiA9ICd0YWIxJzsgLy8gY3VycmVudCB0YWIgaW4gbGVmdCBwYW5lbFxuZXhwb3J0IGxldCBzdWJzZXQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgcmlnaHR0YWIgPSAnYnRuTW9kZWxzJzsgLy8gY3VycmVudCB0YWIgaW4gcmlnaHQgcGFuZWxcblxuLy8gdHJhbnNmb3JtYXRpb24gdG9vbGJhciBvcHRpb25zXG5sZXQgdCwgdHlwZVRyYW5zZm9ybTtcbmV4cG9ydCBsZXQgdHJhbnNmb3JtTGlzdCA9ICdsb2coZCkgZXhwKGQpIGReMiBzcXJ0KGQpIGludGVyYWN0KGQsZSknLnNwbGl0KCcgJyk7XG5sZXQgdHJhbnNmb3JtVmFyID0gJyc7XG5cbi8vIHZhciBsaXN0IGZvciBlYWNoIHNwYWNlIGNvbnRhaW4gdmFyaWFibGVzIGluIG9yaWdpbmFsIGRhdGFcbi8vIHBsdXMgdHJhbnMgaW4gdGhhdCBzcGFjZVxubGV0IHRyYW5zID0gW107XG5sZXQgcHJlcHJvY2VzcyA9IHt9OyAvLyBob2xkIHByZS1wcm9jZXNzZWQgZGF0YVxubGV0IHNwYWNlcyA9IFtdO1xuXG4vLyBsYXlvdXQgZnVuY3Rpb24gY29uc3RhbnRzXG5jb25zdCBsYXlvdXRBZGQgPSBcImFkZFwiO1xuY29uc3QgbGF5b3V0TW92ZSA9IFwibW92ZVwiO1xuXG4vLyByYWRpdXMgb2YgY2lyY2xlXG5jb25zdCBSQURJVVMgPSA0MDtcblxuLy8gY3gsIGN5LCByIHZhbHVlcyBmb3IgaW5kaWNhdG9yIGxpZ2h0c1xubGV0IGluZDEgPSBbKFJBRElVUyszMCkgKiBNYXRoLmNvcygxLjMpLCAtMSooUkFESVVTKzMwKSAqIE1hdGguc2luKDEuMyksIDVdO1xubGV0IGluZDIgPSBbKFJBRElVUyszMCkgKiBNYXRoLmNvcygxLjEpLCAtMSooUkFESVVTKzMwKSAqIE1hdGguc2luKDEuMSksIDVdO1xuXG4vLyBzcGFjZSBpbmRleFxubGV0IG15c3BhY2UgPSAwO1xuXG5sZXQgZm9yY2V0b2dnbGUgPSBbXCJ0cnVlXCJdO1xuZXhwb3J0IGxldCBsb2NrdG9nZ2xlID0gdHJ1ZTtcbmxldCBwcml2ID0gdHJ1ZTtcblxuLy8gc3dhbmRpdmUgaXMgb3VyIGdyYWNlZnVsIGZhaWwgZm9yIGQzbVxuLy8gc3dhbmRpdmUgc2V0IHRvIHRydWUgaWYgdGFzayBpcyBpbiBmYWlsc2V0XG5sZXQgc3dhbmRpdmUgPSBmYWxzZTtcbmxldCBmYWlsc2V0ID0gW1wiVElNRVNFUklFU0ZPUkVDQVNUSU5HXCIsXCJHUkFQSE1BVENISU5HXCIsXCJMSU5LUFJFRElDVElPTlwiLFwidGltZVNlcmllc0ZvcmVjYXN0aW5nXCIsXCJncmFwaE1hdGNoaW5nXCIsXCJsaW5rUHJlZGljdGlvblwiXTtcblxuZXhwb3J0IGxldCBsb2dBcnJheSA9IFtdO1xuZXhwb3J0IGxldCB6cGFyYW1zID0ge1xuICAgIHpkYXRhOiBbXSxcbiAgICB6ZWRnZXM6IFtdLFxuICAgIHp0aW1lOiBbXSxcbiAgICB6bm9tOiBbXSxcbiAgICB6Y3Jvc3M6IFtdLFxuICAgIHptb2RlbDogXCJcIixcbiAgICB6dmFyczogW10sXG4gICAgemR2OiBbXSxcbiAgICB6Z3JvdXAxOiBbXSxcbiAgICB6Z3JvdXAyOiBbXSwgICAgICAgLy8gaGFyZCBjb2RpbmcgdG8gdHdvIGdyb3VwcyBmb3IgcHJlc2VudCBleHBlcmltZW50cywgYnV0IHdpbGwgZXZlbnR1YWxseSBtYWtlIHpncm91cCBhcnJheSBvZiBhcnJheXMsIHdpdGggemdyb3VwLmxlbmdodCB0aGUgbnVtYmVyIG9mIGdyb3Vwc1xuICAgIHpkYXRhdXJsOiBcIlwiLFxuICAgIHpkM21kYXRhOiBcIlwiLCAvL3RoZXNlIHRha2UgdGhlIHBsYWNlIG9mIHpkYXRhdXJsIGZvciBkM20sIGJlY2F1c2UgZGF0YSBpcyBpbiB0d28gcGxhY2Vlcy4gZXZlbnR1YWxseSB3aWxsIGdlbmVyYWxpemVcbiAgICB6ZDNtdGFyZ2V0OiBcIlwiLFxuICAgIHpzdWJzZXQ6IFtdLFxuICAgIHpzZXR4OiBbXSxcbiAgICB6bW9kZWxjb3VudDogMCxcbiAgICB6cGxvdDogW10sXG4gICAgenNlc3Npb25pZDogXCJcIixcbiAgICB6ZGF0YWNpdGU6ICcuLi4nLFxuICAgIHpjcm9zc3RhYjogW10sXG4gICAgenVzZXJuYW1lOiAnJyxcbn07XG5cbmV4cG9ydCBsZXQgbW9kZWxDb3VudCA9IDA7XG5leHBvcnQgbGV0IHZhbHVlS2V5ID0gW107XG5leHBvcnQgbGV0IGFsbE5vZGVzID0gW107XG5leHBvcnQgbGV0IGFsbFJlc3VsdHMgPSBbXTtcbmV4cG9ydCBsZXQgbm9kZXMgPSBbXTtcbmV4cG9ydCBsZXQgbGlua3MgPSBbXTtcbmxldCBtb2RzID0ge307XG5sZXQgZXN0aW1hdGVkID0gZmFsc2U7XG5sZXQgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbmxldCBzZWxJbnRlcmFjdCA9IGZhbHNlO1xuZXhwb3J0IGxldCBjYWxsSGlzdG9yeSA9IFtdOyAvLyB0cmFuc2Zvcm0gYW5kIHN1YnNldCBjYWxsc1xubGV0IG15dGFyZ2V0ID0gJyc7XG5cbmxldCBjb25maWd1cmF0aW9ucyA9IHt9O1xubGV0IGRhdGFkb2N1bWVudCA9IHt9O1xuXG5leHBvcnQgbGV0IGRvbWFpbklkZW50aWZpZXIgPSBudWxsOyAvLyBhdmFpbGFibGUgdGhyb3VnaG91dCBhcHBzIGpzOyB1c2VkIGZvciBzYXZpbmcgd29ya3NwYWNlXG5cbi8vIGV2ZW50dWFsbHkgcmVhZCB0aGlzIGZyb20gdGhlIHNjaGVtYSB3aXRoIHJlYWwgZGVzY3JpcHRpb25zXG4vLyBtZXRyaWNzLCB0YXNrcywgYW5kIHN1YnRhc2tzIGFzIHNwZWNpZmllZCBpbiBEM00gc2NoZW1hc1xuLy8gTUVBTiBTUVVBUkVEIEVSUk9SIElTIFNFVCBUTyBTQU1FIEFTIFJNU0UuIE1TRSBpcyBpbiBzY2hlbWEgYnV0IG5vdCBwcm90b1xuZXhwb3J0IGxldCBkM21UYXNrVHlwZSA9IHtcbiAgICB0YXNrVHlwZVVuZGVmaW5lZDogW1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1RZUEVfVU5ERUZJTkVEXCIsIDBdLFxuICAgIGNsYXNzaWZpY2F0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNMQVNTSUZJQ0FUSU9OXCIgLCAxXSxcbiAgICByZWdyZXNzaW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIlJFR1JFU1NJT05cIiAsIDJdLFxuICAgIGNsdXN0ZXJpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiQ0xVU1RFUklOR1wiLCAzXSxcbiAgICBsaW5rUHJlZGljdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJMSU5LX1BSRURJQ1RJT05cIiAsIDRdLFxuICAgIHZlcnRleE5vbWluYXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiVkVSVEVYX05PTUlOQVRJT05cIiAsIDVdLFxuICAgIGNvbW11bml0eURldGVjdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJDT01NVU5JVFlfREVURUNUSU9OXCIgLCA2XSxcbiAgICBncmFwaENsdXN0ZXJpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiR1JBUEhfQ0xVU1RFUklOR1wiICwgN10sXG4gICAgZ3JhcGhNYXRjaGluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJHUkFQSF9NQVRDSElOR1wiICwgOF0sXG4gICAgdGltZVNlcmllc0ZvcmVjYXN0aW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIlRJTUVfU0VSSUVTX0ZPUkVDQVNUSU5HXCIgLCA5XSxcbiAgICBjb2xsYWJvcmF0aXZlRmlsdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNPTExBQk9SQVRJVkVfRklMVEVSSU5HXCIgLCAxMF1cbn07XG5cbmV4cG9ydCBsZXQgZDNtVGFza1N1YnR5cGUgPSB7XG4gICAgdGFza1N1YnR5cGVVbmRlZmluZWQ6W1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1NVQlRZUEVfVU5ERUZJTkVEXCIsIDBdLFxuICAgIHN1YnR5cGVOb25lOltcImRlc2NyaXB0aW9uXCIsXCJOT05FXCIsMV0sXG4gICAgYmluYXJ5OltcImRlc2NyaXB0aW9uXCIsIFwiQklOQVJZXCIgLCAyXSxcbiAgICBtdWx0aUNsYXNzOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElDTEFTU1wiICwgM10sXG4gICAgbXVsdGlMYWJlbDpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJTEFCRUxcIiAsIDRdLFxuICAgIHVuaXZhcmlhdGU6W1wiZGVzY3JpcHRpb25cIiwgXCJVTklWQVJJQVRFXCIgLCA1XSxcbiAgICBtdWx0aXZhcmlhdGU6W1wiZGVzY3JpcHRpb25cIiwgXCJNVUxUSVZBUklBVEVcIiAsIDZdLFxuICAgIG92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiT1ZFUkxBUFBJTkdcIiAsIDddLFxuICAgIG5vbk92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiTk9OT1ZFUkxBUFBJTkdcIiAsIDhdXG59O1xuLypleHBvcnQgbGV0IGQzbU91dHB1dFR5cGUgPSB7XG4gICAgb3V0cHV0VW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsXCJPVVRQVVRfVFlQRV9VTkRFRklORUQgXCIsIDBdLFxuICAgIHByZWRpY3Rpb25zRmlsZTpbXCJkZXNjcmlwdGlvblwiLFwiUFJFRElDVElPTlNfRklMRVwiLDFdLFxuICAgIHNjb3Jlc0ZpbGU6W1wiZGVzY3JpcHRpb25cIixcIlNDT1JFU19GSUxFXCIsMl1cbn07ICovXG5leHBvcnQgbGV0IGQzbU1ldHJpY3MgPSB7XG4gICAgbWV0cmljVW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsIFwiTUVUUklDX1VOREVGSU5FRFwiICwgMF0sXG4gICAgZXhlY3V0aW9uVGltZTpbXCJkZXNjcmlwdGlvblwiLCBcIkVYRUNVVElPTl9USU1FXCIsIDFdLFxuICAgIGFjY3VyYWN5IDogW1wiZGVzY3JpcHRpb25cIiwgXCJBQ0NVUkFDWVwiICwgMl0sXG4gICAgZjE6W1wiZGVzY3JpcHRpb25cIiwgXCJGMVwiICwgM10sXG4gICAgZjFNaWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01JQ1JPXCIgLCA0XSxcbiAgICBmMU1hY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiRjFfTUFDUk9cIiAsIDVdLFxuICAgIHJvY0F1YzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNcIiAsIDZdLFxuICAgIHJvY0F1Y01pY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NSUNST1wiICwgN10sXG4gICAgcm9jQXVjTWFjcm86W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDX01BQ1JPXCIgLCA4XSxcbiAgICBtZWFuU3F1YXJlZEVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiTUVBTl9TUVVBUkVEX0VSUk9SXCIsIDldLFxuICAgIHJvb3RNZWFuU3F1YXJlZEVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiUk9PVF9NRUFOX1NRVUFSRURfRVJST1JcIiAsIDEwXSxcbiAgICByb290TWVhblNxdWFyZWRFcnJvckF2ZzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SX0FWR1wiICwgMTFdLFxuICAgIG1lYW5BYnNvbHV0ZUVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiTUVBTl9BQlNPTFVURV9FUlJPUlwiICwgMTJdLFxuICAgIHJTcXVhcmVkOltcImRlc2NyaXB0aW9uXCIsIFwiUl9TUVVBUkVEXCIgLCAxM10sXG4gICAgbm9ybWFsaXplZE11dHVhbEluZm9ybWF0aW9uOltcImRlc2NyaXB0aW9uXCIsIFwiTk9STUFMSVpFRF9NVVRVQUxfSU5GT1JNQVRJT05cIiAsIDE0XSxcbiAgICBqYWNjYXJkU2ltaWxhcml0eVNjb3JlOltcImRlc2NyaXB0aW9uXCIsIFwiSkFDQ0FSRF9TSU1JTEFSSVRZX1NDT1JFXCIgLCAxNV1cbn07XG5cbmV4cG9ydCBsZXQgZDNtUHJvYmxlbURlc2NyaXB0aW9uID0ge1xuICAgIHRhc2tUeXBlOiBbMixcIkRFRkFVTFRcIl0sXG4gICAgdGFza1N1YnR5cGU6IFsxLFwiREVGQVVMVFwiXSxcbiAvLyAgIG91dHB1dFR5cGU6IFszLFwiREVGQVVMVFwiXSxcbiAgICBtZXRyaWM6IFszLFwiREVGQVVMVFwiXSxcbiAgICB0YXNrRGVzY3JpcHRpb246IFwiXCJcbn07XG5cbmxldCBzdmcsIHdpZHRoLCBoZWlnaHQsIGRpdiwgc2VsZWN0TGFkZGE7XG5leHBvcnQgbGV0IGVzdGltYXRlTGFkZGE7XG5cbi8vIGFyY3MgZm9yIGRlbm90aW5nIHBlYmJsZSBjaGFyYWN0ZXJpc3RpY3NcbmNvbnN0IGFyYyA9IChzdGFydCwgZW5kKSA9PiBkMy5zdmcuYXJjKClcbiAgICAuaW5uZXJSYWRpdXMoUkFESVVTICsgNSlcbiAgICAub3V0ZXJSYWRpdXMoUkFESVVTICsgMjApXG4gICAgLnN0YXJ0QW5nbGUoc3RhcnQpXG4gICAgLmVuZEFuZ2xlKGVuZCk7XG5jb25zdCBbYXJjMCwgYXJjMSwgYXJjMiwgYXJjMywgYXJjNF0gPSBbYXJjKDAsIDMuMiksIGFyYygwLCAxKSwgYXJjKDEuMSwgMi4yKSwgYXJjKDIuMywgMy4zKSwgYXJjKDQuMywgNS4zKV07XG5jb25zdCBhcmNJbmQgPSAoYXJjbGltaXRzKSA9PiBkMy5zdmcuYXJjKClcbiAgICAuaW5uZXJSYWRpdXMoUkFESVVTICsgMjIpXG4gICAgLm91dGVyUmFkaXVzKFJBRElVUyArIDM3KVxuICAgIC5zdGFydEFuZ2xlKGFyY2xpbWl0c1swXSlcbiAgICAuZW5kQW5nbGUoYXJjbGltaXRzWzFdKTtcblxuY29uc3QgW2FyY0luZDFMaW1pdHMsIGFyY0luZDJMaW1pdHNdID0gW1swLCAwLjNdLCBbMC4zNSwgMC42NV1dO1xuY29uc3QgW2FyY0luZDEsIGFyY0luZDJdID0gW2FyY0luZChhcmNJbmQxTGltaXRzKSwgYXJjSW5kKGFyY0luZDJMaW1pdHMpXTtcblxuZXhwb3J0IGxldCBieUlkID0gaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4vKipcbiAgIHBhZ2UgcmVsb2FkIGxpbmtlZCB0byBidG5SZXNldFxuKi9cbmV4cG9ydCBjb25zdCByZXNldCA9IGZ1bmN0aW9uIHJlbG9hZFBhZ2UoKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG59O1xuZXhwb3J0IGxldCByZXN0YXJ0O1xuXG5sZXQgZGF0YXVybCA9ICcnO1xuXG4vKipcbiAgY2FsbGVkIGJ5IG1haW5cbiAgTG9hZHMgYWxsIGV4dGVybmFsIGRhdGEgaW4gdGhlIGZvbGxvd2luZyBvcmRlciAobG9naWMgaXMgbm90IGluY2x1ZGVkKTpcbiAgMS4gUmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25cbiAgMi4gU2V0ICdjb25maWd1cmF0aW9ucydcbiAgMy4gUmVhZCB0aGUgcHJvYmxlbSBzY2hlbWEgYW5kIHNldCAnZDNtUHJvYmxlbURlc2NyaXB0aW9uJ1xuICA0LiBSZWFkIHRoZSBkYXRhIGRvY3VtZW50IGFuZCBzZXQgJ2RhdGFkb2N1bWVudCdcbiAgNS4gUmVhZCBpbiB6ZWxpZyBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICA2LiBSZWFkIGluIHplbGlnY2hvaWNlIG1vZGVscyAobm90IGZvciBkM20pXG4gIDcuIFN0YXJ0IHRoZSB1c2VyIHNlc3Npb25cbiAgOC4gUmVhZCBwcmVwcm9jZXNzIGRhdGEgb3IgKGlmIG5lY2Vzc2FyeSkgcnVuIHByZXByb2Nlc3NcbiAgOS4gQnVpbGQgYWxsTm9kZXNbXSB1c2luZyBwcmVwcm9jZXNzZWQgaW5mb3JtYXRpb25cbiAgMTAuIEFkZCBkYXRhZG9jdW1lbnQgaW5mb3JtYXRpb24gdG8gYWxsTm9kZXMgKHdoZW4gaW4gSVNfRDNNX0RPTUFJTilcbiAgMTEuIENhbGwgbGF5b3V0KCkgYW5kIHN0YXJ0IHVwXG4qL1xuYXN5bmMgZnVuY3Rpb24gbG9hZChob2xkLCBsYWJsQXJyYXksIGQzbVJvb3RQYXRoLCBkM21EYXRhTmFtZSwgZDNtUHJlcHJvY2VzcywgZDNtRGF0YSwgZDNtUFMsIGQzbURTLCBwVVJMKSB7XG4gICAgaWYgKCFJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAxLiBSZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvblxuICAgIGxldCByZXMgPSBhd2FpdCBtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICB1cmw6IFwiL2NvbmZpZy9kM20tY29uZmlnL2pzb24vbGF0ZXN0XCJcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgIC8vIDIuIFNldCAnY29uZmlndXJhdGlvbnMnXG4gICAgY29uZmlndXJhdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcykpOyAvLyB0aGlzIGlzIGp1c3QgY29weWluZyByZXNcbiAgICBkM21Sb290UGF0aCA9IGNvbmZpZ3VyYXRpb25zLnRyYWluaW5nX2RhdGFfcm9vdC5yZXBsYWNlKC9cXC9kYXRhLywnJyk7XG4gICAgZDNtRGF0YU5hbWUgPSBjb25maWd1cmF0aW9ucy5uYW1lO1xuXG4gICAgLy8gc2NvcGVzIGF0IGFwcC5qcyBsZXZlbDsgdXNlZCBmb3Igc2F2aW5nIHdvcmtzcGFjZVxuICAgIGRvbWFpbklkZW50aWZpZXIgPSB7bmFtZTogY29uZmlndXJhdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZV91cmw6IGNvbmZpZ3VyYXRpb25zLmNvbmZpZ191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0QzTSBjb25maWcgZmlsZSd9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZDogY29uZmlndXJhdGlvbnMuaWR9O1xuXG4gICAgZDNtUFMgPSBcIi9jb25maWcvZDNtLWNvbmZpZy9nZXQtcHJvYmxlbS1zY2hlbWEvanNvblwiO1xuICAgIGQzbURTID0gXCIvY29uZmlnL2QzbS1jb25maWcvZ2V0LWRhdGFzZXQtc2NoZW1hL2pzb25cIjtcbiAgICBjb25zb2xlLmxvZyhcIkNvbmZpZ3VyYXRpb25zOiBcIiwgY29uZmlndXJhdGlvbnMpO1xuICAgIGQzbVByZXByb2Nlc3MgPSBwVVJMID0gYHJvb2stY3VzdG9tL3Jvb2stZmlsZXMvJHtkM21EYXRhTmFtZX0vcHJlcHJvY2Vzcy9wcmVwcm9jZXNzLmpzb25gO1xuXG4gICAgLy8gMy4gUmVhZCB0aGUgcHJvYmxlbSBzY2hlbWEgYW5kIHNldCAnZDNtUHJvYmxlbURlc2NyaXB0aW9uJ1xuICAgIC8vIC4uLmFuZCBtYWtlIGEgY2FsbCB0byBzdGFydCB0aGUgc2Vzc2lvbiB3aXRoIFRBMi4gaWYgd2UgZ2V0IHRoaXMgZmFyLCBkYXRhIGFyZSBndWFyYW50ZWVkIHRvIGV4aXN0IGZvciB0aGUgZnJvbnRlbmRcbiAgIFxuICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChcIi9jb25maWcvZDNtLWNvbmZpZy9nZXQtcHJvYmxlbS1kYXRhLWZpbGUtaW5mb1wiKTtcbiAgIFxuICAgIC8vIHNvbWUgc2ltcGxlIGxvZ2ljIHRvIGdldCB0aGUgcGF0aHMgcmlnaHRcbiAgICAvLyBub3RlIHRoYXQgaWYgbmVpdGhlciBleGlzdCwgc3RheSBhcyBkZWZhdWx0IHdoaWNoIGlzIG51bGxcbiAgICBcbiAgICBsZXQgc2V0ID0gKGZpZWxkLCB2YWwpID0+IHJlcy5kYXRhW2ZpZWxkXS5leGlzdHMgPyByZXMuZGF0YVtmaWVsZF0ucGF0aCA6XG4gICAgICAgIHJlcy5kYXRhW2ZpZWxkICsgJy5neiddLmV4aXN0cyA/IHJlcy5kYXRhW2ZpZWxkICsgJy5neiddLnBhdGggOlxuICAgICAgICB2YWw7XG5cbiAgICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YSA9IHNldCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuICAgIHpwYXJhbXMuemQzbXRhcmdldCA9IHNldCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuXG4gICAgLy8gaGFyZGNvZGluZyB0aGlzLCBvbmNlIGdldC1wcm9ibGVtLWRhdGEtZmlsZS1pbmZvIGlzIHJldmlzZWQgdGhpcyBoYXJkY29kZSBjYW4gZ28gYXdheSBhbmQgdXNlIHRoZSBwcmV2aW91cyB0d28gTE9DXG4gIC8vICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YSA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcbiAgLy8gIHpwYXJhbXMuemQzbXRhcmdldCA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcblxuICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChkM21QUyk7XG4gICAgY29uc29sZS5sb2coXCJwcm9iIHNjaGVtYSBkYXRhOiBcIiwgcmVzKTtcblxuICAgIG15dGFyZ2V0ID0gcmVzLmlucHV0cy5kYXRhWzBdLnRhcmdldHNbMF0uY29sTmFtZTsgLy8gZWFzaWVyIHdheSB0byBhY2Nlc3MgdGFyZ2V0IG5hbWU/XG5cbiAgLy8gIHNldCA9IChmaWVsZCwgYXJyKSA9PiBkM21Qcm9ibGVtRGVzY3JpcHRpb25bZmllbGRdID0gcmVzW2ZpZWxkXSBpbiBhcnIgPyByZXNbZmllbGRdIDogZmllbGQgKyAnVW5kZWZpbmVkJztcbiAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGU9cmVzLmFib3V0LnRhc2tUeXBlO1xuICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZT1yZXMuYWJvdXQudGFza1N1YlR5cGU7XG4gICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHJlcy5pbnB1dHMucGVyZm9ybWFuY2VNZXRyaWNzWzBdLm1ldHJpYztcbiAvLyAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gcmVzLmV4cGVjdGVkT3V0cHV0cy5wcmVkaWN0aW9uc0ZpbGU7XG4gLy8gICBzZXQoJ3Rhc2tUeXBlJywgZDNtVGFza1R5cGUpO1xuIC8vICAgc2V0KCd0YXNrU3VidHlwZScsIGQzbVRhc2tTdWJ0eXBlKTtcbiAvLyAgIHNldCgnbWV0cmljJywgZDNtTWV0cmljcyk7XG4gLy8gICBzZXQoJ291dHB1dFR5cGUnLCBkM21PdXRwdXRUeXBlKTtcbiAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9uID0gcmVzLmRlc2NyaXB0aW9uRmlsZTtcbiAgICBieUlkKFwiYnRuVHlwZVwiKS5jbGljaygpO1xuXG4gICAgLy8gbWFraW5nIGl0IGNhc2UgaW5zZW5zaXRpdmUgYmVjYXVzZSB0aGUgY2FzZSBzZWVtcyB0byBkaXNhZ3JlZSBhbGwgdG9vIG9mdGVuXG4gICAgaWYgKGZhaWxzZXQuaW5jbHVkZXMoZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHN3YW5kaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyA0LiBSZWFkIHRoZSBkYXRhIGRvY3VtZW50IGFuZCBzZXQgJ2RhdGFkb2N1bWVudCdcbiAgICBkYXRhZG9jdW1lbnQgPSBhd2FpdCBtLnJlcXVlc3QoZDNtRFMpO1xuICAgIFxuICAgIGlmIChJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIGxldCBkYXRhc2V0TmFtZSA9IGRhdGFkb2N1bWVudC5hYm91dC5kYXRhc2V0TmFtZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgXCJkYXRhc2V0TmFtZVwiIGZpZWxkIGluIGRhdGFzZXQgZG9jdW1lbnRcbiAgICAgICAgenBhcmFtcy56ZGF0YSA9IGRhdGFzZXROYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZGF0YXNldE5hbWUuc2xpY2UoMSk7IC8vIE1ha2Ugc3VyZSB0byBjYXBpdGFsaXplO1xuICAgICAgICBsZXQgY2l0ZSA9IGRhdGFkb2N1bWVudC5hYm91dC5jaXRhdGlvbjtcbiAgICAgICAgY29uc29sZS5sb2coY2l0ZSk7XG4gICAgICAgIGxldCBuZXdjaXRlID0gY2l0ZS5tYXRjaCgve1xccypbXFx3XFwuXStcXHMqfS9nKS5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geC5tYXRjaCgvW1xcd1xcLl0rLylbMF07IH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhuZXdjaXRlKTtcbiAgICAgICAgLypcbiAgICAgICAgLy8gY2xlYW4gY2l0YXRpb25cbiAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjaXRlXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwmL2csIFwiYW5kXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw7L2csIFwiLFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJS9nLCBcIi1cIik7XG4gICAgICAgIC8vIGZpbGwgaW4gY2l0YXRpb24gaW4gaGVhZGVyXG4gICAgICAgICQoJyNjaXRlIGRpdi5wYW5lbC1ib2R5JykudGV4dCh6cGFyYW1zLnpkYXRhY2l0ZSk7XG4gICAgICAgICovXG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3RlOiBwcmVzZW50bHkgeG1sIGlzIG5vIGxvbmdlciBiZWluZyByZWFkIGZyb20gRGF0YXZlcnNlIG1ldGFkYXRhIGFueXdoZXJlXG4gICAgICAgIGxldCB0ZW1wID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZpbGVOYW1lXCIpO1xuICAgICAgICB6cGFyYW1zLnpkYXRhID0gdGVtcFswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IGNpdGUgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmlibENpdFwiKTtcbiAgICAgICAgLy8gY2xlYW4gY2l0YXRpb24gc28gUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2l0ZVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJi9nLCBcImFuZFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcOy9nLCBcIixcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCUvZywgXCItXCIpO1xuICAgICAgICAvLyBmaWxsIGluIGNpdGF0aW9uIGluIGhlYWRlclxuICAgICAgICAkKCcjY2l0ZSBkaXYucGFuZWwtYm9keScpLnRleHQoenBhcmFtcy56ZGF0YWNpdGUpO1xuICAgIH1cbiAgICAvLyBkcm9wIGZpbGUgZXh0ZW5zaW9uXG4gICAgbGV0IGRhdGFuYW1lID0gSVNfRDNNX0RPTUFJTiA/IHpwYXJhbXMuemRhdGEgOiB6cGFyYW1zLnpkYXRhLnJlcGxhY2UoL1xcLiguKikvLCAnJyk7XG5cbiAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIikuaHRtbChkYXRhbmFtZSk7XG4gICAgXG4gICAgLy8gcHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gcGFnZSB0aXRsZVxuICAgIGQzLnNlbGVjdChcInRpdGxlXCIpLmh0bWwoXCJUd29SYXZlbnMgXCIgKyBkYXRhbmFtZSk7XG5cbiAgICAvLyBpZiBzd2FuZGl2ZSwgd2UgaGF2ZSB0byBzZXQgdmFsdWVLZXkgaGVyZSBzbyB0aGF0IGxlZnQgcGFuZWwgY2FuIHBvcHVsYXRlXG4gICAgaWYgKHN3YW5kaXZlKSB7XG4gICAgICAgIFtkYXRhZG9jdW1lbnQudHJhaW5EYXRhLnRyYWluRGF0YSwgZGF0YWRvY3VtZW50LnRyYWluRGF0YS50cmFpblRhcmdldHNdXG4gICAgICAgICAgICAuZm9yRWFjaCh2YXJzID0+IHZhcnMgJiYgdmFycy5mb3JFYWNoKHYgPT4gdmFsdWVLZXkucHVzaCh2LnZhck5hbWUpKSk7XG4gICAgICAgIC8vIGVuZCBzZXNzaW9uIGlmIG5laXRoZXIgdHJhaW5EYXRhIG5vciB0cmFpblRhcmdldHM/XG4gICAgICAgIHZhbHVlS2V5Lmxlbmd0aCA9PT0gMCAmJiBhbGVydChcIm5vIHRyYWluRGF0YSBvciB0cmFpblRhcmdlc3QgaW4gZGF0YSBkZXNjcmlwdGlvbiBmaWxlLiB2YWx1ZUtleSBsZW5ndGggaXMgMFwiKTtcbiAgICAgICAgLy8gcGVyaGFwcyBhbGxvdyB1c2VycyB0byB1bmxvY2sgYW5kIHNlbGVjdCB0aGluZ3M/XG4gICAgICAgIGJ5SWQoJ2J0bkxvY2snKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnYnRuRXJhc2VyJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGJ5SWQoJ2J0blN1YnNldCcpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBieUlkKCdtYWluJykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZXknO1xuICAgICAgICBieUlkKCd3aGl0ZXNwYWNlJykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZXknO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiZGF0YSBzY2hlbWEgZGF0YTogXCIsIGRhdGFkb2N1bWVudCk7XG5cbiAgICAvLyA1LiBSZWFkIGluIHplbGlnIG1vZGVscyAobm90IGZvciBkM20pXG4gICAgLy8gNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICAgIGlmICghSVNfRDNNX0RPTUFJTil7XG4gICAgICBmb3IgKGxldCBmaWVsZCBvZiBbJ3plbGlnNW1vZGVscycsICd6ZWxpZzVjaG9pY2Vtb2RlbHMnXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChgZGF0YS8ke2ZpZWxkfS5qc29uYCk7XG4gICAgICAgICAgICAgIGNkYihmaWVsZCArICcganNvbjogJywgcmVzKTtcbiAgICAgICAgICAgICAgcmVzW2ZpZWxkXVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gcmVzW2ZpZWxkXS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IG1vZHNba2V5Lm5hbWVbMF1dID0ga2V5LmRlc2NyaXB0aW9uWzBdKTtcbiAgICAgICAgICB9IGNhdGNoKF8pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW4ndCBsb2FkIFwiICsgZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gNy4gU3RhcnQgdGhlIHVzZXIgc2Vzc2lvblxuICAgIC8vIHJwYyBTdGFydFNlc3Npb24oU2Vzc2lvblJlcXVlc3QpIHJldHVybnMgKFNlc3Npb25SZXNwb25zZSkge31cbiAgICByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvc3RhcnRzZXNzaW9uJywge3VzZXJfYWdlbnQ6ICdzb21lIGFnZW50JywgdmVyc2lvbjogJ3NvbWUgdmVyc2lvbid9KTtcbiAgICBpZiAocmVzKSB7XG4gICAgICAgIHpwYXJhbXMuenNlc3Npb25pZCA9IHJlcy5jb250ZXh0LnNlc3Npb25JZDtcbiAgICB9XG5cbiAgICAvLyBob3BzY290Y2ggdHV0b3JpYWxcbiAgICBpZiAodHV0b3JpYWxfbW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICAgICAgbGV0IHN0ZXAgPSAodGFyZ2V0LCBwbGFjZW1lbnQsIHRpdGxlLCBjb250ZW50KSA9PiAoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgc2hvd0NUQUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgICAgIGN0YUxhYmVsOiAnRGlzYWJsZSB0aGVzZSBtZXNzYWdlcycsXG4gICAgICAgICAgICBvbkNUQTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhvcHNjb3RjaC5lbmRUb3VyKHRydWUpO1xuICAgICAgICAgICAgICAgIHR1dG9yaWFsX21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBob3BzY290Y2guc3RhcnRUb3VyKHtcbiAgICAgICAgICAgIGlkOiBcImRhdGFzZXRfbGF1bmNoXCIsXG4gICAgICAgICAgICBpMThuOiB7ZG9uZUJ0bjonT2snfSxcbiAgICAgICAgICAgIHNob3dDbG9zZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgb25FbmQ6ICgpID0+IGZpcnN0X2xvYWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHN0ZXBzOiBbXG4gICAgICAgICAgICAgICAgc3RlcChcImRhdGFOYW1lXCIsIFwiYm90dG9tXCIsIFwiV2VsY29tZSB0byBUd29SYXZlbnMgU29sdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+VGhpcyB0b29sIGNhbiBndWlkZSB5b3UgdG8gc29sdmUgYW4gZW1waXJpY2FsIHByb2JsZW0gaW4gdGhlIGRhdGFzZXQgYWJvdmUuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgIDxwPlRoZXNlIG1lc3NhZ2VzIHdpbGwgdGVhY2ggeW91IHRoZSBzdGVwcyB0byB0YWtlIHRvIGZpbmQgYW5kIHN1Ym1pdCBhIHNvbHV0aW9uLjwvcD5gKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiYnRuUmVzZXRcIiwgXCJib3R0b21cIiwgXCJSZXN0YXJ0IEFueSBQcm9ibGVtIEhlcmVcIixcbiAgICAgICAgICAgICAgICAgICAgICc8cD5Zb3UgY2FuIGFsd2F5cyBzdGFydCBhIHByb2JsZW0gb3ZlciBieSB1c2luZyB0aGlzIHJlc2V0IGJ1dHRvbi48L3A+JyksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0bkVzdGltYXRlXCIsIFwibGVmdFwiLCBcIlNvbHZlIFByb2JsZW1cIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5UaGUgY3VycmVudCBncmVlbiBidXR0b24gaXMgZ2VuZXJhbGx5IHRoZSBuZXh0IHN0ZXAgdG8gZm9sbG93IHRvIG1vdmUgdGhlIHN5c3RlbSBmb3J3YXJkLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5DbGljayB0aGlzIFNvbHZlIGJ1dHRvbiB0byB0ZWxsIHRoZSB0b29sIHRvIGZpbmQgYSBzb2x1dGlvbiB0byB0aGUgcHJvYmxlbS48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChteXRhcmdldCArICdiaWdncm91cCcsIFwibGVmdFwiLCBcIlRhcmdldCBWYXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgYFRoaXMgaXMgdGhlIHZhcmlhYmxlLCAke215dGFyZ2V0fSwgd2UgYXJlIHRyeWluZyB0byBwcmVkaWN0LlxuICAgICAgICAgICAgICAgICAgICAgIFRoaXMgY2VudGVyIHBhbmVsIGdyYXBoaWNhbGx5IHJlcHJlc2VudHMgdGhlIHByb2JsZW0gY3VycmVudGx5IGJlaW5nIGF0dGVtcHRlZC5gKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiZ3IxaHVsbFwiLCBcInJpZ2h0XCIsIFwiRXhwbGFuYXRpb24gU2V0XCIsIFwiVGhpcyBzZXQgb2YgdmFyaWFibGVzIGNhbiBwb3RlbnRpYWxseSBwcmVkaWN0IHRoZSB0YXJnZXQuXCIpLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJkaXNwbGFjZW1lbnRcIiwgXCJyaWdodFwiLCBcIlZhcmlhYmxlIExpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5DbGljayBvbiBhbnkgdmFyaWFibGUgbmFtZSBoZXJlIGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBwcm9ibGVtIHNvbHV0aW9uLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5Zb3UgbGlrZWx5IGRvIG5vdCBuZWVkIHRvIGFkanVzdCB0aGUgcHJvYmxlbSByZXByZXNlbnRhdGlvbiBpbiB0aGUgY2VudGVyIHBhbmVsLjwvcD5gKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiYnRuRW5kU2Vzc2lvblwiLCBcImJvdHRvbVwiLCBcIkZpbmlzaCBQcm9ibGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICBcIklmIHRoZSBzb2x1dGlvbiByZXBvcnRlZCBiYWNrIHNlZW1zIGFjY2VwdGFibGUsIHRoZW4gZmluaXNoIHRoaXMgcHJvYmxlbSBieSBjbGlja2luZyB0aGlzIEVuZCBTZXNzaW9uIGJ1dHRvbi5cIiksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ0VuZGluZyBIb3BzY290Y2ggVG91cicpO1xuICAgIH1cblxuICAgIC8vIDguIHJlYWQgcHJlcHJvY2VzcyBkYXRhIG9yIChpZiBuZWNlc3NhcnkpIHJ1biBwcmVwcm9jZXNzXG4gICAgLy8gTk9URTogcHJlcHJvY2Vzcy5qc29uIGlzIG5vdyBndWFyYW50ZWVkIHRvIGV4aXN0Li4uXG5cbiAgICAvL21pdGFsIDogQ3VzdG9tIHBpcGVsaW5lIG9iamVjdFxuICAgIGxldCBwaXBlbGluZV9vYmogPVtcbiAgICAgICAge1xuICAgICAgICBcInBpcGVsaW5lSWRcIjogXCJwaXBlbGluZV8xXCIsXG4gICAgICAgIFwibW9kdWxlc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIm1vZHVsZV9pZCAwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibW9kdWxlX3R5cGUgMFwiLFxuICAgICAgICAgICAgICAgIFwibGFiZWxcIjogXCJtb2R1bGVfbGFiZWwgMFwiLFxuICAgICAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9tZSAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0eXBlIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJ2YWx1ZSAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9tZSAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0eXBlIDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwibW9kdWxlX2lkIDFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJtb2R1bGVfdHlwZSAxXCIsXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBcIm1vZHVsZV9sYWJlbCAxXCIsXG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub21lIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInR5cGUgMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcInZhbHVlIDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub21lIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInR5cGUgMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiY29ubmVjdGlvbnNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiZnJvbU1vZHVsZUlkXCI6IFwibW9kdWxlIDBcIixcbiAgICAgICAgICAgICAgICBcImZyb21PdXRwdXROYW1lXCI6IFwiZnJvbV9vdXRwdXRfbmFtZSAwXCIsXG4gICAgICAgICAgICAgICAgXCJ0b01vZHVsZUlkXCI6IFwidG9fbW9kdWxlX2lkIDBcIixcbiAgICAgICAgICAgICAgICBcInRvSW5wdXROYW1lXCI6IFwidG9faW5wdXRfbmFtZSAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJmcm9tTW9kdWxlSWRcIjogXCJtb2R1bGUgMVwiLFxuICAgICAgICAgICAgICAgIFwiZnJvbU91dHB1dE5hbWVcIjogXCJmcm9tX291dHB1dF9uYW1lIDFcIixcbiAgICAgICAgICAgICAgICBcInRvTW9kdWxlSWRcIjogXCJ0b19tb2R1bGVfaWQgMVwiLFxuICAgICAgICAgICAgICAgIFwidG9JbnB1dE5hbWVcIjogXCJ0b19pbnB1dF9uYW1lIDFcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInJlc3BvbnNlSW5mb1wiOiB7XG4gICAgICAgICAgICBcInN0YXR1c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjb2RlXCI6IFwiT0tcIixcbiAgICAgICAgICAgICAgICBcImRldGFpbHNcIjogXCIoc3RhdGljIHRlc3QgcmVzcG9uc2UpXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBcInBpcGVsaW5lSWRcIjogXCJwaXBlbGluZV8yXCIsXG4gICAgICAgIFwibW9kdWxlc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIm1vZHVsZV9pZCAwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibW9kdWxlX3R5cGUgMFwiLFxuICAgICAgICAgICAgICAgIFwibGFiZWxcIjogXCJtb2R1bGVfbGFiZWwgMFwiLFxuICAgICAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9tZSAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0eXBlIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJ2YWx1ZSAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9tZSAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0eXBlIDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwibW9kdWxlX2lkIDFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJtb2R1bGVfdHlwZSAxXCIsXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBcIm1vZHVsZV9sYWJlbCAxXCIsXG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub21lIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInR5cGUgMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcInZhbHVlIDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub21lIDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInR5cGUgMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwiY29ubmVjdGlvbnNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiZnJvbU1vZHVsZUlkXCI6IFwibW9kdWxlIDBcIixcbiAgICAgICAgICAgICAgICBcImZyb21PdXRwdXROYW1lXCI6IFwiZnJvbV9vdXRwdXRfbmFtZSAwXCIsXG4gICAgICAgICAgICAgICAgXCJ0b01vZHVsZUlkXCI6IFwidG9fbW9kdWxlX2lkIDBcIixcbiAgICAgICAgICAgICAgICBcInRvSW5wdXROYW1lXCI6IFwidG9faW5wdXRfbmFtZSAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJmcm9tTW9kdWxlSWRcIjogXCJtb2R1bGUgMVwiLFxuICAgICAgICAgICAgICAgIFwiZnJvbU91dHB1dE5hbWVcIjogXCJmcm9tX291dHB1dF9uYW1lIDFcIixcbiAgICAgICAgICAgICAgICBcInRvTW9kdWxlSWRcIjogXCJ0b19tb2R1bGVfaWQgMVwiLFxuICAgICAgICAgICAgICAgIFwidG9JbnB1dE5hbWVcIjogXCJ0b19pbnB1dF9uYW1lIDFcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInJlc3BvbnNlSW5mb1wiOiB7XG4gICAgICAgICAgICBcInN0YXR1c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjb2RlXCI6IFwiT0tcIixcbiAgICAgICAgICAgICAgICBcImRldGFpbHNcIjogXCIoc3RhdGljIHRlc3QgcmVzcG9uc2UpXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXVxuICAgIC8vIGNvbnNvbGUubG9nKFwicGlwZWxpbmVcIilcbiAgICAvLyBjb25zb2xlLmxvZyhwaXBlbGluZV9vYmpbMF0ucGlwZWxpbmVJZClcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGlmKGlzX3Jlc3VsdHNfbW9kZSl7XG4gICAgICAgIHBpcGVsaW5lX29iai5mb3JFYWNoKGZ1bmN0aW9uKHBpcGUpe1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BpcGUnKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocGlwZSlcbiAgICAgICAgICAgIHByZXByb2Nlc3NbY291bnQrK10gPSBwaXBlO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocHJlcHJvY2VzcylcbiAgICAgICAgfSlcbiAgICB9XG5lbHNle1xuXG4gICAgbGV0IHJlYWQgPSByZXMgPT4ge1xuICAgICAgICBwcml2ID0gcmVzLmRhdGFzZXQucHJpdmF0ZSB8fCBwcml2O1xuICAgICAgICBjb25zb2xlLmxvZygncmVzIHBpcGxpZXMnKVxuICAgICAgICBjb25zb2xlLmxvZyhyZXMpXG4gICAgICAgIE9iamVjdC5rZXlzKHJlcy52YXJpYWJsZXMpLmZvckVhY2goayA9PiBwcmVwcm9jZXNzW2tdID0gcmVzLnZhcmlhYmxlc1trXSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnYXR0ZW1wdCB0byByZWFkIHByZXByb2Nlc3MgZmlsZSAod2hpY2ggbWF5IG5vdCBleGlzdCk6ICcgKyBwVVJMKTtcbiAgICAgICAgaWYoaXNfcmVzdWx0c19tb2RlKXtcbiAgICAgICAgICAgIHJlcyA9IHJlYWQoYXdhaXQgcGlwZWxpbmVfb2JqKTsvL2F3YWl0IG0ucmVxdWVzdChwVVJMKSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmVzID0gcmVhZChhd2FpdCBtLnJlcXVlc3QocFVSTCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVzLi5cIilcbiAgICAgICAgY29uc29sZS5sb2cocmVzKVxuICAgIH0gY2F0Y2goXykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9rLCBwcmVwcm9jZXNzIG5vdCBmb3VuZCwgdHJ5IHRvIFJVTiBUSEUgUFJFUFJPQ0VTU0FQUFwiKTtcbiAgICAgICAgbGV0IHVybCA9IFJPT0tfU1ZDX1VSTCArICdwcmVwcm9jZXNzYXBwJztcbiAgICAgICAgdmFyIGpzb25faW5wdXQ7XG4gICAgICAgIGlmIChJU19EM01fRE9NQUlOKXtcbiAgICAgICAgICAvLyBGb3IgRDNNIGlucHV0cywgY2hhbmdlIHRoZSBwcmVwcm9jZXNzIGlucHV0IGRhdGFcbiAgICAgICAgICAvL1xuICAgICAgICAgIGpzb25faW5wdXQgPSBKU09OLnN0cmluZ2lmeSh7ZGF0YTogZDNtRGF0YSwgZGF0YXN0dWI6IGQzbURhdGFOYW1lfSk7XG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICBqc29uX2lucHV0ID0gSlNPTi5zdHJpbmdpZnkoe2RhdGE6IGRhdGFsb2MsIHRhcmdldDogdGFyZ2V0bG9jLCBkYXRhc3R1YjogZGF0YXN0dWJ9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdqc29uX2lucHV0OiAnLCBqc29uX2lucHV0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3VybDogJywgdXJsKTtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IHJlYWQoYXdhaXQgbS5yZXF1ZXN0KHttZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGRhdGE6IGpzb25faW5wdXR9KSk7XG4gICAgICAgIH0gY2F0Y2goXykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3ByZXByb2Nlc3MgZmFpbGVkJyk7XG4gICAgICAgICAgICBhbGVydCgncHJlcHJvY2VzcyBmYWlsZWQuIGVuZGluZyB1c2VyIHNlc3Npb24uJyk7XG4gICAgICAgICAgICBlbmRzZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiAgICBcbiAgICAvLyA5LiBCdWlsZCBhbGxOb2Rlc1tdIHVzaW5nIHByZXByb2Nlc3NlZCBpbmZvcm1hdGlvblxuICAgIGxldCB2YXJzID0gT2JqZWN0LmtleXMocHJlcHJvY2Vzcyk7XG4gICAgY29uc29sZS5sb2coXCJwcmVwcm9jZXNzLXZhcnNcIilcbiAgICBjb25zb2xlLmxvZyhwcmVwcm9jZXNzKVxuICAgIC8vIHZhcnMgPSBbXCJwaXBlbGluZV8xXCIsIFwicGlwZWxpbmVfMlwiXVxuXG4gICAgLy8gdGVtcG9yYXJ5IHZhbHVlcyBmb3IgaG9sZCB0aGF0IGNvcnJlc3BvbmQgdG8gaGlzdG9ncmFtIGJpbnNcbiAgICBob2xkID0gWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gdmFsdWVLZXlbaV0gPSB2YXJzW2ldLmF0dHJpYnV0ZXMubmFtZS5ub2RlVmFsdWU7XG4gICAgICAgIC8vIGxhYmxBcnJheVtpXSA9IHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpLmxlbmd0aCA9PSAwID9cbiAgICAgICAgLy8gXCJubyBsYWJlbFwiIDpcbiAgICAgICAgLy8gdmFyc1hNTFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxhYmxcIilbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG4gICAgICAgIC8vIGxldCBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgLy8gICAgIC5iaW5zKGJhcm51bWJlcikuZnJlcXVlbmN5KGZhbHNlKVxuICAgICAgICAvLyAgICAgKFswLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIHZhbHVlS2V5W2ldID0gdmFyc1tpXTtcbiAgICAgICAgbGFibEFycmF5W2ldID0gXCJubyBsYWJlbFwiO1xuICAgICAgICAvLyBjb250YWlucyBhbGwgdGhlIHByZXByb2Nlc3NlZCBkYXRhIHdlIGhhdmUgZm9yIHRoZSB2YXJpYWJsZSwgYXMgd2VsbCBhcyBVSSBkYXRhIHBlcnRpbmVudCB0byB0aGF0IHZhcmlhYmxlLFxuICAgICAgICAvLyBzdWNoIGFzIHNldHggdmFsdWVzIChpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlbSkgYW5kIHBlYmJsZSBjb29yZGluYXRlc1xuICAgICAgICBsZXQgb2JqID0ge1xuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbmFtZTogcHJlcHJvY2Vzc1t2YWx1ZUtleVtpXV0ucGlwZWxpbmVJZCxcbiAgICAgICAgICAgIGxhYmw6IGxhYmxBcnJheVtpXSxcbiAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICBjb3VudDogaG9sZCxcbiAgICAgICAgICAgIG5vZGVDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcbiAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIHNldHhwbG90OiBmYWxzZSxcbiAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgIGdyb3VwMTogZmFsc2UsXG4gICAgICAgICAgICBncm91cDI6IGZhbHNlLFxuICAgICAgICAgICAgZm9yZWZyb250OiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGFuZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvYmogYmVmb3JlIG1lcmdlXCIpXG4gICAgICAgIGNvbnNvbGUubG9nKG9iailcbiAgICAgICAgY29uc29sZS5sb2coXCJwcmVwcm9jZXNzXCIpXG4gICAgICAgIGNvbnNvbGUubG9nKHByZXByb2Nlc3NbdmFsdWVLZXlbaV1dKVxuICAgICAgICBjb25zb2xlLmxvZyhcInZhbHVlIEtleVwiKVxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZUtleVtpXSlcbiAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmosIHByZXByb2Nlc3NbdmFsdWVLZXlbaV1dKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvYmogYWZ0ZXIgbWVyZ2VcIilcbiAgICAgICAgY29uc29sZS5sb2cob2JqKVxuICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iaik7XG5cbiAgICAgICAgLy9cblxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIi4uLkFsbCBub2Rlc1wiKVxuICAgIGNvbnNvbGUubG9nKGFsbE5vZGVzKSAgIFxuICAgIFxuICAgIGxldCBsZW4gPSBhbGxOb2Rlcy5sZW5ndGg7XG5cbiAgICBmb3IobGV0IGkgPSAwIDsgaTwgYWxsTm9kZXMubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgZm9yKGxldCBqPTAgOyBqPCBhbGxOb2Rlc1tpXS5tb2R1bGVzLmxlbmd0aCA7IGorKyl7XG4gICAgICAgICAgICBsZXQgb2JqID0ge1xuICAgICAgICAgICAgICAgIGlkOiBsZW4rKyxcbiAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGFsbE5vZGVzW2ldLm1vZHVsZXNbal0uaWQsXG4gICAgICAgICAgICAgICAgbGFibDogXCJubyBsYWJlbHNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgICAgIG5vZGVDb2w6IGFsbE5vZGVzW2ldLm5vZGVDb2wsIC8vIE5lZWQgdG8gY2hhbmdlIHRvIGRpZmZlcmVudCBzaGFkZSA7IGFkZCBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgYmFzZUNvbDogYWxsTm9kZXNbaV0ubm9kZUNvbCxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogc2VsVmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN1YnNldHJhbmdlOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgZ3JheW91dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ3JvdXAxOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBncm91cDI6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9yZWZyb250OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGFsbE5vZGVzW2ldLnBpcGVsaW5lSWRcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlwX3Byb3AucHVzaChvYmopXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhbGxOb2Rlc1tpXS5wcm9wZXJ0aWVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhwaXBfcHJvcClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcImFsbE5vZGVzXCIpO1xuICAgIGNvbnNvbGUubG9nKGFsbE5vZGVzKTtcbiAgICBjb25zb2xlLmxvZyhhbGxOb2Rlcy5sZW5ndGgpXG5cbiAgICAvLyAxMC4gQWRkIGRhdGFkb2N1bWVudCBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBJU19EM01fRE9NQUlOKVxuICAgaWYoIWlzX3Jlc3VsdHNfbW9kZSl7XG4gICAgbGV0IGRhdGF2YXJzID0gZGF0YWRvY3VtZW50LmRhdGFSZXNvdXJjZXNbMF0uY29sdW1ucztcbiAgICBkYXRhdmFycy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGxldCBteWkgPSBmaW5kTm9kZUluZGV4KHYuY29sTmFtZSk7XG4gICAgICAgIGFsbE5vZGVzW215aV0gPSBPYmplY3QuYXNzaWduKGFsbE5vZGVzW215aV0sIHtkM21EZXNjcmlwdGlvbjogdn0pO1xuICAgIH0pO1xuICAgfVxuICAgIFxuICAgIC8vIHJlc3VsdF9sYXlvdXQoZmFsc2UsIHRydWUpO1xuICAgIC8vIDExLiBDYWxsIGxheW91dCgpIGFuZCBzdGFydCB1cGxheW91dFxuICAgIGlmKGlzX3Jlc3VsdHNfbW9kZSl7XG4gICAgICAgIHJlc3VsdF9sYXlvdXQoZmFsc2UsIHRydWUpO1xuICAgIH1lbHNle1xuICAgICAgICBsYXlvdXQoZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIElTX0QzTV9ET01BSU4gPyB6UG9wKCkgOiBkYXRhRG93bmxvYWQoKTtcbn1cblxuLyoqXG4gICBjYWxsZWQgb24gYXBwIHN0YXJ0XG4gICBAcGFyYW0ge3N0cmluZ30gZmlsZWlkXG4gICBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWVcbiAgIEBwYXJhbSB7c3RyaW5nfSBkZGl1cmxcbiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhdXJsXG4gICBAcGFyYW0ge3N0cmluZ30gYXBpa2V5XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG1haW4oZmlsZWlkLCBob3N0bmFtZSwgZGRpdXJsLCBkYXRhdXJsLCBhcGlrZXkpIHtcbiAgICBpZiAoUFJPRFVDVElPTiAmJiBmaWxlaWQgPT09ICcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnRXJyb3I6IE5vIGZpbGVpZCBoYXMgYmVlbiBwcm92aWRlZC4nO1xuICAgICAgICBhbGVydChtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YXZlcnNldXJsID0gaG9zdG5hbWUgPyAnaHR0cHM6Ly8nICsgaG9zdG5hbWUgOlxuICAgICAgICBQUk9EVUNUSU9OID8gREFUQVZFUlNFX1VSTCA6XG4gICAgICAgICdodHRwOi8vbG9jYWxob3N0OjgwODAnO1xuICAgIC8vIGlmIGZpbGUgaWQgc3VwcGxpZWQsIGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmxcbiAgICAvLyB3aXRoIHRoZSBmaWxlaWQgc3VwcGxpZWQgYW5kIHRoZSBob3N0bmFtZSB3ZSBoYXZlIHN1cHBsaWVkIG9yIGNvbmZpZ3VyZWRcbiAgICBkYXRhdXJsID0gZmlsZWlkICYmICFkYXRhdXJsID8gYCR7ZGF0YXZlcnNldXJsfS9hcGkvYWNjZXNzL2RhdGFmaWxlLyR7ZmlsZWlkfT9rZXk9JHthcGlrZXl9YCA6IGRhdGF1cmw7XG4gICAgY2RiKCctLWRhdGF1cmw6ICcgKyBkYXRhdXJsKTtcbiAgICBjZGIoJy0tZGF0YXZlcnNldXJsOiAnICsgZGF0YXZlcnNldXJsKTtcblxuICAgIGxldCB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoJyNtYWluLmxlZnQnKS5zdHlsZSgnd2lkdGgnKTtcbiAgICB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgdGVtcFdpZHRoLmxlbmd0aCAtIDIpO1xuICAgIGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIDEyMDsgLy8gaGFyZCBjb2RlIGhlYWRlciwgZm9vdGVyLCBhbmQgYm90dG9tIG1hcmdpblxuXG4gICAgZXN0aW1hdGVMYWRkYSA9IExhZGRhLmNyZWF0ZShieUlkKFwiYnRuRXN0aW1hdGVcIikpO1xuICAgIHNlbGVjdExhZGRhID0gTGFkZGEuY3JlYXRlKGJ5SWQoXCJidG5TZWxlY3RcIikpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgLy8gaW5kaWNhdG9ycyBmb3Igc2hvd2luZyBtZW1iZXJzaGlwIGFib3ZlIGFyY3NcbiAgICAvLyBsZXQgaW5kaWNhdG9yID0gKGRlZ3JlZSkgPT4gZDMuc3ZnLmNpcmNsZSgpXG4gICAgLy8gICAgIC5jeCggUkFESVVTICkvLyhSQURJVVMrMzUpICogTWF0aC5zaW4oZGVncmVlKSlcbiAgICAvLyAgICAgLmN5KCBSQURJVVMgKS8vKFJBRElVUyszNSkgKiBNYXRoLmNvcyhkZWdyZWUpKVxuICAgIC8vICAgICAucigzKTtcbiAgICAvLyBpbmQxID0gaW5kaWNhdG9yKDEpO1xuICAgIC8vIGluZDIgPSBpbmRpY2F0b3IoMS4yKTtcblxuICAgIC8vIGZyb20gLmNzdlxuICAgIGxldCBbaG9sZCwgbGFibEFycmF5XSA9IFtbXSwgW11dO1xuXG4gICAgLy8gYXNzdW1lIGxvY2F0aW9ucyBhcmUgY29uc2lzdGVudCBiYXNlZCBvbiBkM20gZGlyZWN0b3J5IHN0cnVjdHVyZVxuICAgIGxldCBkM21Sb290UGF0aCA9ICcnO1xuICAgIGxldCBkM21EYXRhTmFtZSA9ICcnO1xuICAgIGxldCBkM21EYXRhID0gbnVsbDtcbiAgICBsZXQgZDNtUHJlcHJvY2VzcyA9ICcnO1xuICAgIGxldCBkM21QUyA9ICcnO1xuICAgIGxldCBkM21EUyA9ICcnO1xuXG4gICAgLy8gZGVmYXVsdCB0byBGZWFyb24gTGFpdGluXG4gICAgbGV0IGRhdGEgPSAnZGF0YS8nICsgKGZhbHNlID8gJ1BVTVM1c21hbGwnIDogJ2ZlYXJvbkxhaXRpbicpO1xuICAgIGxldCBtZXRhZGF0YXVybCA9IGRkaXVybCB8fCAoZmlsZWlkID8gYCR7ZGF0YXZlcnNldXJsfS9hcGkvbWV0YS9kYXRhZmlsZS8ke2ZpbGVpZH1gIDogZGF0YSArICcueG1sJyk7XG4gICAgLy8gcmVhZCBwcmUtcHJvY2Vzc2VkIG1ldGFkYXRhIGFuZCBkYXRhXG4gICAgbGV0IHBVUkwgPSBkYXRhdXJsID8gYCR7ZGF0YXVybH0mZm9ybWF0PXByZXBgIDogZGF0YSArICcuanNvbic7XG5cbiAgICBpZiAoSVNfRDNNX0RPTUFJTikge1xuICAgICAgICBwVVJMID0gZDNtUHJlcHJvY2VzcztcbiAgICB9IGVsc2UgaWYgKCFQUk9EVUNUSU9OKSB7XG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSAnZGF0YS9mZWFyb25MYWl0aW4udHN2JztcbiAgICB9XG5cbiAgICBsb2FkKGhvbGQsIGxhYmxBcnJheSwgZDNtUm9vdFBhdGgsIGQzbURhdGFOYW1lLCBkM21QcmVwcm9jZXNzLCBkM21EYXRhLCBkM21QUywgZDNtRFMsIHBVUkwpO1xufVxuXG5sZXQgJGZpbGwgPSAob2JqLCBvcCwgZDEsIGQyKSA9PiBkMy5zZWxlY3Qob2JqKS50cmFuc2l0aW9uKClcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5Jywgb3ApXG4gICAgLmRlbGF5KGQxKVxuICAgIC5kdXJhdGlvbihkMik7XG5sZXQgZmlsbCA9IChkLCBpZCwgb3AsIGQxLCBkMikgPT4gJGZpbGwoJyMnICsgaWQgKyBkLmlkLCBvcCwgZDEsIGQyKTtcbmxldCBmaWxsVGhpcyA9IChzZWxmLCBvcCwgZDEsIGQyKSA9PiAkZmlsbChzZWxmLCBvcCwgZDEsIGQyKTtcblxuLyoqXG4gICBkZWxldGVzIHRoZSBpdGVtIGF0IGluZGV4IGZyb20gYXJyYXkuXG4gICBpZiBvYmplY3QgaXMgcHJvdmlkZWQsIGRlbGV0ZXMgZmlyc3QgaW5zdGFuY2Ugb2Ygb2JqZWN0IGZyb20gYXJyYXkuXG4gICBAcGFyYW0ge09iamVjdFtdfSBhcnIgLSBhcnJheVxuICAgQHBhcmFtIHtudW1iZXJ9IGlkeCAtIGluZGV4XG4gICBAcGFyYW0ge09iamVjdH0gW29ial0gLSBvYmplY3RcbiovXG5mdW5jdGlvbiBkZWwoYXJyLCBpZHgsIG9iaikge1xuICAgIGlkeCA9IG9iaiA/IGFyci5pbmRleE9mKG9iaikgOiBpZHg7XG4gICAgaWR4ID4gLTEgJiYgYXJyLnNwbGljZShpZHgsIDEpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB6cGFyYW1zUmVzZXQodGV4dCkge1xuICAgICd6ZHYgemNyb3NzIHp0aW1lIHpub20nLnNwbGl0KCcgJykuZm9yRWFjaCh4ID0+IGRlbCh6cGFyYW1zW3hdLCAtMSwgdGV4dCkpO1xufVxuLy8tLS0gbWl0YWwgcmVzdWx0IGxheW91dCBmdW5jdGlvblxuXG5mdW5jdGlvbiByZXN1bHRfbGF5b3V0KHYsIHYyKSB7XG4gICAgY29uc29sZS5sb2coXCJpbiBsYXlvdXQgZnVuY3Rpb25cIilcbiAgICB2YXIgcGlwZWxpbmVfcCA9IFtdO1xuICAgIG5vZGVzID0gW107XG4gICAgbGlua3MgPSBbXTtcblxuICAgIHN2Zy5hcHBlbmQoXCJzdmc6ZGVmc1wiKS5hcHBlbmQoXCJzdmc6bWFya2VyXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJncm91cDEtYXJyb3dcIilcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxNSAxNScpXG4gICAgICAgIC5hdHRyKFwicmVmWFwiLCAyLjUpXG4gICAgICAgIC5hdHRyKFwicmVmWVwiLCAwKVxuICAgICAgICAuYXR0cihcIm1hcmtlcldpZHRoXCIsIDMpXG4gICAgICAgIC5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDMpXG4gICAgICAgIC5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKVxuICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMi1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcik7XG5cbiAgICB2YXIgbGluZSA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMS1hcnJvdylcIik7XG5cbiAgICB2YXIgbGluZTIgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgNSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNncm91cDItYXJyb3cpXCIpOztcblxuICAgIHZhciB2aXNiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXNiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIikgLy8gbm90ZSBsaW5lcywgYXJlIGJlaGluZCBncm91cCBodWxscyBvZiB3aGljaCB0aGVyZSBpcyBhIHdoaXRlIGFuZCBjb2xvcmVkIHNlbWkgdHJhbnNwYXJlbnQgbGF5ZXJcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB2YXIgdmlzMmJhY2tncm91bmQgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczJiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB2YXIgdmlzID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXMuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsICdncjFodWxsJylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuXG4gICAgdmFyIHZpczIgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczIuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqUkFESVVTKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XG5cbiAgICBpZiAodiA9PSBsYXlvdXRBZGQgfHwgdiA9PSBsYXlvdXRNb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dClcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gaGVyZSBtaXRhbFxuICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpaV0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0genBhcmFtcy56dmFyc1tqXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcIiNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICgpID0+IGhleFRvUmdiYShub2Rlc1tqXS5zdHJva2VDb2xvcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB6cGFyYW1zLnplZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIG15c3JjID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzBdKTtcbiAgICAgICAgICAgIHZhciBteXRndCA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVsxXSk7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzW215c3JjXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzW215dGd0XSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZihJU19EM01fRE9NQUlOKSB7XG4gICAgICAgICAgICAvL25vZGVzID0gW2ZpbmROb2RlKG15dGFyZ2V0KV07ICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZGVwZW5kZW50IHZhcmlhYmxlIG9uIHN0YXJ0dXBcbiAgICAgICAgICAgIG5vZGVzID0gYWxsTm9kZXMuc2xpY2UoMCxhbGxOb2Rlcy5sZW5ndGgpOyAgICAvLyBBZGQgYWxsIGJ1dCBmaXJzdCB2YXJpYWJsZSBvbiBzdGFydHVwIChhc3N1bWVzIDAgcG9zaXRpb24gaXMgZDNtIGluZGV4IHZhcmlhYmxlKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5hbWUgIT0gbXl0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbal0uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnB1c2gobm9kZXNbal0ubmFtZSk7ICAvLyB3cml0ZSBhbGwgbmFtZXMgKGV4Y2VwdCBkM20gaW5kZXggYW5kIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUpIHRvIHpncm91cDEgYXJyYXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoXCJUaGVyZSBhcmUgemVybyB2YXJpYWJsZXMgaW4gdGhlIG1ldGFkYXRhLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhbmVsUGxvdHMoKTsgLy8gYWZ0ZXIgbm9kZXMgaXMgcG9wdWxhdGVkLCBhZGQgc3Vic2V0IGFuZCAoaWYgIUlTX0QzTV9ET01BSU4pIHNldHggcGFuZWxzXG5cbiAgICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuICAgICAgICAubm9kZXMobm9kZXMpXG4gICAgICAgIC5saW5rcyhsaW5rcylcbiAgICAgICAgLnNpemUoW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgICAubGlua0Rpc3RhbmNlKDE1MClcbiAgICAgICAgLmNoYXJnZSgtZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICByZXR1cm4gLTEwMCpkLnI7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigndGljaycsIHRpY2spO1xuXG4gICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnZW5kLWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNilcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RhcnQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA0KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgLy8gbGluZSBkaXNwbGF5ZWQgd2hlbiBkcmFnZ2luZyBuZXcgbm9kZXNcbiAgICB2YXIgZHJhZ19saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgICAuYXR0cignZCcsICdNMCwwTDAsMCcpO1xuXG4gICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgdmFyIHBhdGggPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgncGF0aCcpLFxuICAgICAgICBjaXJjbGUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnZycpO1xuICAgICAgICAvL2xpbmUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnbGluZScpO1xuXG4gICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgIHZhciBzZWxlY3RlZF9ub2RlID0gbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsLFxuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRNb3VzZVZhcnMoKSB7XG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBkcmF3IGRpcmVjdGVkIGVkZ2VzIHdpdGggcHJvcGVyIHBhZGRpbmcgZnJvbSBub2RlIGNlbnRlcnNcbiAgICAgICAgcGF0aC5hdHRyKCdkJywgZCA9PiB7XG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gZC50YXJnZXQueCAtIGQuc291cmNlLngsXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gZC50YXJnZXQueSAtIGQuc291cmNlLnksXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpLFxuICAgICAgICAgICAgICAgIG5vcm1YID0gZGVsdGFYIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBub3JtWSA9IGRlbHRhWSAvIGRpc3QsXG4gICAgICAgICAgICAgICAgc291cmNlUGFkZGluZyA9IGQubGVmdCA/IFJBRElVUyArIDUgOiBSQURJVVMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFkZGluZyA9IGQucmlnaHQgPyBSQURJVVMgKyA1IDogUkFESVVTLFxuICAgICAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gZC50YXJnZXQueCAtICh0YXJnZXRQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgICAgICByZXR1cm4gYE0ke3NvdXJjZVh9LCR7c291cmNlWX1MJHt0YXJnZXRYfSwke3RhcmdldFl9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcblxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKSAgICAgICAgICAgLy8gU2hyaW5rL2V4cGFuZCBwZWJibGVzIHRoYXQgam9pbi9sZWF2ZSBncm91cHNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKTtcblxuICAgIH1cblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIHZhckNvbG9yKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcInRhc2tUeXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtVGFza1R5cGUpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNzdWJ0eXBlc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3N1YnR5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcInRhc2tTdWJ0eXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtVGFza1N1YnR5cGUpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNtZXRyaWNzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBkM21Qcm9ibGVtRGVzY3JpcHRpb24ubWV0cmljID0gW1wiXCIsXCJcIl07XG4gICAgICAgICAgICAvLyB0aGlzLmNsYXNzTmFtZT1cIml0ZW0tZGVmYXVsdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcIm1ldHJpY1wiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbU1ldHJpY3MpO1xuICAgICAgICB9KTtcblxuXG4gICAgLy8gdXBkYXRlIGdyYXBoIChjYWxsZWQgd2hlbiBuZWVkZWQpXG4gICAgcmVzdGFydCA9IGZ1bmN0aW9uKCRsaW5rcywgaXNfZXhwbG9yZSkge1xuICAgICAgICBsaW5rcyA9ICRsaW5rcyB8fCBsaW5rcztcbiAgICAgICAgLy8gbm9kZXMuaWQgaXMgcGVnZ2VkIHRvIGFsbE5vZGVzLCBpLmUuIHRoZSBvcmRlciBpbiB3aGljaCB2YXJpYWJsZXMgYXJlIHJlYWQgaW5cbiAgICAgICAgLy8gbm9kZXMuaW5kZXggaXMgZmxvYXRpbmcgYW5kIGRlcGVuZHMgb24gdXBkYXRlcyB0byBub2Rlcy4gIGEgdmFyaWFibGVzIGluZGV4IGNoYW5nZXMgd2hlbiBuZXcgdmFyaWFibGVzIGFyZSBhZGRlZC5cbiAgICAgICAgY2lyY2xlLmNhbGwoZm9yY2UuZHJhZyk7XG4gICAgICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwLjA1KTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZShkID0+IHNldFBlYmJsZUNoYXJnZShkKi01KSk7XG4gICAgICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICAgICAgayA9IDQ7IC8vIHN0cmVuZ3RoIHBhcmFtZXRlciBmb3IgZ3JvdXAgYXR0cmFjdGlvbi9yZXB1bHNpb25cbiAgICAgICAgICAgIGlmICgoenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDApICYgKHpwYXJhbXMuemdyb3VwMi5sZW5ndGggPiAwICkpIHsgLy8gc2NhbGUgZG93biBieSBudW1iZXIgb2YgYWN0aXZlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGsgPSAyLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDAuMik7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMCk7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZS5yZXN1bWUoKTtcblxuICAgICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgbGlua3NcbiAgICAgICAgLy8gVkpEOiBkYXNoZWQgbGlua3MgYmV0d2VlbiBwZWJibGVzIGFyZSBcInNlbGVjdGVkXCIuIHRoaXMgaXMgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+ICFpc19leHBsb3JlICYmIHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4gIWlzX2V4cGxvcmUgJiYgeC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbGlua3NcbiAgICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+ICFpc19leHBsb3JlICYmIHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4gIWlzX2V4cGxvcmUgJiYgeC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBKU09OLnN0cmluZ2lmeShsaW5rc1tqXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWwobGlua3MsIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgICBjaXJjbGUgPSBjaXJjbGUuZGF0YShub2RlcywgeCA9PiB4LmlkKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgeCA9PiB4LnJlZmxleGl2ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHggPT4gZDMucmdiKHguc3Ryb2tlQ29sb3IpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB4ID0+IHguc3Ryb2tlV2lkdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgbGV0IGcgPSBjaXJjbGUuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgICAgICAvLyBhZGQgcGxvdFxuICAgICAgICBnLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkLCB0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT0gJ2JhcicpIGJhcnNOb2RlKGQsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZC5ncm91cDEgPSBkLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZUZXh0JykpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoJyNkdkFyYycpKVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ25vbUFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKFwibm9tVGV4dFwiKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZChcIiNub21BcmNcIikpXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3JBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAgZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMmluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgLy9kLmdyb3VwMSA9ICFkLmdyb3VwMTsgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGVhc2llciwgYnV0IGN1cnJlbnRseSBzZXQgaW4gc2V0Q29sb3JzKClcbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IxaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IyaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAyID0gIWQuZ3JvdXAyOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjJDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnclRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2dyQXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkdyb3Vwc1wiKTtcblxuICAgICAgICBnLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkMy5yZ2IoZC5zdHJva2VDb2xvcikudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGViYmxlXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGVzKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBpcF9wcm9wKVxuICAgICAgICAgICAgICAgIGlmKGQuZ3JvdXAxICYmIGQuZXhwYW5kKXtcbiAgICAgICAgICAgICAgICAgICAgZC5leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy91c2UgcGlwX3Byb3BcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGQubW9kdWxlcy5sZW5ndGg7cCsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGQubW9kdWxlc1twXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZigpe31cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lICE9PSBkLm1vZHVsZXNbcF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gbGlua3MuZmlsdGVyKGZ1bmN0aW9uKGxpbmspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLnRhcmdldC5uYW1lICE9PSBkLm1vZHVsZXNbcF0uaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFsbE5vZGVzKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGQuZ3JvdXAxICYmICFkLmV4cGFuZCl7XG4gICAgICAgICAgICAgICAgICAgIGQuZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDAgOyBpIDwgcGlwX3Byb3AubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBpcF9wcm9wW2ldLnBhcmVudCArXCIgXCIgKyBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGlwX3Byb3BbaV0ucGFyZW50ID09IGQubmFtZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocGlwX3Byb3BbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChwaXBfcHJvcFtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1tkLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1tub2Rlcy5sZW5ndGgtMV0sIC8vIG5vdCBhYmxlIHRvIGFjY2VzcyB3aXRoIG9iamVjdCBpZCEhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGVzKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25fbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG1vdXNlZG93bl9ub2RlID09PSBzZWxlY3RlZF9ub2RlID8gbnVsbCA6IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBkcmFnIGxpbmVcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55KTtcblxuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IEZGXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIHRvIGdyYXBoICh1cGRhdGUgaWYgZXhpc3RzKVxuICAgICAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBsaW5rcy5maWx0ZXIoeCA9PiB4LnNvdXJjZSA9PSBzb3VyY2UgJiYgeC50YXJnZXQgPT0gdGFyZ2V0KVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IG5vZGUgbmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLm5hbWUpO1xuXG4gICAgICAgIC8vIHNob3cgc3VtbWFyeSBzdGF0cyBvbiBtb3VzZW92ZXJcbiAgICAgICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgICAgIGcuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIilcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICB0YWJMZWZ0KCd0YWIzJyk7XG4gICAgICAgICAgICAgICAgdmFyU3VtbWFyeShkKTtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBieUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2snKTtcbiAgICAgICAgICAgICAgICBieUlkKFwidHJhbnNTZWxcIikuc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG5cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2VGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjFpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IxaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21BcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiY3NBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZUFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZVRleHRcIiwgLjUsIDAsIDEwMCk7XG5cbiAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBkID0+IHtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN1bW1hcnlIb2xkIHx8IHRhYkxlZnQoc3Vic2V0ID8gJ3RhYjInIDogJ3RhYjEnKTtcbiAgICAgICAgICAgICAgICAnY3NBcmMgY3NUZXh0IHRpbWVBcmMgdGltZVRleHQgZHZBcmMgZHZUZXh0IG5vbUFyYyBub21UZXh0IGdyQXJjIGdyVGV4dCcuc3BsaXQoJyAnKS5tYXAoeCA9PiBmaWxsKGQsIHgsIDAsIDEwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiB2YXJpYWJsZSBsaXN0IGlzIHNpbGVudGx5IHVwZGF0ZWQgYXMgcGViYmxlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5kYXRhKG5vZGVzLm1hcCh4ID0+IHgubmFtZSkpIC8vIHNldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICAgICBpZighSVNfRDNNX0RPTUFJTil7XG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwgbGknKS5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAnaW50ZXJhY3Rpb24nIGlzIHRoZSBzZWxlY3RlZCBmdW5jdGlvbiwgZG9uJ3Qgc2hvdyB0aGUgZnVuY3Rpb24gbGlzdCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChzZWxJbnRlcmFjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICQoJyN0SW5wdXQnKS52YWwoKS5jb25jYXQoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKG4pO1xuICAgICAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuID0gbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4gPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHQgPSB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgICAgICBjaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBmb3JjZS5zdGFydCgpO1xuXG4gICAgICAgIC8vIHNhdmUgd29ya3NwYWNlc1xuICAgICAgICBjb25zb2xlLmxvZygnb2sgd3MnKTtcbiAgICAgICAgcmVjb3JkX3VzZXJfbWV0YWRhdGEoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZCkge1xuICAgICAgICAvLyBwcmV2ZW50IEktYmFyIG9uIGRyYWdcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgIGlmIChkMy5ldmVudC5jdHJsS2V5IHx8IG1vdXNlZG93bl9ub2RlIHx8IG1vdXNlZG93bl9saW5rKSByZXR1cm47XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZCkge1xuICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyB1cGRhdGUgZHJhZyBsaW5lXG4gICAgICAgIGRyYWdfbGluZS5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBkMy5tb3VzZSh0aGlzKVswXSArICcsJyArIGQzLm1vdXNlKHRoaXMpWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGQpIHtcbiAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlKSB7XG4gICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgfVxuXG4gICAgLy8gYXBwIHN0YXJ0cyBoZXJlXG4gICAgc3ZnLmF0dHIoJ2lkJywgKCkgPT4gXCJ3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge21vdXNlZG93bih0aGlzKTt9KVxuICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbigpIHttb3VzZXVwKHRoaXMpO30pO1xuXG4gICAgZDMuc2VsZWN0KHdpbmRvdylcbiAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGFsbCBjbGlja3Mgd2lsbCBidWJibGUgaGVyZSB1bmxlc3MgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmVzdGFydCgpOyAvLyBpbml0aWFsaXplcyBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xuXG4gICAgaWYodjIgJiBJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIHZhciBjbGlja19ldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGV2ZW50XG4gICAgICAgIGNsaWNrX2V2LmluaXRFdmVudChcImNsaWNrXCIsIHRydWUgLyogYnViYmxlICovLCB0cnVlIC8qIGNhbmNlbGFibGUgKi8pO1xuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBldmVudFxuICAgICAgICBsZXQgY2xpY2tJRCA9IFwiZHZBcmNcIitmaW5kTm9kZUluZGV4KG15dGFyZ2V0KTtcbiAgICAgICAgYnlJZChjbGlja0lEKS5kaXNwYXRjaEV2ZW50KGNsaWNrX2V2KTtcbiAgICB9XG59XG5cblxuXG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIGxheW91dCh2LCB2Mikge1xuICAgIHZhciBteVZhbHVlcyA9IFtdO1xuICAgIG5vZGVzID0gW107XG4gICAgbGlua3MgPSBbXTtcblxuICAgIHN2Zy5hcHBlbmQoXCJzdmc6ZGVmc1wiKS5hcHBlbmQoXCJzdmc6bWFya2VyXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJncm91cDEtYXJyb3dcIilcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxNSAxNScpXG4gICAgICAgIC5hdHRyKFwicmVmWFwiLCAyLjUpXG4gICAgICAgIC5hdHRyKFwicmVmWVwiLCAwKVxuICAgICAgICAuYXR0cihcIm1hcmtlcldpZHRoXCIsIDMpXG4gICAgICAgIC5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDMpXG4gICAgICAgIC5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKVxuICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMi1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcik7XG5cbiAgICB2YXIgbGluZSA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMS1hcnJvdylcIik7XG5cbiAgICB2YXIgbGluZTIgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgNSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNncm91cDItYXJyb3cpXCIpOztcblxuICAgIHZhciB2aXNiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXNiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIikgLy8gbm90ZSBsaW5lcywgYXJlIGJlaGluZCBncm91cCBodWxscyBvZiB3aGljaCB0aGVyZSBpcyBhIHdoaXRlIGFuZCBjb2xvcmVkIHNlbWkgdHJhbnNwYXJlbnQgbGF5ZXJcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB2YXIgdmlzMmJhY2tncm91bmQgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczJiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB2YXIgdmlzID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXMuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsICdncjFodWxsJylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuXG4gICAgdmFyIHZpczIgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczIuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqUkFESVVTKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XG5cbiAgICBpZiAodiA9PSBsYXlvdXRBZGQgfHwgdiA9PSBsYXlvdXRNb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaWldKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHpwYXJhbXMuenZhcnNbal0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgIHNlbGVjdE1lID0gXCIjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAoKSA9PiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56ZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBteXNyYyA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVswXSk7XG4gICAgICAgICAgICB2YXIgbXl0Z3QgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMV0pO1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1tteXNyY10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1tteXRndF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYoSVNfRDNNX0RPTUFJTikge1xuICAgICAgICAgICAgLy9ub2RlcyA9IFtmaW5kTm9kZShteXRhcmdldCldOyAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGRlcGVuZGVudCB2YXJpYWJsZSBvbiBzdGFydHVwXG4gICAgICAgICAgICBub2RlcyA9IGFsbE5vZGVzLnNsaWNlKDEsYWxsTm9kZXMubGVuZ3RoKTsgICAgLy8gQWRkIGFsbCBidXQgZmlyc3QgdmFyaWFibGUgb24gc3RhcnR1cCAoYXNzdW1lcyAwIHBvc2l0aW9uIGlzIGQzbSBpbmRleCB2YXJpYWJsZSlcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChub2Rlc1tqXS5uYW1lICE9IG15dGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2pdLmdyb3VwMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5wdXNoKG5vZGVzW2pdLm5hbWUpOyAgLy8gd3JpdGUgYWxsIG5hbWVzIChleGNlcHQgZDNtIGluZGV4IGFuZCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlKSB0byB6Z3JvdXAxIGFycmF5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdLCBhbGxOb2Rlc1syXV07XG4gICAgICAgICAgICBsaW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzJdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXV07XG4gICAgICAgICAgICBsaW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiVGhlcmUgYXJlIHplcm8gdmFyaWFibGVzIGluIHRoZSBtZXRhZGF0YS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYW5lbFBsb3RzKCk7IC8vIGFmdGVyIG5vZGVzIGlzIHBvcHVsYXRlZCwgYWRkIHN1YnNldCBhbmQgKGlmICFJU19EM01fRE9NQUlOKSBzZXR4IHBhbmVsc1xuXG4gICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgICAgLm5vZGVzKG5vZGVzKVxuICAgICAgICAubGlua3MobGlua3MpXG4gICAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgICAgLmxpbmtEaXN0YW5jZSgxNTApXG4gICAgICAgIC5jaGFyZ2UoLTgwMClcbiAgICAgICAgLm9uKCd0aWNrJywgdGljayk7XG5cbiAgICAvLyBkZWZpbmUgYXJyb3cgbWFya2VycyBmb3IgZ3JhcGggbGlua3NcbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdlbmQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA2KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJyk7XG5cbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdGFydC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDQpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00xMCwtNUwwLDBMMTAsNScpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJyk7XG5cbiAgICAvLyBsaW5lIGRpc3BsYXllZCB3aGVuIGRyYWdnaW5nIG5ldyBub2Rlc1xuICAgIHZhciBkcmFnX2xpbmUgPSBzdmcuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rIGRyYWdsaW5lIGhpZGRlbicpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLDBMMCwwJyk7XG5cbiAgICAvLyBoYW5kbGVzIHRvIGxpbmsgYW5kIG5vZGUgZWxlbWVudCBncm91cHNcbiAgICB2YXIgcGF0aCA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdwYXRoJyksXG4gICAgICAgIGNpcmNsZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdnJyk7XG4gICAgICAgIC8vbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdsaW5lJyk7XG5cbiAgICAvLyBtb3VzZSBldmVudCB2YXJzXG4gICAgdmFyIHNlbGVjdGVkX25vZGUgPSBudWxsLFxuICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGwsXG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiByZXNldE1vdXNlVmFycygpIHtcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGZvcmNlIGxheW91dCAoY2FsbGVkIGF1dG9tYXRpY2FsbHkgZWFjaCBpdGVyYXRpb24pXG4gICAgZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgZnVuY3Rpb24gZmluZGNvb3JkcyhmaW5kbmFtZXMsYWxsbmFtZXMsY29vcmRzLGxlbmd0aGVuKXtcbiAgICAgICAgICAgIHZhciBmY29vcmRzID0gbmV3IEFycmF5KGZpbmRuYW1lcy5sZW5ndGgpOyAgIC8vIGZvdW5kIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2YXIgYWRkbG9jYXRpb24gPSAwO1xuICAgICAgICAgICAgaWYoZmluZG5hbWVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbmRuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBhZGRsb2NhdGlvbiA9IGFsbG5hbWVzLmluZGV4T2YoZmluZG5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkc1tqXSA9IGNvb3Jkc1thZGRsb2NhdGlvbl07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKGxlbmd0aGVuKXtcbiAgICAgICAgICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBmY29vcmRzWzBdWzBdLSBmY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gZmNvb3Jkc1swXVsxXS0gZmNvb3Jkc1sxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFsoZmNvb3Jkc1swXVswXSArIGZjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChmY29vcmRzWzBdWzFdKyBmY29vcmRzWzFdWzFdKS8yICsgZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbKGZjb29yZHNbMF1bMF0gKyBmY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoZmNvb3Jkc1swXVsxXSsgZmNvb3Jkc1sxXVsxXSkvMiAtIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFJBRElVUyAqIDAuMjtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdICsgZGVsdGEsIGZjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdIC0gZGVsdGEsIGZjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdLCBmY29vcmRzWzBdWzFdICsgZGVsdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdLCBmY29vcmRzWzBdWzFdIC0gZGVsdGFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGZjb29yZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGQzLmdlb20uaHVsbCByZXR1cm5zIG51bGwgZm9yIHR3byBwb2ludHMsIGFuZCBmYWlscyBpZiB0aHJlZSBwb2ludHMgYXJlIGluIGEgbGluZSxcbiAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgZnVuY3Rpb24gbGVuZ3RoZW5jb29yZHMoY29vcmRzKXtcbiAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID09IDIpe1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBjb29yZHNbMF1bMF0tIGNvb3Jkc1sxXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gY29vcmRzWzBdWzFdLSBjb29yZHNbMV1bMV07XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goWyhjb29yZHNbMF1bMF0gKyBjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChjb29yZHNbMF1bMV0rIGNvb3Jkc1sxXVsxXSkvMiArIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFsoY29vcmRzWzBdWzBdICsgY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoY29vcmRzWzBdWzFdKyBjb29yZHNbMV1bMV0pLzIgLSBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFJBRElVUyAqIDAuMjtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdICsgZGVsdGEsIGNvb3Jkc1swXVsxXV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0gLSBkZWx0YSwgY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSwgY29vcmRzWzBdWzFdICsgZGVsdGFdKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0gLSBkZWx0YV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChjb29yZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBub2Rlcy5tYXAoZnVuY3Rpb24oZCkgeyAgcmV0dXJuIFsgZC54LCBkLnldOyB9KTtcbiAgICAgICAgdmFyIGdyMWNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56Z3JvdXAxLCB6cGFyYW1zLnp2YXJzLCBjb29yZHMsIHRydWUpO1xuICAgICAgICB2YXIgZ3IyY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpncm91cDIsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIHZhciBkZXBjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemR2LCB6cGFyYW1zLnp2YXJzLCBjb29yZHMsIGZhbHNlKTtcblxuICAgICAgICAvLyBkcmF3IGNvbnZleCBodWxsIGFyb3VuZCBpbmRlcGVuZGVudCB2YXJpYWJsZXMsIGlmIHRocmVlIG9yIG1vcmUgY29vcmRpbmF0ZXMgZ2l2ZW5cbiAgICAgICAgLy8gbm90ZSwgZDMuZ2VvbS5odWxsIHJldHVybnMgbnVsbCBpZiBzaG9ydGVyIGNvb3JkaW5hdGUgc2V0IHRoYW4gMyxcbiAgICAgICAgLy8gc28gZmluZGNvb3JkcygpIGZ1bmN0aW9uIGhhcyBvcHRpb24gdG8gbGVuZ3RoZW4gdGhlIGNvb3JkaW5hdGVzIHJldHVybmVkIHRvIGJ5cGFzcyB0aGlzXG4gICAgICAgIGlmKGdyMWNvb3Jkcy5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgIGxpbmUuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdmlzYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMyk7XG4gICAgICAgICAgICB2YXIgbXlodWxsID0gZDMuZ2VvbS5odWxsKGdyMWNvb3Jkcyk7XG5cbiAgICAgICAgICAgIHZpcy5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcblxuICAgICAgICAgICAgLy92YXIgcCA9IGQzLmdlb20ucG9seWdvbihpbmRjb29yZHMpLmNlbnRyb2lkKCk7ICAvLyBTZWVtcyB0byBnbyBzdHJhbmdlIHNvbWV0aW1lc1xuICAgICAgICAgICAgdmFyIHAgPSBqYW1lc2NlbnRyb2lkKGdyMWNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmKGRlcGNvb3Jkcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSBkZXBjb29yZHNbMF07ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUsIG9ubHkgdXNpbmcgZmlyc3QgZGVwIHZhciBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAvL3ZhciByID0gZmluZGJvdW5kYXJ5KHAscSxncjFjb29yZHMpOyAgICAgICAgLy8gQW4gYXBwcm9hY2ggdG8gZmluZCB0aGUgZXhhY3QgYm91bmRhcnksIG5vdCBwcmVzZW50bHkgd29ya2luZ1xuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcVswXSAtIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBxWzFdIC0gcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxzb3VyY2VQYWRkaW5nID0gUkFESVVTICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBSQURJVVMgKyAxMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKFwieDFcIiwgcFswXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWCkpICAgLy8gb3IgclswXSBpZiBmaW5kYm91bmRhcnkgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSkgICAvLyBvciByWzFdIGlmIGZpbmRib3VuZGFyeSB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHFbMF0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgcVsxXS0gKGx0YXJnZXRQYWRkaW5nICogbG5vcm1ZKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBncm91cCBtZW1iZXJzIGF0dHJhY3QgZWFjaCBvdGhlciwgcmVwdWxzZSBub24tZ3JvdXAgbWVtYmVyc1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IChuLmdyb3VwMSkgPyAxIDogLTE7ICAgIC8vd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKTtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAgICAgdmlzLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbi8vICAgICAgICAgICAgdmlzLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIGxpbmUuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGdyMmNvb3Jkcy5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgIGxpbmUyLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMyk7XG4gICAgICAgICAgICB2YXIgbXlodWxsID0gZDMuZ2VvbS5odWxsKGdyMmNvb3Jkcyk7XG4gICAgICAgICAgICB2aXMyLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcblxuICAgICAgICAgICAgLy92YXIgcCA9IGQzLmdlb20ucG9seWdvbihpbmRjb29yZHMpLmNlbnRyb2lkKCk7ICAvLyBTZWVtcyB0byBnbyBzdHJhbmdlIHNvbWV0aW1lc1xuICAgICAgICAgICAgdmFyIHAgPSBqYW1lc2NlbnRyb2lkKGdyMmNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmKGRlcGNvb3Jkcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSBkZXBjb29yZHNbMF07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlLCBvbmx5IHVzaW5nIGZpcnN0IGRlcCB2YXIgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBxWzBdIC0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHFbMV0gLSBwWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0LFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxzb3VyY2VQYWRkaW5nID0gUkFESVVTICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBSQURJVVMgKyAxMDtcblxuICAgICAgICAgICAgICAgIGxpbmUyLmF0dHIoXCJ4MVwiLCBwWzBdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDIpID8gMSA6IC0xOyAgLy8gd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgbGluZTIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBkLnRhcmdldC54IC0gZC5zb3VyY2UueCxcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBkLnRhcmdldC55IC0gZC5zb3VyY2UueSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICAgICAgbm9ybVggPSBkZWx0YVggLyBkaXN0LFxuICAgICAgICAgICAgICAgIG5vcm1ZID0gZGVsdGFZIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gUkFESVVTICsgNSA6IFJBRElVUyxcbiAgICAgICAgICAgICAgICB0YXJnZXRQYWRkaW5nID0gZC5yaWdodCA/IFJBRElVUyArIDUgOiBSQURJVVMsXG4gICAgICAgICAgICAgICAgc291cmNlWCA9IGQuc291cmNlLnggKyAoc291cmNlUGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VZID0gZC5zb3VyY2UueSArIChzb3VyY2VQYWRkaW5nICogbm9ybVkpLFxuICAgICAgICAgICAgICAgIHRhcmdldFggPSBkLnRhcmdldC54IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IGQudGFyZ2V0LnkgLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1ZKTtcbiAgICAgICAgICAgIHJldHVybiBgTSR7c291cmNlWH0sJHtzb3VyY2VZfUwke3RhcmdldFh9LCR7dGFyZ2V0WX1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaXJjbGUuYXR0cigndHJhbnNmb3JtJywgZCA9PiAndHJhbnNsYXRlKCcgKyBkLnggKyAnLCcgKyBkLnkgKyAnKScpO1xuXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpICAgICAgICAgICAvLyBTaHJpbmsvZXhwYW5kIHBlYmJsZXMgdGhhdCBqb2luL2xlYXZlIGdyb3Vwc1xuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpO1xuXG4gICAgfVxuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpIC8vIG1vZGVscyB0YWJcbiAgICAgICAgLy8gIGQzLnNlbGVjdChcIiNEaXNwbGF5X2NvbnRlbnRcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgdmFyQ29sb3IpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bW9kZWwgPSBkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjdHlwZXNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgLy8gIGQzLnNlbGVjdChcIiNEaXNwbGF5X2NvbnRlbnRcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdHlwZXNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlID0gdGhpcy5pbm5lckhUTUwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIHNldFByb2JsZW1EZWZpbml0aW9uKFwidGFza1R5cGVcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21UYXNrVHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3N1YnR5cGVzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjc3VidHlwZXNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gdGhpcy5pbm5lckhUTUwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIHNldFByb2JsZW1EZWZpbml0aW9uKFwidGFza1N1YnR5cGVcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21UYXNrU3VidHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWMgPSBbXCJcIixcIlwiXTtcbiAgICAgICAgICAgIC8vIHRoaXMuY2xhc3NOYW1lPVwiaXRlbS1kZWZhdWx0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbWV0cmljc1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24ubWV0cmljID0gdGhpcy5pbm5lckhUTUwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIHNldFByb2JsZW1EZWZpbml0aW9uKFwibWV0cmljXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtTWV0cmljcyk7XG4gICAgICAgIH0pO1xuXG4gIC8qICBkMy5zZWxlY3QoXCIjb3V0cHV0c1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI291dHB1dHNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgc2V0UHJvYmxlbURlZmluaXRpb24oXCJvdXRwdXRUeXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtT3V0cHV0VHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAqL1xuXG4gICAgLy8gdXBkYXRlIGdyYXBoIChjYWxsZWQgd2hlbiBuZWVkZWQpXG4gICAgcmVzdGFydCA9IGZ1bmN0aW9uKCRsaW5rcywgaXNfZXhwbG9yZSkge1xuICAgICAgICBsaW5rcyA9ICRsaW5rcyB8fCBsaW5rcztcbiAgICAgICAgLy8gbm9kZXMuaWQgaXMgcGVnZ2VkIHRvIGFsbE5vZGVzLCBpLmUuIHRoZSBvcmRlciBpbiB3aGljaCB2YXJpYWJsZXMgYXJlIHJlYWQgaW5cbiAgICAgICAgLy8gbm9kZXMuaW5kZXggaXMgZmxvYXRpbmcgYW5kIGRlcGVuZHMgb24gdXBkYXRlcyB0byBub2Rlcy4gIGEgdmFyaWFibGVzIGluZGV4IGNoYW5nZXMgd2hlbiBuZXcgdmFyaWFibGVzIGFyZSBhZGRlZC5cbiAgICAgICAgY2lyY2xlLmNhbGwoZm9yY2UuZHJhZyk7XG4gICAgICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwLjEpO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKGQgPT4gc2V0UGViYmxlQ2hhcmdlKGQpKTtcbiAgICAgICAgICAgIGZvcmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMSk7XG4gICAgICAgICAgICBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxuICAgICAgICAgICAgaWYgKCh6cGFyYW1zLnpncm91cDEubGVuZ3RoID4gMCkgJiAoenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgKSkgeyAvLyBzY2FsZSBkb3duIGJ5IG51bWJlciBvZiBhY3RpdmUgZ3JvdXBzXG4gICAgICAgICAgICAgICAgayA9IDIuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMCk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMCk7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZS5yZXN1bWUoKTtcblxuICAgICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgbGlua3NcbiAgICAgICAgLy8gVkpEOiBkYXNoZWQgbGlua3MgYmV0d2VlbiBwZWJibGVzIGFyZSBcInNlbGVjdGVkXCIuIHRoaXMgaXMgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+ICFpc19leHBsb3JlICYmIHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4gIWlzX2V4cGxvcmUgJiYgeC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbGlua3NcbiAgICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+ICFpc19leHBsb3JlICYmIHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4gIWlzX2V4cGxvcmUgJiYgeC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBKU09OLnN0cmluZ2lmeShsaW5rc1tqXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWwobGlua3MsIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgICBjaXJjbGUgPSBjaXJjbGUuZGF0YShub2RlcywgeCA9PiB4LmlkKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgeCA9PiB4LnJlZmxleGl2ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHggPT4gZDMucmdiKHguc3Ryb2tlQ29sb3IpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB4ID0+IHguc3Ryb2tlV2lkdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgbGV0IGcgPSBjaXJjbGUuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgICAgICAvLyBhZGQgcGxvdFxuICAgICAgICBnLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkLCB0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT0gJ2JhcicpIGJhcnNOb2RlKGQsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZC5ncm91cDEgPSBkLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZUZXh0JykpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoJyNkdkFyYycpKVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ25vbUFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKFwibm9tVGV4dFwiKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZChcIiNub21BcmNcIikpXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3JBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAgZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMmluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgLy9kLmdyb3VwMSA9ICFkLmdyb3VwMTsgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGVhc2llciwgYnV0IGN1cnJlbnRseSBzZXQgaW4gc2V0Q29sb3JzKClcbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IxaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IyaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAyID0gIWQuZ3JvdXAyOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjJDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnclRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2dyQXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkdyb3Vwc1wiKTtcblxuICAgICAgICBnLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkMy5yZ2IoZC5zdHJva2VDb2xvcikudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgY2xpY2sgb24gbm9kZVxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSA/IG51bGwgOiBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb24gZHJhZyBsaW5lXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICd1cmwoI2VuZC1hcnJvdyknKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSk7XG5cbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gbGlua3MuZmlsdGVyKHggPT4geC5zb3VyY2UgPT0gc291cmNlICYmIHgudGFyZ2V0ID09IHRhcmdldClbMF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IG5ldyBsaW5rXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdyBub2RlIG5hbWVzXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAuYXR0cigneScsIDE1KVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2lkJylcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5uYW1lKTtcblxuICAgICAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnQgdGV4dCB3cmFwcGluZywgdXNlIGh0bWwgaW5zdGVhZFxuICAgICAgICBnLnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdGFiTGVmdCgndGFiMycpO1xuICAgICAgICAgICAgICAgIHZhclN1bW1hcnkoZCk7XG4gICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgYnlJZCgndHJhbnNmb3JtYXRpb25zJykuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OmJsb2NrJyk7XG4gICAgICAgICAgICAgICAgYnlJZChcInRyYW5zU2VsXCIpLnNlbGVjdGVkSW5kZXggPSBkLmlkO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhciA9IHZhbHVlS2V5W2QuaWRdO1xuXG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2QXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJkdlRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnclRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMWluZGljYXRvclRleHRcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMmluZGljYXRvclRleHRcIiwgLjEsIDAsIDEwMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJjc1RleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVUZXh0XCIsIC41LCAwLCAxMDApO1xuXG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5SG9sZCB8fCB0YWJMZWZ0KHN1YnNldCA/ICd0YWIyJyA6ICd0YWIxJyk7XG4gICAgICAgICAgICAgICAgJ2NzQXJjIGNzVGV4dCB0aW1lQXJjIHRpbWVUZXh0IGR2QXJjIGR2VGV4dCBub21BcmMgbm9tVGV4dCBnckFyYyBnclRleHQnLnNwbGl0KCcgJykubWFwKHggPT4gZmlsbChkLCB4LCAwLCAxMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gdmFyaWFibGUgbGlzdCBpcyBzaWxlbnRseSB1cGRhdGVkIGFzIHBlYmJsZXMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAuZGF0YShub2Rlcy5tYXAoeCA9PiB4Lm5hbWUpKSAvLyBzZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAgICAgaWYoIUlTX0QzTV9ET01BSU4pe1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsIGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgJ2ludGVyYWN0aW9uJyBpcyB0aGUgc2VsZWN0ZWQgZnVuY3Rpb24sIGRvbid0IHNob3cgdGhlIGZ1bmN0aW9uIGxpc3QgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ZXJhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbChuKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2UobiA9IG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcblxuICAgICAgICAvLyBzYXZlIHdvcmtzcGFjZXNcbiAgICAgICAgY29uc29sZS5sb2coJ29rIHdzJyk7XG4gICAgICAgIHJlY29yZF91c2VyX21ldGFkYXRhKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICBpZiAoZDMuZXZlbnQuY3RybEtleSB8fCBtb3VzZWRvd25fbm9kZSB8fCBtb3VzZWRvd25fbGluaykgcmV0dXJuO1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGQpIHtcbiAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gdXBkYXRlIGRyYWcgbGluZVxuICAgICAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cChkKSB7XG4gICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIHN2Zy5hdHRyKCdpZCcsICgpID0+IFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHttb3VzZWRvd24odGhpcyk7fSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7bW91c2V1cCh0aGlzKTt9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcblxuICAgIHJlc3RhcnQoKTsgLy8gaW5pdGlhbGl6ZXMgZm9yY2UubGF5b3V0KClcbiAgICBmYWtlQ2xpY2soKTtcblxuICAgIGlmKHYyICYgSVNfRDNNX0RPTUFJTikge1xuICAgICAgICB2YXIgY2xpY2tfZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBldmVudFxuICAgICAgICBjbGlja19ldi5pbml0RXZlbnQoXCJjbGlja1wiLCB0cnVlIC8qIGJ1YmJsZSAqLywgdHJ1ZSAvKiBjYW5jZWxhYmxlICovKTtcbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnRcbiAgICAgICAgbGV0IGNsaWNrSUQgPSBcImR2QXJjXCIrZmluZE5vZGVJbmRleChteXRhcmdldCk7XG4gICAgICAgIGJ5SWQoY2xpY2tJRCkuZGlzcGF0Y2hFdmVudChjbGlja19ldik7XG4gICAgfVxufVxuXG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIGZpbmQoJG5vZGVzLCBuYW1lKSB7XG4gICAgZm9yIChsZXQgaSBpbiAkbm9kZXMpXG4gICAgICAgIGlmICgkbm9kZXNbaV0ubmFtZSA9PSBuYW1lKSByZXR1cm4gJG5vZGVzW2ldLmlkO1xufVxuXG4vKipcbiAgIHJldHVybnMgaWRcbiovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVJbmRleChuYW1lLCB3aG9sZSkge1xuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IG5hbWUpIHJldHVybiB3aG9sZSA/IG5vZGUgOiBub2RlLmlkO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBub2RlSW5kZXgobm9kZU5hbWUpIHtcbiAgICBmb3IgKGxldCBpIGluIG5vZGVzKVxuICAgICAgICBpZiAobm9kZXNbaV0ubmFtZSA9PT0gbm9kZU5hbWUpIHJldHVybiBpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGUobmFtZSkge1xuICAgIGZvciAobGV0IG4gb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChuLm5hbWUgPT09IG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gbjtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdXBkYXRlTm9kZShpZCkge1xuICAgIGxldCBub2RlID0gZmluZE5vZGUoaWQpO1xuICAgIGlmIChub2RlLmdyYXlvdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGxldCBuYW1lcyA9ICgpID0+IG5vZGVzLm1hcChuID0+IG4ubmFtZSk7XG4gICAgaWYgKG5hbWVzKCkuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgZGVsKG5vZGVzLCBub2RlLmluZGV4KTtcbiAgICAgICAgbGlua3NcbiAgICAgICAgICAgIC5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGwgPT4gZGVsKGxpbmtzLCAtMSwgbCkpO1xuICAgICAgICB6cGFyYW1zUmVzZXQobmFtZSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG5vZGUgbmFtZSBmcm9tIGdyb3VwIGxpc3RzXG4gICAgICAgIG5vZGUuZ3JvdXAxICYmIGRlbCh6cGFyYW1zLnpncm91cDEsIC0xLCBuYW1lKTtcbiAgICAgICAgbm9kZS5ncm91cDIgJiYgZGVsKHpwYXJhbXMuemdyb3VwMiwgLTEsIG5hbWUpO1xuICAgICAgICBub2RlLmdyb3VwMSA9IG5vZGUuZ3JvdXAyID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbm9kZSByZXNldCAtIHBlcmhhcHMgdGhpcyB3aWxsIGJlY29tZSBhIGhhcmQgcmVzZXQgYmFjayB0byBhbGwgb3JpZ2luYWwgYWxsTm9kZSB2YWx1ZXM/XG4gICAgICAgIG5vZGUubm9kZUNvbCA9IG5vZGUuYmFzZUNvbDtcbiAgICAgICAgbm9kZS5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICBub2RlLnN0cm9rZVdpZHRoID0gJzEnO1xuXG4gICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgenBhcmFtcy56dmFycyA9IG5hbWVzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICAgZXZlcnkgdGltZSBhIHZhcmlhYmxlIGluIGxlZnRwYW5lbCBpcyBjbGlja2VkLCBub2RlcyB1cGRhdGVzIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNoYW5nZXNcbiovXG5leHBvcnQgZnVuY3Rpb24gY2xpY2tWYXIoZWxlbSkge1xuICAgIGlmICh1cGRhdGVOb2RlKGVsZW0udGFyZ2V0LmlkKSkge1xuICAgICAgICAvLyBwYW5lbFBsb3RzKCk7IGlzIHRoaXMgbmVjZXNzYXJ5P1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAgUmV0cmlldmUgdGhlIHZhcmlhYmxlIGxpc3QgZnJvbSB0aGUgcHJlcHJvY2VzcyBkYXRhLlxuICBUaGlzIGhlbHBzIGhhbmRsZSB0aGUgbmV3IGZvcm1hdCBhbmQgKHRlbXBvcmFyaWx5KVxuICB0aGUgb2xkZXIgZm9ybWF0IGluIFBST0RVQ1RJT04gKHJwIDguMTQuMjAxNylcbiAgXCJuZXdcIiByZXNwb25zZTpcbiAge1xuICBcImRhdGFzZXRcIiA6IHsuLi59XG4gIFwidmFyaWFibGVzXCIgOiB7XG4gIFwidmFyMVwiIDogey4uLn0sXG4gIChldGMpXG4gIH1cbiAgfVxuICBcIm9sZFwiIHJlc3BvbnNlOlxuICB7XG4gIFwidmFyMVwiIDogey4uLn0sXG4gIChldGMpXG4gIH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyaWFibGVEYXRhKGpzb24pIHtcbiAgICByZXR1cm4ganNvbi5oYXNPd25Qcm9wZXJ0eSgndmFyaWFibGVzJykgPyBqc29uLnZhcmlhYmxlcyA6IGpzb247XG59XG5cbi8qKlxuICAgY2FsbGVkIGJ5IGZvcmNlIGJ1dHRvblxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZVN3aXRjaCgpIHtcbiAgICBmb3JjZXRvZ2dsZSA9IFtmb3JjZXRvZ2dsZVswXSA9PSAndHJ1ZScgPyAnZmFsc2UnIDogJ3RydWUnXTtcbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwiZmFsc2VcIikge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWxwbWF0ZXJpYWxzKHR5cGUpIHtcbiAgICBpZih0eXBlPT1cInZpZGVvXCIpe1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oXCJodHRwOi8vMnJhLnZuL2RlbW9zL2QzbWludGVncmF0aW9uZGVtby5tcDRcIiwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKFwiaHR0cDovLzJyYS52bi9wYXBlcnMvdHdvcmF2ZW5zLWQzbWd1aWRlLnBkZlwiLCAnX2JsYW5rJyk7XG4gICAgICAgIHdpbi5mb2N1cygpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyh0eXBlKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2tEZXNjcmlwdGlvbigpIHtcbiAgICBsb2NrdG9nZ2xlID0gbG9ja3RvZ2dsZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICBsZXQgdGVtcDtcbiAgICBsZXQgaTtcbiAgICBpZiAoIWxvY2t0b2dnbGUpIHtcbiAgICAgICAgYnlJZCgnYnRuTG9jaycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICB0ZW1wID0gYnlJZCgncmlnaHRDb250ZW50QXJlYScpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LnJlbW92ZShcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5SWQoJ2J0bkxvY2snKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIHRlbXAgPSBieUlkKCdtZXRyaWNzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0ZW1wKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gYnlJZCgndHlwZXMnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWRlZmF1bHRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGJ5SWQoJ3N1YnR5cGVzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgLyogICAgdGVtcCA9IGJ5SWQoJ291dHB1dHMnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWRlZmF1bHRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH0gICovXG4gICAgICAgIGZha2VDbGljaygpO1xuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpQb3AoKSB7XG4gICAgaWYgKGRhdGF1cmwpIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIHpwYXJhbXMuem1vZGVsY291bnQgPSBtb2RlbENvdW50O1xuICAgIHpwYXJhbXMuemVkZ2VzID0gW107XG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIHpwYXJhbXMuem5hdHVyZSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhcnJheVxuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHpwYXJhbXMuem5hdHVyZS5wdXNoKG5vZGVzW2pdLm5hdHVyZSk7XG4gICAgICAgIGxldCB0ZW1wID0gbm9kZXNbal0uaWQ7XG4gICAgICAgIHpwYXJhbXMuenNldHhbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zZXR4dmFscztcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6ZWRnZXMgYXJyYXlcbiAgICAgICAgLy9jb3JyZWN0IHRoZSBzb3VyY2UgdGFyZ2V0IG9yZGVyaW5nIGZvciBaZWxpZ1xuICAgICAgICBsZXQgc3JjdGd0ID0gbGlua3Nbal0ubGVmdCA9PSBmYWxzZSA/XG4gICAgICAgICAgICBbbGlua3Nbal0uc291cmNlLm5hbWUsIGxpbmtzW2pdLnRhcmdldC5uYW1lXSA6XG4gICAgICAgICAgICBbbGlua3Nbal0udGFyZ2V0Lm5hbWUsIGxpbmtzW2pdLnNvdXJjZS5uYW1lXTtcbiAgICAgICAgenBhcmFtcy56ZWRnZXMucHVzaChzcmN0Z3QpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucywgZGl2aWQpIHtcbiAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoZGl2aWQpLmFwcGVuZCgndGFibGUnKTtcbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoJ3RoZWFkJyk7XG4gICAgdmFyXHR0Ym9keSA9IHRhYmxlLmFwcGVuZCgndGJvZHknKTtcblxuICAgIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RyJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGlmKGk9PTApIHJldHVybiAnaXRlbS1zZWxlY3QnO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gJ2l0ZW0tZGVmYXVsdCc7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGQnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCBteXJvdyA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmKG15cm93LmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdChcInRyLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QobXlyb3cpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmKGRpdmlkPT0nI3NldHhSaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c3Bsb3Rpbml0KGFsbFBpcGVsaW5lSW5mb1tteXJvdy5maXJzdENoaWxkLmlubmVyVGV4dF0sIGR2dmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fSk7XG5cbiAgICAvLyB0aGlzIGlzIGNvZGUgdG8gYWRkIGEgY2hlY2tib3ggdG8gZWFjaCByb3cgb2YgcGlwZWxpbmUgcmVzdWx0cyB0YWJsZVxuICAgIC8qXG4gICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgIC5hdHRyKFwidHlwZVwiLCBcImNoZWNrYm94XCIpXG4gICAgICAuc3R5bGUoXCJmbG9hdFwiLFwicmlnaHRcIik7XG4gICAgKi9cblxuICAgIHJldHVybiB0YWJsZTtcblxufVxuXG5mdW5jdGlvbiBvblBpcGVsaW5lQ3JlYXRlKFBpcGVsaW5lQ3JlYXRlUmVzdWx0KSB7XG4gICAgLy8gcnBjIEdldEV4ZWN1dGVQaXBlbGluZVJlc3VsdHMoUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4gICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuXG4gICAgLy8gY2hhbmdlIHN0YXR1cyBvZiBidXR0b25zIGZvciBlc3RpbWF0aW5nIHByb2JsZW0gYW5kIG1hcmtpbmcgcHJvYmxlbSBhcyBmaW5pc2hlZFxuICAgICQoXCIjYnRuRXN0aW1hdGVcIikucmVtb3ZlQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcbiAgICAkKFwiI2J0bkVzdGltYXRlXCIpLmFkZENsYXNzKFwiYnRuLWRlZmF1bHRcIik7XG4gICAgJChcIiNidG5FbmRTZXNzaW9uXCIpLnJlbW92ZUNsYXNzKFwiYnRuLWRlZmF1bHRcIik7XG4gICAgJChcIiNidG5FbmRTZXNzaW9uXCIpLmFkZENsYXNzKFwiYnRuLXN1Y2Nlc3NcIik7XG5cbiAgICBsZXQgYWxsUGlwZWxpbmVJbmZvID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGk8UGlwZWxpbmVDcmVhdGVSZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZCBpbiBhbGxQaXBlbGluZUluZm8pIHtcbiAgICAgICAgICAgIGFsbFBpcGVsaW5lSW5mb1tQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkXT1PYmplY3QuYXNzaWduKGFsbFBpcGVsaW5lSW5mb1tQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkXSxQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF09UGlwZWxpbmVDcmVhdGVSZXN1bHRbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coYWxsUGlwZWxpbmVJbmZvKTtcbiAgICAvLyB0byBnZXQgYWxsIHBpcGVsaW5lIGlkczogT2JqZWN0LmtleXMoYWxsUGlwZWxpbmVJbmZvKVxuXG4gICAgbGV0IHJlc3VsdHN0YWJsZSA9IFtdO1xuICAgIGZvcih2YXIga2V5IGluIGFsbFBpcGVsaW5lSW5mbykge1xuICAgICAgICAvLyBkb24ndCByZXBvcnQgdGhlIHBpcGVsaW5lIHRvIHVzZXIgaWYgaXQgaGFzIGZhaWxlZFxuICAgICAgICBpZihhbGxQaXBlbGluZUluZm9ba2V5XS5yZXNwb25zZUluZm8uc3RhdHVzLmRldGFpbHMgPT0gXCJQaXBlbGluZSBGYWlsZWRcIikgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBteWlkID0gXCJcIjtcbiAgICAgICAgbGV0IG15bWV0cmljID0gXCJcIjtcbiAgICAgICAgbGV0IG15dmFsID0gXCJcIjtcbiAgICAgICAgY29uc29sZS5sb2coYWxsUGlwZWxpbmVJbmZvKTtcbiAgICAgICAgbGV0IG15c2NvcmVzID0gYWxsUGlwZWxpbmVJbmZvW2tleV0ucGlwZWxpbmVJbmZvLnNjb3JlcztcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG15c2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvL2lmKGk9PTApIHtteWlkPWtleTt9XG4gICAgICAgICAgICAvLyAgIGVsc2UgbXlpZD1cIlwiO1xuICAgICAgICAgICAgbXlpZD1rZXk7XG4gICAgICAgICAgICBteW1ldHJpYz1teXNjb3Jlc1tpXS5tZXRyaWM7XG4gICAgICAgICAgICBteXZhbD0rbXlzY29yZXNbaV0udmFsdWUudG9GaXhlZCgzKTtcbiAgICAgICAgICAgIHJlc3VsdHN0YWJsZS5wdXNoKHtcIlBpcGVsaW5lSURcIjpteWlkLFwiTWV0cmljXCI6bXltZXRyaWMsIFwiU2NvcmVcIjpteXZhbH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIHRoZSB0YWJsZVxuICAgIHRhYnVsYXRlKHJlc3VsdHN0YWJsZSwgWydQaXBlbGluZUlEJywgJ01ldHJpYycsICdTY29yZSddLCAnI3Jlc3VsdHMnKTtcbiAgICB0YWJ1bGF0ZShyZXN1bHRzdGFibGUsIFsnUGlwZWxpbmVJRCcsICdNZXRyaWMnLCAnU2NvcmUnXSwgJyNzZXR4UmlnaHQnKTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB0b2dnbGVSaWdodEJ1dHRvbnMoXCJhbGxcIik7XG4gICAgYnlJZChcImJ0blJlc3VsdHNcIikuY2xpY2soKTtcblxuICAgIC8vIHRoaXMgaW5pdGlhbGl6ZXMgdGhlIG1haW5cbiAgICAvLyB0aGlzIHBpZWNlIGhlcmUgaXMgdGhlIGZpcnN0IHBpcGVsaW5lIHRocm91Z2g6IGFsbFBpcGVsaW5lSW5mb1tyZXN1bHRzdGFibGVbMV0uUGlwZWxpbmVJRF1cbiAgICAvL3Jlc3VsdHNwbG90aW5pdChhbGxQaXBlbGluZUluZm9bcmVzdWx0c3RhYmxlWzFdLlBpcGVsaW5lSURdLCBkdnZhbHVlcyk7XG4gICAgZXhwb3J0cGlwZWxpbmUocmVzdWx0c3RhYmxlWzFdLlBpcGVsaW5lSUQpO1xuXG4gICAgLy8gSSBkb24ndCB0aGluayB3ZSBuZWVkIHRoZXNlIHVudGlsIHdlIGFyZSBoYW5kbGluZyBzdHJlYW1pbmcgcGlwZWxpbmVzXG4gICAgLy8gVGhleSBhcmUgc2V0IHVwIGFuZCBjYWxsZWQsIGJ1dCBkb24ndCBhY3R1YWxseSByZW5kZXIgYW55dGhpbmcgZm9yIHRoZSB1c2VyXG5cbiAgICAvLyB0aGlzIGlzIG91ciBmdW5jdGlvbiBmb3IgdGhlIExpc3RQaXBlbGluZXMgb2YgQVBJXG4gICAgbGlzdHBpcGVsaW5lcygpO1xuXG4gICAgLy9sZXQgcGlwZWxpbmVpZCA9IFBpcGVsaW5lQ3JlYXRlUmVzdWx0LnBpcGVsaW5laWQ7XG4gICAgLy8gZ2V0ZXhlY3V0ZXBpcGVsaW5lcmVzdWx0cyBpcyB0aGUgdGhpcmQgdG8gYmUgY2FsbGVkXG4gICAgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2dldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHMnLCB7Y29udGV4dCwgcGlwZWxpbmVfaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pfSk7XG59XG5mdW5jdGlvbiBDcmVhdGVQaXBlbGluZURhdGEocHJlZGljdG9ycywgZGVwdmFyKSB7XG4gICAgbGV0IGNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgbGV0IHVyaUNzdiA9IHpwYXJhbXMuemQzbWRhdGE7XG4gICAgbGV0IHVyaUpzb24gPSB1cmlDc3Yuc3Vic3RyaW5nKDAsIHVyaUNzdi5sYXN0SW5kZXhPZihcIi90YWJsZXNcIikpICsgXCIvZGF0YXNldERvYy5qc29uXCI7XG4gICAgbGV0IHRhcmdldEZlYXR1cmVzID0gW3sgJ3Jlc291cmNlX2lkJzogXCIwXCIsICdmZWF0dXJlX25hbWUnOiBkZXB2YXJbMF0gfV07XG4gICAgbGV0IHByZWRpY3RGZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZGljdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVkaWN0RmVhdHVyZXNbaV0gPSB7ICdyZXNvdXJjZV9pZCc6IFwiMFwiLCAnZmVhdHVyZV9uYW1lJzogcHJlZGljdG9yc1tpXSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkYXRhc2V0X3VyaTogdXJpSnNvbiwgICAvLyB1cmlDc3YgaXMgYWxzbyB2YWxpZCwgYnV0IG5vdCBjdXJyZW50bHkgYWNjZXB0ZWQgYnkgSVNJIFRBMlxuICAgICAgICB0YXNrOiBkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdLFxuICAgICAgICB0YXNrU3VidHlwZTogZDNtVGFza1N1YnR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlXVsxXSxcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9uOiBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9uLFxuICAgICAgICBvdXRwdXQ6IFwiT1VUUFVUX1RZUEVfVU5ERUZJTkVEXCIsICAvLyB2YWxpZCB2YWx1ZXMgd2lsbCBjb21lIGluIGZ1dHVyZSBBUElcbiAgICAgICAgbWV0cmljczogW2QzbU1ldHJpY3NbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpY11bMV1dLFxuICAgICAgICB0YXJnZXRGZWF0dXJlcyxcbiAgICAgICAgLyogRXhhbXBsZTpcbiAgICAgICAgICBcInRhcmdldEZlYXR1cmVzXCI6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwicmVzb3VyY2VfaWRcIjogXCIwXCIsXG4gICAgICAgICAgICAgIFwiZmVhdHVyZV9uYW1lXCI6IFwiQXRfYmF0c1wiXG4gICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICovXG4gICAgICAgIHByZWRpY3RGZWF0dXJlcyxcbiAgICAgICAgLyogRXhhbXBsZTpcbiAgICAgICAgICBcInByZWRpY3RSZWF0dXJlc1wiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJyZXNvdXJjZV9pZFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwiZmVhdHVyZV9uYW1lXCI6IFwiUkJJc1wiXG4gICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICovXG4gICAgICAgIG1heFBpcGVsaW5lczogNSAvL3VzZXIgdG8gc3BlY2lmeSB0aGlzIGV2ZW50dWFsbHk/XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkSW5jb21wbGV0ZSgpIHtcbiAgICBpZiAoUFJPRFVDVElPTiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQgPT09ICcnKSB7XG4gICAgICAgIGFsZXJ0KCdXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICAgIGNhbGxlZCBieSBjbGlja2luZyAnU29sdmUgVGhpcyBQcm9ibGVtJyBpbiBtb2RlbCBtb2RlXG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVzdGltYXRlKGJ0bikge1xuICAgIGlmICghSVNfRDNNX0RPTUFJTil7XG4gICAgICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgelBvcCgpO1xuICAgICAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgICAgIC8vIHBhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgICAgICB6cGFyYW1zLmFsbFZhcnMgPSB2YWx1ZUtleS5zbGljZSgxMCwgMjUpOyAvLyBiZWNhdXNlIHRoZSBVUkwgaXMgdG9vIGxvbmcuLi5cblxuICAgICAgICAvKiBVTlVTRURcbiAgICAgICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IFJPT0tfU1ZDX1VSTCArIFwic2VsZWN0b3JhcHBcIjtcbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0b3JTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpY2tlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgICAgICBjZGIoXCJzZWxlY3RvclN1Y2Nlc3M6IFwiLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWxlY3RvckZhaWwoYnRuKSB7XG4gICAgICAgICAgICBhbGVydChcIlNlbGVjdG9yIEZhaWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgbGV0IGpzb24gPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnemVsaWdhcHAnLCB6cGFyYW1zKTtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuICAgICAgICAgICAgaWYgKCFlc3RpbWF0ZWQpIGJ5SWQoXCJyZXN1bHRzXCIpLnJlbW92ZUNoaWxkKGJ5SWQoXCJyZXN1bHRzSG9sZGVyXCIpKTtcblxuICAgICAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cblxuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGNsaWNrIG9uIFJlc3VsdHMgYnV0dG9uXG4gICAgICAgICAgICAkKFwiI2J0blJlc3VsdHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgICAgICAgICBsZXQgbW9kZWwgPSBcIk1vZGVsXCIuY29uY2F0KG1vZGVsQ291bnQgPSBtb2RlbENvdW50ICsgMSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vZENvbCgpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYSh2YXJDb2xvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kQ29sKCk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuaW5zZXJ0KFwicFwiLCBcIjpmaXJzdC1jaGlsZFwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIG1vZGVsKVxuICAgICAgICAgICAgICAgIC50ZXh0KG1vZGVsKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLnN1YnN0cigwLCAxNykgPT0gYi5zdWJzdHIoMCwgMTcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlc2NhcGUgZnVuY3Rpb24gaWYgZGlzcGxheWVkIG1vZGVsIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgbW9kQ29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHZpeih0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IHJDYWxsID0gW2pzb24uY2FsbF07XG4gICAgICAgICAgICBzaG93TG9nKCdlc3RpbWF0ZScsIHJDYWxsKTtcblxuICAgICAgICAgICAgdml6KG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3dhbmRpdmUpIHsgLy8gSVNfRDNNX0RPTUFJTiBhbmQgc3dhbmRpdmUgaXMgdHJ1ZVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcblxuICAgICAgICBsZXQgbXl2a2kgPSB2YWx1ZUtleS5pbmRleE9mKG15dGFyZ2V0KTtcbiAgICAgICAgaWYobXl2a2kgIT0gLTEpIHtcbiAgICAgICAgICAgIGRlbCh2YWx1ZUtleSwgbXl2a2kpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvQ3JlYXRlUGlwZWxpbmVzJywgQ3JlYXRlUGlwZWxpbmVEYXRhKHZhbHVlS2V5LCBteXRhcmdldCkpO1xuICAgICAgICByZXMgJiYgb25QaXBlbGluZUNyZWF0ZShyZXMpO1xuICAgIH0gZWxzZSB7IC8vIHdlIGFyZSBpbiBJU19EM01fRE9NQUlOIG5vIHN3YW5kaXZlXG4gICAgICAgIC8vIHJwYyBDcmVhdGVQaXBlbGluZXMoUGlwZWxpbmVDcmVhdGVSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0gUGlwZWxpbmVDcmVhdGVSZXN1bHQpIHt9XG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuXG4gICAgICAgIC8vIHBpcGVsaW5lYXBwIGlzIGEgcm9vayBhcHBsaWNhdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSwgdGhlIERWIHZhbHVlcywgYW5kIHRoZSBwcmVkaWN0b3JzLiBjYW4gdGhpbmsgb2YgaXQgd2FzIGEgd2F5IHRvIHRyYW5zbGF0ZSB0aGUgcG90ZW50aWFsbHkgY29tcGxleCBncmFtbWFyIGZyb20gdGhlIFVJXG5cbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAncGlwZWxpbmVhcHAnLCB6cGFyYW1zKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgICBzZXR4VGFibGUocmVzLnByZWRpY3RvcnMpO1xuICAgICAgICAgICAgbGV0IGR2dmFsdWVzID0gcmVzLmR2dmFsdWVzO1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NyZWF0ZVBpcGVsaW5lcycsIENyZWF0ZVBpcGVsaW5lRGF0YShyZXMucHJlZGljdG9ycywgcmVzLmRlcHZhcikpO1xuICAgICAgICAgLy8gICByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnY3JlYXRlcGlwZWxpbmUnLCB6cGFyYW1zKTtcbiAgICAgICAgICAgIHJlcyAmJiBvblBpcGVsaW5lQ3JlYXRlKHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiB0YTJzdHVmZigpIHtcbiAgICBjb25zb2xlLmxvZyhkM21Qcm9ibGVtRGVzY3JpcHRpb24pO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5hc3luYyBmdW5jdGlvbiBkYXRhRG93bmxvYWQoKSB7XG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcblxuICAgIC8vIHBhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnZGF0YWFwcCcsIHpwYXJhbXMpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB6cGFyYW1zLnpzZXNzaW9uaWQgPSByZXMuc2Vzc2lvbmlkWzBdO1xuICAgIC8vIHNldCBsaW5rIFVSTFxuICAgIGJ5SWQoXCJsb2dJRFwiKS5ocmVmID0gYCR7UFJPRFVDVElPTiA/IFJPT0tfU1ZDX1VSTCArICdsb2dfZGlyL2xvZ18nIDogJ3Jvb2svbG9nXycgfSR7enBhcmFtcy56c2Vzc2lvbmlkfS50eHRgO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB2aXoobXltKSB7XG4gICAgbXltID0gK215bS5zdWJzdHIoNSwgNSkgLSAxO1xuXG4gICAgbGV0IHJlbW92ZUtpZHMgPSBwYXJlbnQgPT4ge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIH07XG4gICAgcmVtb3ZlS2lkcyhieUlkKFwicmVzdWx0c1ZpZXdcIikpO1xuXG4gICAgbGV0IGpzb24gPSBhbGxSZXN1bHRzW215bV07XG5cbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLmltYWdlcykge1xuICAgICAgICB2YXIgemZpZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIGpzb24uaW1hZ2VzW2ldKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMjAwKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDIwMCk7XG4gICAgICAgIGJ5SWQoXCJyZXN1bHRzVmlld1wiKS5hcHBlbmRDaGlsZCh6ZmlnKTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgcmVzdWx0cyB0YWJsZVxuICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdW1JbmZvKSB7XG4gICAgICAgIGlmIChrZXkgPT0gJ2NvbG5hbWVzJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChqc29uLnN1bUluZm9ba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKTtcblxuICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpO1xuICAgIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0aFwiKVxuICAgICAgICAuZGF0YShqc29uLnN1bUluZm8uY29sbmFtZXMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgdmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG4gICAgdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEocmVzdWx0c0FycmF5KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgLmRhdGEoZCA9PiBkKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgbXlOdW0gPSBOdW1iZXIoZCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obXlOdW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgcmV0dXJuIG15TnVtLnRvUHJlY2lzaW9uKDMpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYWxpY2VibHVlXCIpO1xuICAgICAgICB9KSAvLyBmb3Igbm8gZGlzY2VybmFibGUgcmVhc29uXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIik7XG4gICAgICAgIH0pOyAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuXG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5odG1sKCgpID0+IFwiPGI+Rm9ybXVsYTogPC9iPlwiLmNvbmNhdChqc29uLmNhbGxbMF0pKTtcblxuICAgIG0ucmVkcmF3KCk7XG59XG5cbi8qKlxuICAgcGFyc2VzIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbnB1dC5cbiAgIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuKi9cbmZ1bmN0aW9uIHRyYW5zUGFyc2Uobikge1xuICAgIHZhciBvdXQyID0gW107XG4gICAgdmFyIHQyID0gbjtcbiAgICB2YXIgazIgPSAwO1xuICAgIHZhciBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgdmFyIGluZGV4ZWQgPSBbXTtcblxuICAgIC8vIG91dDIgaXMgYWxsIG1hdGNoZWQgdmFyaWFibGVzLCBpbmRleGVkIGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG1hdGNoZWQgdmFyaWFibGVzIHN0YXJ0aW5nIGluZGV4IGFuZCBmaW5pc2hpbmcgaW5kZXguICBlLmcuLCBuPVwid2FycysyXCIsIG91dDI9W3dhciwgd2Fyc10sIGluZGV4ZWQ9W3swLDJ9LHswLDN9XVxuICAgIGZvciAodmFyIGkgaW4gdmFsdWVLZXkpIHtcbiAgICAgICAgdmFyIG0yID0gbi5tYXRjaCh2YWx1ZUtleVtpXSk7XG4gICAgICAgIGlmIChtMiAhPSBudWxsKVxuICAgICAgICAgICAgb3V0Mi5wdXNoKG0yWzBdKTtcblxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHZhbHVlS2V5W2ldLCBcImdcIik7XG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZiAocyAhPSAtMSlcbiAgICAgICAgICAgIGluZGV4ZWQucHVzaCh7ZnJvbTogcywgdG86IHMgKyB2YWx1ZUtleVtpXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICAvLyBuZXN0ZWQgbG9vcCBub3QgZ29vZCwgYnV0IGluZGV4ZWQgaXMgbm90IGxpa2VseSB0byBiZSB2ZXJ5IGxhcmdlLlxuICAgIC8vIGlmIGEgdmFyaWFibGUgaXMgbmVzdGVkLCBpdCBpcyByZW1vdmVkIGZyb20gb3V0MlxuICAgIC8vIG5vdGljZSwgbG9vcCBpcyBiYWNrd2FyZHMgc28gdGhhdCBpbmRleCBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGUgc3BsaWNlXG4gICAgY2RiKFwiaW5kZXhlZCBcIiwgaW5kZXhlZCk7XG4gICAgZm9yICh2YXIgaSA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaiA+IC0xOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChpbmRleGVkW2ldLmZyb20gPj0gaW5kZXhlZFtqXS5mcm9tKSAmIChpbmRleGVkW2ldLnRvIDw9IGluZGV4ZWRbal0udG8pKSB7XG4gICAgICAgICAgICAgICAgY2RiKGksIFwiIGlzIG5lc3RlZCBpbiBcIiwgaik7XG4gICAgICAgICAgICAgICAgZGVsKG91dDIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBvdXQyKSB7XG4gICAgICAgIHQyID0gdDIucmVwbGFjZShvdXQyW2ldLCBzdWJNZTIpOyAvL3NvbWV0aGluZyB0aGF0J2xsIG5ldmVyIGJlIGEgdmFyaWFibGUgbmFtZVxuICAgICAgICBrMiA9IGsyICsgMTtcbiAgICAgICAgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIH1cblxuICAgIGlmIChvdXQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0Mi5wdXNoKHQyKTtcbiAgICAgICAgY2RiKFwibmV3IG91dCBcIiwgb3V0Mik7XG4gICAgICAgIHJldHVybiAob3V0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICAgbiA9IG5hbWUgb2YgY29sdW1uL25vZGVcbiAgIHQgPSBzZWxlY3RlZCB0cmFuc2Zvcm1hdGlvblxuKi9cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybShuLCB0LCB0eXBlVHJhbnNmb3JtKSB7XG4gICAgaWYgKGRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGVUcmFuc2Zvcm0pXG4gICAgICAgIHQgPSB0LnJlcGxhY2UoXCIrXCIsIFwiX3BsdXNfXCIpOyAvLyBjYW4ndCBzZW5kIHRoZSBwbHVzIG9wZXJhdG9yXG5cbiAgICBjZGIoJ25hbWUgb2YgY29sOiAnICsgbik7XG4gICAgY2RiKCd0cmFuc2Zvcm1hdGlvbjogJyArIHQpO1xuXG4gICAgdmFyIGJ0biA9IGJ5SWQoJ2J0bkVzdGltYXRlJyk7XG5cbiAgICAvLyBmaW5kIHRoZSBub2RlIGJ5IG5hbWVcbiAgICB2YXIgbXluID0gZmluZE5vZGVJbmRleChuWzBdLCB0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgbXluID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG15biA9IGZpbmROb2RlSW5kZXgobiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0ge1xuICAgICAgICB2YXJuYW1lc1R5cGVzOiBuLFxuICAgICAgICBpbnRlcnZhbDogbXluLmludGVydmFsLFxuICAgICAgICBudW1jaGFyOiBteW4ubnVtY2hhcixcbiAgICAgICAgbmF0dXJlOiBteW4ubmF0dXJlLFxuICAgICAgICBiaW5hcnk6IG15bi5iaW5hcnlcbiAgICB9O1xuXG4gICAgY2RiKG15bik7XG4gICAgLy8gaWYgdHlwZVRyYW5zZm9ybSBidXQgd2UgYWxyZWFkeSBoYXZlIHRoZSBtZXRhZGF0YVxuICAgIGlmICh0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChteW4ubmF0dXJlID09IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90dmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImJhclwiO1xuICAgICAgICAgICAgYmFyc05vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChteW4ubmF0dXJlICE9IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgICAgICBkZW5zaXR5Tm9kZShteW4pO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbGV0IGpzb24gPSBhd2FpdCBtYWtlUmVxdWVzdChcbiAgICAgICAgUk9PS19TVkNfVVJMICsgJ3RyYW5zZm9ybWFwcCcsXG4gICAgICAgIHt6ZGF0YXVybDogZGF0YXVybCxcbiAgICAgICAgIHp2YXJzOiBteW4ubmFtZSxcbiAgICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgIHR5cGVUcmFuc2Zvcm06IHR5cGVUcmFuc2Zvcm0sXG4gICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzfSk7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGEgdHlwZVRyYW5zZm9ybT9cbiAgICBpZiAoanNvbi50eXBlVHJhbnNmb3JtWzBdKSB7XG4gICAgICAgIC8vIFllcy4gV2UncmUgdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgICBkMy5qc29uKGpzb24udXJsLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgIGxldCBub2RlO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZmluZE5vZGVJbmRleChrZXksIHRydWUpO1xuXHRcdCAgICAgICAgICAgIGlmICghbm9kZSlcblx0XHQgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBub2RlLCBkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiID8gZGVuc2l0eU5vZGUobm9kZSkgOlxuICAgICAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImJhclwiID8gYmFyc05vZGUobm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICBub2RlICYmIGNkYihub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLyogTm8sIHdlIGhhdmUgYSBuZXcgbm9kZSBoZXJlLS1lLmcuIHRoZSB0cmFuc2Zvcm1lZCBjb2x1bW5cbiAgICAgICAgICAgZXhhbXBsZSByZXNwb25zZToge1xuICAgICAgICAgICBcImNhbGxcIjpbXCJ0X3llYXJfMlwiXSxcbiAgICAgICAgICAgXCJ1cmxcIjpbXCJkYXRhL3ByZXByb2Nlc3NTdWJzZXRfQkFDQ0JDNzgtN0REOS00NDgyLUIzMUQtNkVCMDFDM0EwQzk1LnR4dFwiXSxcbiAgICAgICAgICAgXCJ0cmFuc1wiOltcInllYXJcIixcIl90cmFuc3ZhcjBeMlwiXSxcbiAgICAgICAgICAgXCJ0eXBlVHJhbnNmb3JtXCI6W2ZhbHNlXVxuICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZnVuYzogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIHp2YXJzOiBuLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdWJzZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgckNhbGwgPSBbXTtcblxuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICAgICAgdmFyIG5ld1ZhciA9IHJDYWxsWzBdWzBdO1xuXG4gICAgICAgIHRyYW5zLnB1c2gobmV3VmFyKTtcblxuICAgICAgICAvLyBSZWFkIHRoZSBwcmVwcm9jZXNzIGZpbGUgY29udGFpbmluZyB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIHRoZSB0cmFuc2Zvcm1lZCB2YXJpYWJsZVxuICAgICAgICAvL1xuICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcblxuICAgICAgICAgICAgdmFyIGpzb25kYXRhID0gZ2V0VmFyaWFibGVEYXRhKGpzb24pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG15SW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uOiB0aGlzIHZhcmlhYmxlIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1lZCB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBzcGFjZVxuICAgICAgICAgICAgICAgIHZhciBpID0gYWxsTm9kZXMubGVuZ3RoOyAgLy8gZ2V0IG5ldyBpbmRleFxuICAgICAgICAgICAgICAgIHZhciBvYmoxID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICBsYWJsOiBcInRyYW5zZm9ybWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdLFxuICAgICAgICAgICAgICAgICAgICBub2RlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBzZXR4cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJ2YWw6IGpzb25kYXRhW2tleV0uaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHROdW1jaGFyOiBqc29uZGF0YVtrZXldLm51bWNoYXIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHROYXR1cmU6IGpzb25kYXRhW2tleV0ubmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0QmluYXJ5OiBqc29uZGF0YVtrZXldLmJpbmFyeVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqMSk7XG4gICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eU5vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNob3dMb2coJ3RyYW5zZm9ybScsIHJDYWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWtlUmVxdWVzdCh1cmwsIGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygndXJsOicsIHVybCk7XG4gICAgY29uc29sZS5sb2coJ1BPU1Q6JywgZGF0YSk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QodXJsLCB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGF9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlcyk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXMpWzBdID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdXYXJuaW5nOiAnICsgcmVzLndhcm5pbmcpO1xuICAgICAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIHJlcy53YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKGZhbHNlLCBlcnIpO1xuICAgICAgICBjZGIoZXJyKTtcbiAgICAgICAgYWxlcnQoYEVycm9yOiBjYWxsIHRvICR7dXJsfSBmYWlsZWRgKTtcbiAgICB9XG5cbiAgIC8qXG4gICAgLy8gY2FsbCBlbmRfdGEzX3NlYXJjaCBpZiBzdGF0dXMgIT0gT0tcbiAgICAvLyBzdGF0dXMgbWF5IGJlIGluIGRpZmZlcmVudCBwbGFjZXMgZm9yIGRpZmZlcmVudCBjYWxscyB0aG91Z2gsIGFuZCB0aGlzIGlzIG5vdCB3b3J0aCBkb2luZyBhdCB0aGUgbW9tZW50XG4gICAgbGV0IG15cmVnID0gL2QzbS1zZXJ2aWNlL2c7XG4gICAgbGV0IGlzZDNtY2FsbCA9IG15cmVnLnRlc3QodXJsKTtcbiAgICBpZihpc2QzbWNhbGwpIHtcbiAgICAgICAgbGV0IG15c3RhdHVzID0gcmVzLnJlc3BvbnNlSW5mby5zdGF0dXMuY29kZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZihteXN0YXR1cyAhPSBcIk9LXCIpIHtcbiAgICAgICAgICAgIGVuZF90YTNfc2VhcmNoKGZhbHNlLCBcImdycGMgcmVzcG9uc2Ugc3RhdHVzIG5vdCBva1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdlbmQoKSB7XG4gICAgYm9yZGVyU3RhdGUoKTtcbiAgICBtLnJlZHJhdygpO1xufVxuXG4vKipcbiAgIHByb2dyYW1tYXRpY2FsbHkgZGVzZWxlY3QgZXZlcnkgc2VsZWN0ZWQgdmFyaWFibGVcbiovXG5leHBvcnQgZnVuY3Rpb24gZXJhc2UoKSB7XG4gICAgWycjbGVmdHBhbmVsJywgJyNyaWdodHBhbmVsJ10uZm9yRWFjaChpZCA9PiBkMy5zZWxlY3QoaWQpLmF0dHIoJ2NsYXNzJywgJ3NpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXgnKSk7XG4gICAgdGFiTGVmdCgndGFiMScpO1xuICAgICQoXCIjdmFyTGlzdFwiKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh6cGFyYW1zLnpkdi5jb25jYXQoenBhcmFtcy56bm9tLCB6cGFyYW1zLnp2YXJzKS5pbmNsdWRlcyh0aGlzLmlkKSlcbiAgICAgICAgICAgIGNsaWNrVmFyKHt0YXJnZXQ6IHRoaXN9KTtcbiAgICB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhYkxlZnQodGFiKSB7XG4gICAgYnlJZCgndGFiMScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCh0YWIpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGlmICh0YWIgIT0gJ3RhYjMnKSB7XG4gICAgICAgIHN1YnNldCA9IHRhYiA9PSAndGFiMic7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgfVxuICAgIGxlZnR0YWIgPSB0YWI7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWJSaWdodCh0YWIpIHtcbiAgICBsZXQgc2VsZWN0ID0gY2xzID0+IHtcbiAgICAgICAgbGV0IHBhbmVsID0gZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIik7XG4gICAgICAgIHJldHVybiBjbHMgPyBwYW5lbC5hdHRyKCdjbGFzcycsIGNscykgOiBwYW5lbC5hdHRyKCdjbGFzcycpO1xuICAgIH07XG4gICAgbGV0IGNscyA9IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiO1xuICAgIGxldCB0b2dnbGVSID0gZnVsbCA9PiB7XG4gICAgICAgIHNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbHMgKyB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpID09PSBjbHMgPyAnJyA6IGNscyArICcgZXhwYW5kcGFuZWwnICsgZnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGFiID09PSBcImJ0bk1vZGVsc1wiKSBzZWxlY3QoY2xzKTtcbiAgICBlbHNlIGlmICh0YWIgPT09IFwiYnRuU2V0eFwiKSByaWdodHRhYiA9PT0gXCJidG5TZXR4XCIgfHwgc2VsZWN0KCkgPT09IGNscyAmJiB0b2dnbGVSKCdmdWxsJyk7XG4gICAgZWxzZSBpZiAodGFiID09PSBcImJ0blJlc3VsdHNcIikgIWVzdGltYXRlZCA/IHNlbGVjdChjbHMpIDpcbiAgICAgICAgcmlnaHR0YWIgPT09IFwiYnRuUmVzdWx0c1wiIHx8IHNlbGVjdCgpID09PSBjbHMgJiYgdG9nZ2xlUigpO1xuICAgIGVsc2UgaWYgKHRhYiA9PT0gXCJidG5Vbml2YXJpYXRlXCIpIHNlbGVjdChjbHMpO1xuICAgIHJpZ2h0dGFiID0gdGFiO1xufVxuXG5leHBvcnQgbGV0IHN1bW1hcnkgPSB7ZGF0YTogW119O1xuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB2YXJTdW1tYXJ5KGQpIHtcbiAgICBsZXQgdDEgPSAnTWVhbjosIE1lZGlhbjosIE1vc3QgRnJlcTosIE9jY3VycmVuY2VzOiwgTWVkaWFuIEZyZXE6LCBPY2N1cnJlbmNlczosIExlYXN0IEZyZXE6LCBPY2N1cnJlbmNlczosIFN0ZCBEZXY6LCBNaW5pbXVtOiwgTWF4aW11bTosIEludmFsaWQ6LCBWYWxpZDosIFVuaXF1ZXM6LCBIZXJmaW5kYWhsJy5zcGxpdCgnLCAnKTtcblxuICAgIGxldCByaW50ID0gZDMuZm9ybWF0KCdyJyk7XG4gICAgbGV0IHN0ciA9ICh4LCBwKSA9PiAoK3gpLnRvUHJlY2lzaW9uKHAgfHwgNCkudG9TdHJpbmcoKTtcbiAgICBsZXQgdDIgPSBwcml2ICYmIGQubWVhbkNJID9cbiAgICAgICAgW3N0cihkLm1lYW4sIDIpICsgJyAoJyArIHN0cihkLm1lYW5DSS5sb3dlckJvdW5kLCAyKSArICcgLSAnICsgc3RyKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpICsgJyknLFxuICAgICAgICAgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldIDpcbiAgICAgICAgW3N0cihkLm1lYW4pLCBzdHIoZC5tZWRpYW4pLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksXG4gICAgICAgICBzdHIoZC5zZCksIHN0cihkLm1pbiksIHN0cihkLm1heCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCBzdHIoZC5oZXJmaW5kYWhsKV07XG5cbiAgICBzdW1tYXJ5LmRhdGEgPSBbXTtcbiAgICB0MS5mb3JFYWNoKChlLCBpKSA9PiAhdDJbaV0uaW5jbHVkZXMoJ05hTicpICYmIHQyW2ldICE9ICdOQScgJiYgdDJbaV0gIT0gJycgJiYgc3VtbWFyeS5kYXRhLnB1c2goW2UsIHQyW2ldXSkpO1xuXG4gICAgc3VtbWFyeS5uYW1lID0gZC5uYW1lO1xuICAgIHN1bW1hcnkubGFibCA9IGQubGFibDtcblxuICAgIGQzLnNlbGVjdCgnI3RhYjMnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWQucGxvdHR5cGUpXG4gICAgICAgIHJldHVybjtcbiAgICBkLnBsb3R0eXBlID09ICdjb250aW51b3VzJyA/IGRlbnNpdHkoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQucGxvdHR5cGUgPT0gXCJiYXJcIiA/IGJhcnMoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIzXCIpIC8vIG5vIGdyYXBoIHRvIGRyYXcsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlbW92ZSBwcmV2aW91cyBncmFwaFxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGxldCBwb3BvdmVyQ29udGVudCA9IGQgPT4ge1xuICAgIGlmKHN3YW5kaXZlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBsZXQgW3JpbnQsIHByZWNdID0gW2QzLmZvcm1hdCgncicpLCAodmFsLCBpbnQpID0+ICgrdmFsKS50b1ByZWNpc2lvbihpbnQpLnRvU3RyaW5nKCldO1xuICAgIGxldCBkaXYgPSAoZmllbGQsIG5hbWUsIHZhbCkgPT4ge1xuICAgICAgICBpZiAoZmllbGQgIT0gJ05BJykgdGV4dCArPSBgPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz4ke25hbWV9PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPiR7dmFsIHx8IGZpZWxkfTwvcD48L2Rpdj48L2Rpdj5gO1xuICAgIH07XG4gICAgZC5sYWJsICE9ICcnICYmIGRpdihkLmxhYmwsICdMYWJlbCcpO1xuICAgIGRpdihkLm1lYW4sICdNZWFuJywgcHJpdiAmJiBkLm1lYW5DSSA/XG4gICAgICAgIGAke3ByZWMoZC5tZWFuLCAyKX0gKCR7cHJlYyhkLm1lYW5DSS5sb3dlckJvdW5kLCAyKX0gLSAke3ByZWMoZC5tZWFuQ0kudXBwZXJCb3VuZCwgMil9KWAgOlxuICAgICAgICBwcmVjKGQubWVhbiwgNCkpO1xuICAgIGRpdihkLm1lZGlhbiwgJ01lZGlhbicsIHByZWMoZC5tZWRpYW4sIDQpKTtcbiAgICBkaXYoZC5tb2RlLCAnTW9zdCBGcmVxJyk7XG4gICAgZGl2KGQuZnJlcW1vZGUsICdPY2N1cnJlbmNlcycsICByaW50KGQuZnJlcW1vZGUpKTtcbiAgICBkaXYoZC5taWQsICdNZWRpYW4gRnJlcScpO1xuICAgIGRpdihkLmZyZXFtaWQsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxbWlkKSk7XG4gICAgZGl2KGQuZmV3ZXN0LCAnTGVhc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFmZXdlc3QsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxZmV3ZXN0KSk7XG4gICAgZGl2KGQuc2QsICdTdGFuZCBEZXYnLCBwcmVjKGQuc2QsIDQpKTtcbiAgICBkaXYoZC5tYXgsICdNYXhpbXVtJywgcHJlYyhkLm1heCwgNCkpO1xuICAgIGRpdihkLm1pbiwgJ01pbmltdW0nLCBwcmVjKGQubWluLCA0KSk7XG4gICAgZGl2KGQuaW52YWxpZCwgJ0ludmFsaWQnLCByaW50KGQuaW52YWxpZCkpO1xuICAgIGRpdihkLnZhbGlkLCAnVmFsaWQnLCByaW50KGQudmFsaWQpKTtcbiAgICBkaXYoZC51bmlxdWVzLCAnVW5pcXVlcycsIHJpbnQoZC51bmlxdWVzKSk7XG4gICAgZGl2KGQuaGVyZmluZGFobCwgJ0hlcmZpbmRhaGwnLCBwcmVjKGQuaGVyZmluZGFobCwgNCkpO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gcGFuZWxQbG90cygpIHtcbiAgICBpZihJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIGJ5SWQoJ2J0blN1YnNldCcpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgIH1cbiAgICAvLyBidWlsZCBhcnJheXMgZnJvbSBub2RlcyBpbiBtYWluXG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgaWRzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgdmFycy5wdXNoKG4ubmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csICcnKSk7XG4gICAgICAgIGlkcy5wdXNoKG4uaWQpO1xuICAgIH0pO1xuXG4gICAgLy9yZW1vdmUgYWxsIHBsb3RzLCBjb3VsZCBiZSBzbWFydGVyIGhlcmVcbiAgICBkMy5zZWxlY3QoJyNzZXR4TGVmdCcpLnNlbGVjdEFsbCgnc3ZnJykucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjdGFiMicpLnNlbGVjdEFsbCgnc3ZnJykucmVtb3ZlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGFsbE5vZGVzW2lkc1tpXV0udmFsaWQ9PTApIC8vIHRoaXMgd2FzIGEgc2lsZW50IGVycm9yLi4uIHZlcnkgZnJ1c3RyYXRpbmcuLi5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2lkc1tpXV07XG4gICAgICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInNldHhMZWZ0XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJzdWJzZXRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhub2RlLCBkaXYgPSBcInNldHhMZWZ0XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnNTdWJzZXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0XCIpLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhMZWZ0XyhcXGQrKS87XG4gICAgICAgICAgICAgIHZhciBteW5hbWUgPSByZWdzdHIuZXhlYyh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVpZCA9IG15bmFtZVsyXTtcbiAgICAgICAgICAgICAgbXluYW1lID0gbXluYW1lWzFdO1xuICAgICAgICAgICAgICBpZiAoIXZhcnMuaW5jbHVkZXMobXluYW1lKSkge1xuICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfc2V0eExlZnRfXCIsIG5vZGVpZCk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfdGFiMl9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRlbXApXG4gICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbn1cblxuLyoqXG4gICBjb252ZXJ0cyBjb2xvciBjb2Rlc1xuKi9cbmV4cG9ydCBsZXQgaGV4VG9SZ2JhID0gaGV4ID0+IHtcbiAgICBsZXQgaW50ID0gcGFyc2VJbnQoaGV4LnJlcGxhY2UoJyMnLCAnJyksIDE2KTtcbiAgICByZXR1cm4gYHJnYmEoJHtbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NSwgJzAuNSddLmpvaW4oJywnKX0pYDtcbn07XG5cbi8qKlxuICAgdGFrZXMgbm9kZSBhbmQgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuKi9cbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG4gICAgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzEnKSB7XG4gICAgICAgIGlmIChjID09IGdyMUNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDEsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09IGdyMkNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIG5vZGUgd2l0aCBubyBzdHJva2VcbiAgICAgICAgbi5zdHJva2VXaWR0aCA9ICc0JztcbiAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgIG4ubm9kZUNvbCA9IHRhZ2dlZENvbG9yO1xuICAgICAgICBsZXQgcHVzaCA9IChbY29sb3IsIGtleV0pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xvciAhPSBjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHpwYXJhbXNba2V5XSA9IEFycmF5LmlzQXJyYXkoenBhcmFtc1trZXldKSA/IHpwYXJhbXNba2V5XSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtc1trZXldLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ3pub20nKSB7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09ICd6ZHYnKXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdyb3VwIG1lbWJlcnNoaXBzIGZyb20gZHYnc1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAxKXtcbiAgICAgICAgICAgICAgICAgICAgbi5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMSwgLTEsIG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIC0xLCBuLm5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFtbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddXS5mb3JFYWNoKHB1c2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgenBhcmFtc1Jlc2V0KG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHpwYXJhbXNSZXNldChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYyl7XG4gICAgICAgICAgICAgICAgdmFyIGR2bmFtZSA9IG4ubmFtZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpeyAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBtZW1iZXJzaGlwcyBmcm9tIGR2J3NcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAxLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAyKXtcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAyLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IxQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMUNvbG9yKS5hdHRyKCdmaWxsJywgZ3IxQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjFCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IyQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMkNvbG9yKS5hdHRyKCdmaWxsJywgZ3IyQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjJCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJzZXRTZWxlY3QoYnRuKSB7XG4gICAgaWYgKGRhdGF1cmwpIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgfVxuICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIHpwYXJhbXMuenBsb3QgPSBbXTtcbiAgICB2YXIgc3Vic2V0RW1wdHkgPSB0cnVlO1xuICAgIC8vIGlzIHRoaXMgdGhlIHNhbWUgYXMgelBvcCgpP1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy8gcG9wdWxhdGUgenZhcnMgYW5kIHpzdWJzZXQgYXJyYXlzXG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVswXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVswXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMF0pO1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVsxXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenBsb3QucHVzaChhbGxOb2Rlc1t0ZW1wXS5wbG90dHlwZSk7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIilcbiAgICAgICAgICAgIHN1YnNldEVtcHR5ID0gZmFsc2U7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBvbmVcbiAgICB9XG5cbiAgICBpZiAoc3Vic2V0RW1wdHkgPT0gdHJ1ZSkge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIG5ldyBzdWJzZXQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhcm5hbWVzVHlwZXM6IGFsbE5vZGVzW2pdLm5hbWUsXG4gICAgICAgICAgICBuYXR1cmU6IGFsbE5vZGVzW2pdLm5hdHVyZSxcbiAgICAgICAgICAgIG51bWNoYXI6IGFsbE5vZGVzW2pdLm51bWNoYXIsXG4gICAgICAgICAgICBiaW5hcnk6IGFsbE5vZGVzW2pdLmJpbmFyeSxcbiAgICAgICAgICAgIGludGVydmFsOiBhbGxOb2Rlc1tqXS5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBidXR0b24gbW90aW9uXG4gICAgbGV0IGpzb24gPSBtYWtlUmVxdWVzdChcbiAgICAgICAgUk9PS19TVkNfVVJMICsgJ3N1YnNldFNlbGVjdCcsXG4gICAgICAgIHt6ZGF0YXVybDogenBhcmFtcy56ZGF0YXVybCxcbiAgICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICAgenN1YnNldDogenBhcmFtcy56c3Vic2V0LFxuICAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzfSk7XG4gICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgJChcIiNidG5Nb2RlbHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG5cbiAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgIHpQb3AoKTtcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTtcbiAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICB2YXIgbXlGb3JjZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGZvcmNldG9nZ2xlKTtcbiAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgIHZhciBteUhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBjYWxsSGlzdG9yeSk7XG5cbiAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgXCJ6cGFyYW1zXCI6IG15UGFyYW1zLFxuICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgXCJwcmVwcm9jZXNzXCI6IG15UHJlcHJvY2VzcyxcbiAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0nKTtcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgIG15c3BhY2UgPSBzcGFjZXMubGVuZ3RoO1xuICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICB6dmFyczogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56dmFycyksXG4gICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgIC8vIGlmIGluIG5vZGVzLCByZW1vdmUgZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB2W2ldLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcblxuICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgaWYgKGVycm9yKXtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID0gXCJcIjtcblxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZSA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnZhbGlkID09IDApIHtcbiAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlUGxvdCgpO1xuICAgICAgICBsYXlvdXQobGF5b3V0QWRkKTtcbiAgICB9KTtcblxuICAgIHZhck91dChncmF5T3V0cyk7XG59XG5cbi8qKlxuICAgcmVtb3ZlcyBhbGwgdGhlIGNoaWxkcmVuIHN2Z3MgaW5zaWRlIHN1YnNldCBhbmQgc2V0eCBkaXZzXG4qL1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjc2V0eCcpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBhbGxOb2Rlcy5mb3JFYWNoKG4gPT4gbi5zZXR4cGxvdCA9IG4uc3Vic2V0cGxvdCA9IGZhbHNlKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgbGV0IGZha2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgd3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQod3MpLmQzQ2xpY2soKTtcbiAgICBkMy5zZWxlY3Qod3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59O1xuXG4vKipcbiAgIEVuZFNlc3Npb24oU2Vzc2lvbkNvbnRleHQpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmRzZXNzaW9uKCkge1xuICAgLy8gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2VuZHNlc3Npb24nLCBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCkpO1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZW5kc2Vzc2lvbicsIGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSk7XG4gICAgbGV0IG15c3RhdHVzID0gcmVzLnN0YXR1cy5jb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYobXlzdGF0dXMgPT0gXCJPS1wiKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKHRydWUsIFwiUHJvYmxlbSBtYXJrZWQgYXMgY29tcGxldGUuXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gICAgcnBjIERlbGV0ZVBpcGVsaW5lcyhQaXBlbGluZURlbGV0ZVJlcXVlc3QpIHJldHVybnMgKFBpcGVsaW5lTGlzdFJlc3VsdCkge31cbiAgICBwaXBlcyBpcyBhbiBhcnJheSBvZiBwaXBlbGluZSBJRHNcbiovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlcGlwZWxpbmVzKHBpcGVzKSB7XG4gICAgbGV0IHJlcyA9IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9EZWxldGVQaXBlbGluZXMnLCB7Y29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpLCBkZWxldGVQaXBlbGluZUlkczogcGlwZXN9KTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAgICBycGMgRGVsZXRlUGlwZWxpbmVzKFBpcGVsaW5lRGVsZXRlUmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuICAgIHBpcGVzIGlzIGFuIGFycmF5IG9mIHBpcGVsaW5lIElEc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxwaXBlbGluZXMocGlwZXMpIHtcbiAgICBsZXQgcmVzID0gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NhbmNlbFBpcGVsaW5lcycsIHtjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIGNhbmNlbFBpcGVsaW5lSWRzOiBwaXBlc30pO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5cbi8qKlxuICAgcnBjIExpc3RQaXBlbGluZXMoUGlwZWxpbmVMaXN0UmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuICAgcGlwZXMgaXMgYW4gYXJyYXkgb2YgcGlwZWxpbmUgSURzXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RwaXBlbGluZXMoKSB7XG4gICAgbGV0IHJlcyA9IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9saXN0cGlwZWxpbmVzJywge2NvbnRleHQ6IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKX0pO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL2hhcmRjb2RlZCBwaXBlcyBmb3Igbm93XG4gICAgbGV0IHBpcGVzID0gcmVzLnBpcGVsaW5lSWRzO1xuXG4gICAgLypcbiAgICAgIHBpcGVzLnVuc2hpZnQoXCJwbGFjZVwiKTtcbiAgICAgIGNvbnNvbGUubG9nKHBpcGVzKTtcbiAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgIC5kYXRhKHBpcGVzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAuYXR0cihcImlkXCIsIFwiX3BpcGVfXCIuY29uY2F0KVxuICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpXG4gICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICB9fSk7XG5cbiAgICAgIHBpcGVzLnNoaWZ0KCk7XG5cblxuICAgICAgZDMuc2VsZWN0KFwiI3NldHhSaWdodFwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAuZGF0YShwaXBlcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCBcIl9zZXR4cGlwZV9cIi5jb25jYXQpXG4gICAgICAudGV4dChkID0+IGQpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIGQzLnNlbGVjdChcIiNzZXR4UmlnaHRcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgfX0pO1xuICAgICovXG59XG5cbi8qKlxuICAgcnBjIEV4ZWN1dGVQaXBlbGluZShQaXBlbGluZUV4ZWN1dGVSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0gUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7fVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlcGlwZWxpbmUoKSB7XG4gICAgbGV0IGNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgbGV0IHRhYmxlcm93ID0gYnlJZCgnc2V0eFJpZ2h0JykucXVlcnlTZWxlY3RvcigndHIuaXRlbS1zZWxlY3QnKTtcbiAgICBpZih0YWJsZXJvdyA9PSBudWxsKSB7YWxlcnQoXCJQbGVhc2Ugc2VsZWN0IGEgcGlwZWxpbmUgdG8gZXhlY3V0ZSBvbi5cIik7IHJldHVybjt9XG4gICAgbGV0IHBpcGVsaW5lSWQ9dGFibGVyb3cuZmlyc3RDaGlsZC5pbm5lclRleHQ7XG5cbiAgICB6UG9wKCk7XG4gICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgIGxldCBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG5cbiAgICAvL2xldCBwcmVkaWN0RmVhdHVyZXMgPSBhcGlGZWF0dXJlKHpwYXJhbXMuenZhcnMsXCI8PERBVEFfVVJJPj5cIik7XG4gICAgZGF0YXNldF91cmkgPSBcIjw8REFUQV9VUkk+PlwiOyAgICAgLy8gc2hvdWxkIHBlcmhhcHMgYWRqdXN0IGNhbGwgdG8gZGF0YXNldFVyaSB0byBmb2xsb3cgc3ludGF4IG5vcm1zIG9uIG90aGVyIGNhbGxzIHRvIERqYW5nb1xuICAgIGxldCBkYXRhID0gW107XG5cbiAgICAvL3RoaXMgd2lsbCBqdXN0IHNldCB6cGFyYW1zLnpzZXR4IHRvIHRoZSBtZWFuLCB3aGljaCBpcyBkZWZhdWx0IGZvciBzZXR4IHBsb3RzXG4gICAgLy9ub3RlIHRoYXQgaWYgc2V0eHBsb3QgaXMgbW9kaWZpZWQsIGl0IHdpbGwgTk9UID09IFwiXCIgYmVjYXVzZSB6cGFyYW1zLnpzZXR4IGlzIG1vZGlmaWVkIHdoZW4gdGhlIHNldHggcGxvdCBzbGlkZXIgaXMgbW92ZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgZm9yKGxldCBpID0wOyBpPHpwYXJhbXMuenZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbXltZWFuID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgaWYoenBhcmFtcy56c2V0eFtpXVswXT09XCJcIikge1xuICAgICAgICAgICAgbXlkYXRhWzBdPW15bWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMF0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMF09enBhcmFtcy56c2V0eFtpXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZih6cGFyYW1zLnpzZXR4W2ldWzFdPT1cIlwiKSB7XG4gICAgICAgICAgICBteWRhdGFbMV09YWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMV0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMV09enBhcmFtcy56c2V0eFtpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2gobXlkYXRhKTtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZXhlY3V0ZXBpcGVsaW5lJywge2NvbnRleHQsIHBpcGVsaW5lSWQsIGRhdGFzZXRfdXJpLCBkYXRhfSk7XG59XG5cbi8qKlxuICAgIGNhbGwgdG8gZGphbmdvIHRvIHVwZGF0ZSB0aGUgcHJvYmxlbSBkZWZpbml0aW9uIGluIHRoZSBwcm9ibGVtIGRvY3VtZW50IFxuICAgIHJwYyBTZXRQcm9ibGVtRG9jKFNldFByb2JsZW1Eb2NSZXF1ZXN0KSByZXR1cm5zIChSZXNwb25zZSkge31cbiovXG5mdW5jdGlvbiBzZXRQcm9ibGVtRGVmaW5pdGlvbih0eXBlLCB1cGRhdGVzLCBsb29rdXApIHtcbiAgICBtYWtlUmVxdWVzdChcbiAgICAgICAgRDNNX1NWQ19VUkwgKyBcIi9TZXRQcm9ibGVtRG9jXCIsXG4gICAgICAgIHtyZXBsYWNlUHJvYmxlbVNjaGVtYUZpZWxkOiB7W3R5cGVdOiBsb29rdXBbdXBkYXRlc1t0eXBlXV1bMV19LCBjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCl9KTtcbn1cblxuLyoqXG4gICBmaW5kIHNvbWV0aGluZyBjZW50ZXJpc2ggdG8gdGhlIHZlcnRpY2VzIG9mIGEgY29udmV4IGh1bGxcbiAgIChzcGVjaWZpY2FsbHksIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveClcbiovXG5mdW5jdGlvbiBqYW1lc2NlbnRyb2lkKGNvb3JkKSB7XG4gICAgdmFyIG1pbnggPSBjb29yZFswXVswXSxcbiAgICAgICAgbWF4eCA9IGNvb3JkWzBdWzBdLFxuICAgICAgICBtaW55ID0gY29vcmRbMF1bMV0sXG4gICAgICAgIG1heHkgPSBjb29yZFswXVsxXTtcbiAgICBmb3IodmFyIGogPSAxOyBqPGNvb3JkLmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzBdIDwgbWlueCkgbWlueCA9IGNvb3JkW2pdWzBdO1xuICAgICAgICBpZiAoY29vcmRbal1bMV0gPCBtaW55KSBtaW55ID0gY29vcmRbal1bMV07XG4gICAgICAgIGlmIChjb29yZFtqXVswXSA+IG1heHgpIG1heHggPSBjb29yZFtqXVswXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzFdID4gbWF4eSkgbWF4eSA9IGNvb3JkW2pdWzFdO1xuICAgIH07XG4gICAgICAgIHJldHVyblsobWlueCArIG1heHgpLzIsIChtaW55ICsgbWF4eSkvMl07XG59O1xuXG4vKipcbiAgIERlZmluZSBlYWNoIHBlYmJsZSByYWRpdXMuXG4gICBQcmVzZW50bHksIG1vc3QgcGViYmxlcyBhcmUgc2NhbGVkIHRvIHJhZGl1cyBzZXQgYnkgZ2xvYmFsIFJBRElVUy5cbiAgIE1lbWJlcnMgb2YgZ3JvdXBzIGFyZSBzY2FsZWQgZG93biBpZiBncm91cCBnZXRzIGxhcmdlLlxuKi9cbmZ1bmN0aW9uIHNldFBlYmJsZVJhZGl1cyhkKXtcbiAgICBpZiAoZC5ncm91cDEgfHwgZC5ncm91cDIpeyAvLyBpZiBhIG1lbWJlciBvZiBhIGdyb3VwLCBuZWVkIHRvIGNhbGN1bGF0ZSByYWRpdXMgc2l6ZVxuICAgICAgICB2YXIgdXBwZXJzaXplID0gN1xuICAgICAgICB2YXIgbmcxID0gKGQuZ3JvdXAxKSA/IHpwYXJhbXMuemdyb3VwMS5sZW5ndGggOiAxOyAvLyBzaXplIG9mIGdyb3VwMSwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMVxuICAgICAgICB2YXIgbmcyID0gKGQuZ3JvdXAyKSA/IHpwYXJhbXMuemdyb3VwMi5sZW5ndGggOiAxOyAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsIG5nMik7IC8vIHNpemUgb2YgdGhlIGxhcmdlc3QgZ3JvdXAgdmFyaWFibGUgaXMgbWVtYmVyIG9mXG4gICAgICAgIHJldHVybiAobWF4bmc+dXBwZXJzaXplKSA/IFJBRElVUypNYXRoLnNxcnQodXBwZXJzaXplL21heG5nKSA6IFJBRElVUzsgLy8ga2VlcCB0b3RhbCBhcmVhIG9mIHBlYmJsZXMgYm91bmRlZCB0byBwaSAqIFJBRElVU14yICogdXBwZXJzaXplLCB0aHVzIHNocmlua2luZyByYWRpdXMgZm9yIHBlYmJsZXMgaW4gbGFyZ2VyIGdyb3Vwc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSQURJVVM7IC8vIG5vbmdyb3VwIG1lbWJlcnMgZ2V0IHRoZSBjb21tb24gZ2xvYmFsIHJhZGl1c1xuICAgIH1cbn07XG5cbi8qKlxuICAgRGVmaW5lIGVhY2ggcGViYmxlIGNoYXJnZS5cbiovXG5mdW5jdGlvbiBzZXRQZWJibGVDaGFyZ2UoZCl7XG4gICAgaWYoZC5ncm91cDEgfHwgZC5ncm91cDIpe1xuICAgICAgICBpZihkLmZvcmVmcm9udCl7Ly8gcGViYmxlcyBwYWNrZWQgaW4gZ3JvdXBzIHJlcGVsIG90aGVycyBvbiBtb3VzZW92ZXJcbiAgICAgICAgICAgIHJldHVybiAtMTAwMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBwZXJzaXplID0gNztcbiAgICAgICAgdmFyIG5nMSA9IChkLmdyb3VwMSkgPyB6cGFyYW1zLnpncm91cDEubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMSwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMVxuICAgICAgICB2YXIgbmcyID0gKGQuZ3JvdXAyKSA/IHpwYXJhbXMuemdyb3VwMi5sZW5ndGggOiAxOyAgICAgIC8vIHNpemUgb2YgZ3JvdXAyLCBpZiBhIG1lbWJlciBvZiBncm91cCAyXG4gICAgICAgIHZhciBtYXhuZyA9IE1hdGgubWF4KG5nMSxuZzIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgb2YgdGhlIGxhcmdlc3QgZ3JvdXAgdmFyaWFibGUgaXMgbWVtYmVyIG9mXG4gICAgICAgIHJldHVybiAobWF4bmc+dXBwZXJzaXplKSA/IC00MDAqKHVwcGVyc2l6ZS9tYXhuZykgOiAtNDAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlIGNoYXJnZSBhcyBwZWJibGVzIGJlY29tZSBzbWFsbGVyLCBzbyB0aGV5IGNhbiBwYWNrIHRvZ2V0aGVyXG4gICAgfWVsc2V7XG4gICAgICAgIHJldHVybiAtODAwO1xuICAgIH1cbn07XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRyaWdodHBhbmVsKCkge1xuICAgIGJ5SWQoJ3JpZ2h0cGFuZWwnKS5jbGFzc0xpc3QuYWRkKFwiZXhwYW5kcGFuZWxmdWxsXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnRuV2lkdGhzKGJ0bnMpIHtcbiAgICBsZXQgd2lkdGggPSBgJHsxMDAgLyBidG5zLmxlbmd0aH0lYDtcbiAgICBsZXQgZXhwYW5kd2lkdGggPSAnMzUlJztcbiAgICBsZXQgc2hyaW5rd2lkdGggPSBgJHs2NSAvIChidG5zLmxlbmd0aCAtIDEpfSVgO1xuICAgIGxldCBsaXMgPSBieUlkKCdyaWdodHBhbmVsJykucXVlcnlTZWxlY3RvckFsbChcIi5hY2NvcmRpb24gbGlcIik7XG4gICAgLy8gaGFyZGx5IGV2ZXIgcnVucyBvbiB0aGUgcGFnZVxuICAgIGxpcy5mb3JFYWNoKGxpID0+IHtcbiAgICAgICAgbGkuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsaXMuZm9yRWFjaChsaSA9PiBsaS5zdHlsZS53aWR0aCA9IHNocmlua3dpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSBleHBhbmR3aWR0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKCkgPT4gbGlzLmZvckVhY2gobGkgPT4gbGkuc3R5bGUud2lkdGggPSB3aWR0aCkpO1xuICAgIH0pO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB0b2dnbGVSaWdodEJ1dHRvbnMoc2V0KSB7XG4gICAgaWYgKHNldD09XCJhbGxcIikge1xuICAgICAgICAvLyBmaXJzdCByZW1vdmUgbm9zaG93IGNsYXNzXG4gICAgICAgIGxldCBidG5zID0gYnlJZCgncmlnaHRwYW5lbGJ1dHRvbnMnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLm5vc2hvd1wiKTtcbiAgICAgICAgYnRucy5mb3JFYWNoKGIgPT4gYi5jbGFzc0xpc3QucmVtb3ZlKFwibm9zaG93XCIpKTtcblxuICAgICAgICAvLyBkcm9wcGluZyBtb2RlbHMgZm9yIElTX0QzTV9ET01BSU5cbiAgICAgICAgYnlJZCgnYnRuTW9kZWxzJykuY2xhc3NMaXN0LmFkZChcIm5vc2hvd1wiKTtcblxuICAgICAgICAvLyBpZiBzd2FuZGl2ZSwgZHJvcHBpbmcgc2V0eFxuICAgICAgICBpZihzd2FuZGl2ZSlcbiAgICAgICAgICAgIGJ5SWQoJ2J0blNldHgnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuXG4gICAgICAgIC8vIHRoZW4gc2VsZWN0IGFsbCB0aGUgYnV0dG9uc1xuICAgICAgICBidG5zID0gYnlJZCgncmlnaHRwYW5lbGJ1dHRvbnMnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLmJ0bjpub3QoLm5vc2hvdylcIik7XG4gICAgICAgIGJ0bldpZHRocyhidG5zKTtcbiAgICB9IGVsc2UgaWYgKHNldD09XCJtb2RlbHNcIikge1xuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blNldHgnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blJlc3VsdHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blR5cGUnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBieUlkKCdidG5TdWJ0eXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYnlJZCgnYnRuTWV0cmljcycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIGJ5SWQoJ2J0bk91dHB1dHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3VsdHNwbG90aW5pdChwaWQsIGR2dmFsdWVzKSB7XG4gICAgLy8gcHJlc3VtYWJseSB3ZSdsbCBiZSByZWFkaW5nIGluIHJlc3VsdHMgZnJvbSBhIHBhdGhcbiAgICAvLyBmb3Igbm93IGl0J3MganVzdCBoYXJkY29kZWRcbiAgICBjb25zb2xlLmxvZyhwaWQpO1xuICAgIGxldCBwcmVkZmlsZSA9IHBpZC5waXBlbGluZUluZm8ucHJlZGljdFJlc3VsdERhdGEuZmlsZV8xO1xuICAgIGxldCBwcmVkdmFscyA9IFtdO1xuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHByZWRmaWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZWR2YWxzLnB1c2goTnVtYmVyKHByZWRmaWxlW2ldLnByZWRzKSk7XG4gICAgfVxuXG4gICAgLy8gb25seSBkbyB0aGlzIGZvciBjbGFzc2lmaWNhdGlvbiB0YXNrc1xuICAgIGlmKGQzbVRhc2tUeXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZV1bMV0gPT0gXCJDTEFTU0lGSUNBVElPTlwiKSB7XG4gICAgICAgIGdlbmNvbmZkYXRhKGR2dmFsdWVzLCBwcmVkdmFscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHhkYXRhID0gXCJBY3R1YWxcIjtcbiAgICAgICAgbGV0IHlkYXRhID0gXCJQcmVkaWN0ZWRcIjtcbiAgICAgICAgYml2YXJpYXRlUGxvdChkdnZhbHVlcywgcHJlZHZhbHMsIHhkYXRhLCB5ZGF0YSk7XG4gICAgfVxufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuY29uZmRhdGEgKGR2dmFsdWVzLCBwcmVkdmFscykge1xuICAgIC8vIEZPUiBURVNUSU5HXG4gICAgZHZ2YWx1ZXMgPSBwcmVkdmFscy5zbGljZSgwKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZHZ2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmRvbW51bWJlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgyIC0gLTIgKyAxKSkgKyAtMjtcbiAgICAgICAgZHZ2YWx1ZXNbaV0gPSBkdnZhbHVlc1tpXSArIHJhbmRvbW51bWJlcjtcbiAgICB9XG5cbiAgICAvLyBkb25lIGZvciB0ZXN0aW5nLiBkcm9wIGFib3ZlIHdoZW4gZHZ2YWx1ZXMgYXJlIHJlYWwgdmFsdWVzIHJldHVybmVkIGJ5IFIgd2hlbiBwaXBlbGluZSBpcyBjb25zdHJ1Y3RlZFxuXG4gICAgZnVuY3Rpb24gb25seVVuaXF1ZSh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH1cblxuICAgIGxldCBteWNvdW50cyA9IFtdO1xuICAgIGxldCBteXBhaXJzID0gW107XG5cbiAgICAvLyB0aGlzIHNob3VsZCBldmVudHVhbGx5IGJlIGp1c3QgcmVhZCBmcm9tIHRoZSBVUkkgaW4gcGlwZWxpbmVcbiAgIC8vIGxldCBkdnZhbHVlcyA9IFsxLDEsMSwyLDMsMiwzLDMsMywzLDMsMiwzLDIsMSwyLDMsNCw0XTtcbiAgIC8vIGxldCBwcmVkdmFscyA9IFsxLDIsMywyLDMsMSwzLDMsMywyLDIsMSwzLDMsMSwyLDMsNCwzXTtcblxuICAgIC8vIGNvbWJpbmUgYWN0dWFscyBhbmQgcHJlZGljdGVkLCBhbmQgZ2V0IGFsbCB1bmlxdWUgZWxlbWVudHNcbiAgICBsZXQgbXl1bmlxdWVzID0gZHZ2YWx1ZXMuY29uY2F0KHByZWR2YWxzKTtcbiAgICBteXVuaXF1ZXMgPSBteXVuaXF1ZXMuZmlsdGVyKG9ubHlVbmlxdWUpO1xuXG4gICAgLy8gY3JlYXRlIHR3byBhcnJheXM6IG15Y291bnRzIGluaXRpYWxpemVkIHRvIDAsIG15cGFpcnMgaGF2ZSBlbGVtZW50cyBzZXQgdG8gYWxsIHBvc3NpYmxlIHBhaXJzIG9mIHVuaXF1ZXNcbiAgICAvLyBsb29rZWQgaW50byBzb2x1dGlvbnMgb3RoZXIgdGhhbiBuZXN0ZWQgZm9ycywgYnV0IEludGVybmV0IHN1Z2dlc3QgcGVyZm9ybWFuY2UgaXMganVzdCBmaW5lIHRoaXMgd2F5XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG15dW5pcXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGVtcGNvdW50ID0gW107XG4gICAgICAgIGxldCB0ZW1wcGFpciA9IFtdO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbXl1bmlxdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBteWNvdW50cy5wdXNoKDApO1xuICAgICAgICAgICAgbXlwYWlycy5wdXNoKCtteXVuaXF1ZXNbaV0rJywnK215dW5pcXVlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaW5lIHVwIGFjdHVhbHMgYW5kIHByZWRpY3RlZCwgYW5kIGluY3JlbWVudCBteWNvdW50cyBhdCBpbmRleCB3aGVyZSBteXBhaXIgaGFzIGEgbWF0Y2ggZm9yIHRoZSAnYWN0dWFsLHByZWRpY3RlZCdcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR2dmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wcGFpciA9ICtkdnZhbHVlc1tpXSsnLCcrcHJlZHZhbHNbaV07XG4gICAgICAgIGxldCBteWluZGV4ID0gbXlwYWlycy5pbmRleE9mKHRlbXBwYWlyKTtcbiAgICAgICAgbXljb3VudHNbbXlpbmRleF0gKz0gMTtcbiAgICB9XG5cbiAgICBsZXQgY29uZmRhdGEgPSBbXSwgc2l6ZSA9IG15dW5pcXVlcy5sZW5ndGg7XG4gICAgLy8gYW5vdGhlciBsb29wLi4uIHRoaXMgYnVpbGRzIHRoZSBhcnJheSBvZiBhcnJheXMgZnJvbSB0aGUgZmxhdCBhcnJheSBteWNvdW50cyBmb3IgaW5wdXQgdG8gY29uZnVzaW9uc21hdHJpeCBmdW5jdGlvblxuICAgIHdoaWxlIChteWNvdW50cy5sZW5ndGggPiAwKVxuICAgICAgICBjb25mZGF0YS5wdXNoKG15Y291bnRzLnNwbGljZSgwLCBzaXplKSk7XG5cbiAgICBjb25mdXNpb25tYXRyaXgoY29uZmRhdGEsIG15dW5pcXVlcyk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25mdXNpb25tYXRyaXgobWF0cml4ZGF0YSwgY2xhc3Nlcykge1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgLy8gYWRhcHRlZCBmcm9tIHRoaXMgYmxvY2s6IGh0dHBzOi8vYmwub2Nrcy5vcmcvYXJwaXRuYXJlY2hhbmlhL2RiZjAzZDhlZjdmZmZhNDQ2Mzc5ZDU5ZGI2MzU0YmFjXG4gICAgbGV0IG1haW53aWR0aCA9IGJ5SWQoJ21haW4nKS5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWFpbmhlaWdodCA9IGJ5SWQoJ21haW4nKS5jbGllbnRIZWlnaHQ7XG5cbiAgICBsZXQgY29uZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uZGl2LmlkPVwiY29uZnVzaW9uY29udGFpbmVyXCI7XG4gICAgY29uZGl2LnN0eWxlLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjtcbiAgICBjb25kaXYuc3R5bGUud2lkdGg9KyhtYWlud2lkdGgqLjI1KSsncHgnO1xuICAgIGNvbmRpdi5zdHlsZS5tYXJnaW5MZWZ0PScyMHB4JztcbiAgICBjb25kaXYuc3R5bGUuaGVpZ2h0PSsobWFpbmhlaWdodCouNCkrJ3B4JztcbiAgICBjb25kaXYuc3R5bGUuZmxvYXQ9XCJsZWZ0XCI7XG4gICAgYnlJZCgnc2V0eE1pZGRsZScpLmFwcGVuZENoaWxkKGNvbmRpdik7XG5cbiAgICBsZXQgbGVnZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGVnZGl2LmlkPVwiY29uZnVzaW9ubGVnZW5kXCI7XG4gICAgbGVnZGl2LnN0eWxlLndpZHRoPSsobWFpbndpZHRoKi4wNykrJ3B4JztcbiAgICBsZWdkaXYuc3R5bGUubWFyZ2luTGVmdD0nMjBweCc7XG4gICAgbGVnZGl2LnN0eWxlLmhlaWdodD0rKG1haW5oZWlnaHQqLjQpKydweCc7XG4gICAgbGVnZGl2LnN0eWxlLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjtcbiAgICBieUlkKCdzZXR4TWlkZGxlJykuYXBwZW5kQ2hpbGQobGVnZGl2KTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDEwLCBib3R0b206IDAsIGxlZnQ6IDUwfTtcbiAgICBmdW5jdGlvbiBNYXRyaXgob3B0aW9ucykge1xuICAgICAgICBsZXQgd2lkdGggPSBvcHRpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIsXG4gICAgICAgIGxhYmVsc0RhdGEgPSBvcHRpb25zLmxhYmVscyxcbiAgICAgICAgc3RhcnRDb2xvciA9IG9wdGlvbnMuc3RhcnRfY29sb3IsXG4gICAgICAgIGVuZENvbG9yID0gb3B0aW9ucy5lbmRfY29sb3I7XG5cbiAgICAgICAgbGV0IHdpZHRoTGVnZW5kID0gb3B0aW9ucy53aWR0aExlZ2VuZDtcblxuICAgICAgICBpZighZGF0YSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIGRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8ICFkYXRhLmxlbmd0aCB8fCAhQXJyYXkuaXNBcnJheShkYXRhWzBdKSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0IHNob3VsZCBiZSBhIDItRCBhcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1heFZhbHVlID0gZDMubWF4KGRhdGEsIGZ1bmN0aW9uKGxheWVyKSB7IHJldHVybiBkMy5tYXgobGF5ZXIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pOyB9KTtcbiAgICAgICAgbGV0IG1pblZhbHVlID0gZDMubWluKGRhdGEsIGZ1bmN0aW9uKGxheWVyKSB7IHJldHVybiBkMy5taW4obGF5ZXIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pOyB9KTtcblxuICAgICAgICBsZXQgbnVtcm93cyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgbnVtY29scyA9IGRhdGFbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QoY29udGFpbmVyKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICBsZXQgYmFja2dyb3VuZCA9IHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjJweFwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgICAgIGxldCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgICAgIC5kb21haW4oZDMucmFuZ2UobnVtY29scykpXG4gICAgICAgIC5yYW5nZUJhbmRzKFswLCB3aWR0aF0pO1xuXG4gICAgICAgIGxldCB5ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgICAgIC5kb21haW4oZDMucmFuZ2UobnVtcm93cykpXG4gICAgICAgIC5yYW5nZUJhbmRzKFswLCBoZWlnaHRdKTtcblxuICAgICAgICBsZXQgY29sb3JNYXAgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5WYWx1ZSxtYXhWYWx1ZV0pXG4gICAgICAgIC5yYW5nZShbc3RhcnRDb2xvciwgZW5kQ29sb3JdKTtcblxuICAgICAgICBsZXQgcm93ID0gc3ZnLnNlbGVjdEFsbChcIi5yb3dcIilcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwicm93XCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyB5KGkpICsgXCIpXCI7IH0pO1xuXG4gICAgICAgIGxldCBjZWxsID0gcm93LnNlbGVjdEFsbChcIi5jZWxsXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNlbGxcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4KGkpICsgXCIsIDApXCI7IH0pO1xuXG4gICAgICAgIGNlbGwuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4LnJhbmdlQmFuZCgpKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5LnJhbmdlQmFuZCgpKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMCk7XG5cbiAgICAgICAgY2VsbC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKVxuICAgICAgICAuYXR0cihcInhcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQgPj0gbWF4VmFsdWUvMiA/ICd3aGl0ZScgOiAnYmxhY2snOyB9KVxuICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkOyB9KTtcblxuICAgICAgICByb3cuc2VsZWN0QWxsKFwiLmNlbGxcIilcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZGF0YVtpXTsgfSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvck1hcCk7XG5cbiAgICAgICAgLy8gdGhpcyBwb3J0aW9uIG9mIHRoZSBjb2RlIGlzbid0IGFzIHJvYnVzdCB0byBzaXppbmcuIGNvbHVtbiBsYWJlbHMgbm90IHJlbmRlcmluZyBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICAgICAgbGV0IGxhYmVscyA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCBcImxhYmVsc1wiKTtcblxuICAgICAgICBsZXQgY29sdW1uTGFiZWxzID0gbGFiZWxzLnNlbGVjdEFsbChcIi5jb2x1bW4tbGFiZWxcIilcbiAgICAgICAgLmRhdGEobGFiZWxzRGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY29sdW1uLWxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAvLyBsZXQgdGVtcCA9IFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLFwiICsgKGhlaWdodCsyMCkgKyBcIilcIjsgLy8gdGhpcyBpbiBwYXJ0aWN1bGFyIGxvb2tzIHRvIGJlIHRoZSBjYXVzZVxuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKHRlbXApO1xuICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4KGkpICsgXCIsXCIgKyAoaGVpZ2h0KzMwKSArIFwiKVwiOyB9KTtcblxuICAgICAgICBjb2x1bW5MYWJlbHMuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxcHhcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCB4LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCB4LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCAwKVxuICAgICAgICAuYXR0cihcInkyXCIsIDUpO1xuXG4gICAgICAgIGNvbHVtbkxhYmVscy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAzMClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIHkucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjIyZW1cIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtNjApXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQ7IH0pO1xuXG4gICAgICAgIGxldCByb3dMYWJlbHMgPSBsYWJlbHMuc2VsZWN0QWxsKFwiLnJvdy1sYWJlbFwiKVxuICAgICAgICAuZGF0YShsYWJlbHNEYXRhKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJyb3ctbGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAwICsgXCIsXCIgKyB5KGkpICsgXCIpXCI7IH0pO1xuXG4gICAgICAgIHJvd0xhYmVscy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKVxuICAgICAgICAuYXR0cihcIngxXCIsIDApXG4gICAgICAgIC5hdHRyKFwieDJcIiwgLTUpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieTJcIiwgeS5yYW5nZUJhbmQoKSAvIDIpO1xuXG4gICAgICAgIHJvd0xhYmVscy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtOClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIHkucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjMyZW1cIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkOyB9KTtcblxuICAgICAgICBsZXQga2V5ID0gZDMuc2VsZWN0KFwiI2NvbmZ1c2lvbmxlZ2VuZFwiKVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGhMZWdlbmQpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKTtcblxuICAgICAgICBsZXQgbGVnZW5kID0ga2V5XG4gICAgICAgIC5hcHBlbmQoXCJkZWZzXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6bGluZWFyR3JhZGllbnRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyYWRpZW50XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgXCIwJVwiKVxuICAgICAgICAuYXR0cihcIngyXCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInkyXCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInNwcmVhZE1ldGhvZFwiLCBcInBhZFwiKTtcblxuICAgICAgICBsZWdlbmRcbiAgICAgICAgLmFwcGVuZChcInN0b3BcIilcbiAgICAgICAgLmF0dHIoXCJvZmZzZXRcIiwgXCIwJVwiKVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZW5kQ29sb3IpXG4gICAgICAgIC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIGxlZ2VuZFxuICAgICAgICAuYXBwZW5kKFwic3RvcFwiKVxuICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIHN0YXJ0Q29sb3IpXG4gICAgICAgIC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIGtleS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGhMZWdlbmQvMi0xMClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwidXJsKCNncmFkaWVudClcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgLy8gdGhpcyB5IGlzIGZvciB0aGUgbGVnZW5kXG4gICAgICAgIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgIC5kb21haW4oW21pblZhbHVlLCBtYXhWYWx1ZV0pO1xuXG4gICAgICAgIGxldCB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJyaWdodFwiKTtcblxuICAgICAgICBrZXlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSg0MSxcIiArIG1hcmdpbi50b3AgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgdGFibGUgZ2VuZXJhdGlvbiBmdW5jdGlvbi4gVXNlZCBmb3IgdGhlIHRhYmxlIG9mIHBlcmZvcm1hbmNlIG1lYXN1cmVzLCBub3QgdGhlIGNvbmZ1c2lvbiBtYXRyaXhcbiAgICBmdW5jdGlvbiB0YWJ1bGF0ZShkYXRhLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLmFwcGVuZChcInRhYmxlXCIpXG4gICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJtYXJnaW4tbGVmdDogXCIgKyBtYXJnaW4ubGVmdCArXCJweFwiKSxcbiAgICAgICAgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKSxcbiAgICAgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0clwiKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAuYXR0cihcInN0eWxlXCIsIFwiZm9udC1mYW1pbHk6IENvdXJpZXJcIikgLy8gc2V0cyB0aGUgZm9udCBzdHlsZVxuICAgICAgICAuaHRtbChmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBjb2RlIGlzIGFsbCBmb3IgcHJvZHVjaW5nIGEgdGFibGUgd2l0aCBwZXJmb3JtYW5jZSBtZWFzdXJlc1xuICAgIC8vdmFyIGNvbmZ1c2lvbk1hdHJpeCA9IFtbMTY5LCAxMF0sWzcsIDQ2XV07XG4gICAgdmFyIHRwID0gbWF0cml4ZGF0YVswXVswXTtcbiAgICB2YXIgZm4gPSBtYXRyaXhkYXRhWzBdWzFdO1xuICAgIHZhciBmcCA9IG1hdHJpeGRhdGFbMV1bMF07XG4gICAgdmFyIHRuID0gbWF0cml4ZGF0YVsxXVsxXTtcblxuICAgIHZhciBwID0gdHAgKyBmbjtcbiAgICB2YXIgbiA9IGZwICsgdG47XG5cbiAgICB2YXIgYWNjdXJhY3kgPSAodHArdG4pLyhwK24pO1xuICAgIHZhciBmMSA9IDIqdHAvKDIqdHArZnArZm4pO1xuICAgIHZhciBwcmVjaXNpb24gPSB0cC8odHArZnApO1xuICAgIHZhciByZWNhbGwgPSB0cC8odHArZm4pO1xuXG4gICAgYWNjdXJhY3kgPSBNYXRoLnJvdW5kKGFjY3VyYWN5ICogMTAwKSAvIDEwMDtcbiAgICBmMSA9IE1hdGgucm91bmQoZjEgKiAxMDApIC8gMTAwO1xuICAgIHByZWNpc2lvbiA9IE1hdGgucm91bmQocHJlY2lzaW9uICogMTAwKSAvIDEwMDtcbiAgICByZWNhbGwgPSBNYXRoLnJvdW5kKHJlY2FsbCAqIDEwMCkgLyAxMDA7XG5cbiAgICB2YXIgY29tcHV0ZWREYXRhID0gW107XG4gICAgY29tcHV0ZWREYXRhLnB1c2goe1wiRjFcIjpmMSwgXCJQUkVDSVNJT05cIjpwcmVjaXNpb24sXCJSRUNBTExcIjpyZWNhbGwsXCJBQ0NVUkFDWVwiOmFjY3VyYWN5fSk7XG5cbiAgICBNYXRyaXgoe1xuICAgICAgICAgICBjb250YWluZXIgOiAnI2NvbmZ1c2lvbmNvbnRhaW5lcicsXG4gICAgICAgICAgIGRhdGEgICAgICA6IG1hdHJpeGRhdGEsXG4gICAgICAgICAgIGxhYmVscyAgICA6IGNsYXNzZXMsXG4gICAgICAgICAgIHN0YXJ0X2NvbG9yIDogJyNmZmZmZmYnLFxuICAgICAgICAgICBlbmRfY29sb3IgOiAnI2U2N2UyMicsXG4gICAgICAgICAgIHdpZHRoIDogbWFpbndpZHRoICogLjE1LFxuICAgICAgICAgICBoZWlnaHQgOiBtYWluaGVpZ2h0ICogLjI1LFxuICAgICAgICAgICB3aWR0aExlZ2VuZCA6IG1haW53aWR0aCouMDVcbiAgICAgICAgICAgfSk7XG5cbiAgICAvLyBub3QgcmVuZGVyaW5nIHRoaXMgdGFibGUgZm9yIHJpZ2h0IG5vdywgbGVmdCBhbGwgdGhlIGNvZGUgaW4gcGxhY2UgdGhvdWdoLiBtYXliZSB3ZSB1c2UgaXQgZXZlbnR1YWxseVxuICAgIC8vIHZhciB0YWJsZSA9IHRhYnVsYXRlKGNvbXB1dGVkRGF0YSwgW1wiRjFcIiwgXCJQUkVDSVNJT05cIixcIlJFQ0FMTFwiLFwiQUNDVVJBQ1lcIl0pO1xufVxuXG4vKipcbiAgIHNjYXR0ZXJwbG90IGZ1bmN0aW9uIHRvIGdvIHRvIHBsb3RzLmpzIHRvIGJlIHJldXNlZFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXZhcmlhdGVQbG90KHhfQXhpcywgeV9BeGlzLCB4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eE1pZGRsZVwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcblxuICAgIGxldCBtYWlud2lkdGggPSBieUlkKCdtYWluJykuY2xpZW50V2lkdGg7XG4gICAgbGV0IG1haW5oZWlnaHQgPSBieUlkKCdtYWluJykuY2xpZW50SGVpZ2h0O1xuXG4gICAgLy8gc2NhdHRlciBwbG90XG4gICAgbGV0IGRhdGFfcGxvdCA9IFtdO1xuICAgIHZhciBuYW5Db3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4X0F4aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKHhfQXhpc1tpXSkgfHwgaXNOYU4oeV9BeGlzW2ldKSkge1xuICAgICAgICAgICAgbmFuQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdOdW1iZXIxID0geF9BeGlzW2ldO1xuICAgICAgICAgICAgdmFyIG5ld051bWJlcjIgPSB5X0F4aXNbaV07XG4gICAgICAgICAgICBkYXRhX3Bsb3QucHVzaCh7eGF4aXM6IG5ld051bWJlcjEsIHlheGlzOiBuZXdOdW1iZXIyLCBzY29yZTogTWF0aC5yYW5kb20oKSAqIDEwMH0pO1xuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzNSwgcmlnaHQ6IDM1LCBib3R0b206IDM1LCBsZWZ0OiAzNX1cbiAgICAsIHdpZHRoID0gbWFpbndpZHRoKi4yNS0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHRcbiAgICAsIGhlaWdodCA9IG1haW53aWR0aCouMjUgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICB2YXIgcGFkZGluZyA9IDEwMDtcblxuICAgIHZhciBtaW5feCA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHZhciBtYXhfeCA9IGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHZhciBhdmdfeCA9IChtYXhfeCAtIG1pbl94KSAvIDEwO1xuICAgIHZhciBtaW5feSA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHZhciBtYXhfeSA9IGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwO1xuXG4gICAgdmFyIHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLmRvbWFpbihbbWluX3ggLSBhdmdfeCwgbWF4X3ggKyBhdmdfeF0pXG4gICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLmRvbWFpbihbbWluX3kgLSBhdmdfeSwgbWF4X3kgKyBhdmdfeV0pXG4gICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAuc2NhbGUoeFNjYWxlKVxuICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgLnRpY2tTaXplKC1oZWlnaHQpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5zY2FsZSh5U2NhbGUpXG4gICAgLm9yaWVudCgnbGVmdCcpXG4gICAgLnRpY2tzKDUpXG4gICAgLnRpY2tTaXplKC13aWR0aCk7XG5cbiAgICB2YXIgem9vbSA9IGQzLmJlaGF2aW9yLnpvb20oKVxuICAgIC54KHhTY2FsZSlcbiAgICAueSh5U2NhbGUpXG4gICAgLnNjYWxlRXh0ZW50KFsxLCAxMF0pXG4gICAgLm9uKFwiem9vbVwiLCB6b29tZWQpO1xuXG4gICAgdmFyIGNoYXJ0X3NjYXR0ZXIgPSBkMy5zZWxlY3QoJyNzZXR4TWlkZGxlJylcbiAgICAuYXBwZW5kKCdzdmc6c3ZnJylcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aCArIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSk7XG4gICAgLy8gLmNhbGwoem9vbSk7IGRyb3BwaW5nIHRoaXMgZm9yIG5vdywgdW50aWwgdGhlIGxpbmUgem9vbXMgcHJvcGVybHlcblxuICAgIHZhciBtYWluMSA9IGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKCdnJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgLmF0dHIoJ2NsYXNzJywgJ21haW4nKTtcblxuICAgIGxldCBnWCA9IG1haW4xLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0ICsgJyknKVxuICAgIC5hdHRyKCdjbGFzcycsICd4IGF4aXMnKVxuICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIGxldCBnWSA9IG1haW4xLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3kgYXhpcycpXG4gICAgLmNhbGwoeUF4aXMpO1xuXG4gICAgdmFyIGNsaXAgPSBtYWluMS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcInN2ZzpjbGlwUGF0aFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG4gICAgLmFwcGVuZChcInN2ZzpyZWN0XCIpXG4gICAgLmF0dHIoXCJpZFwiLCBcImNsaXAtcmVjdFwiKVxuICAgIC5hdHRyKFwieFwiLCBcIjBcIilcbiAgICAuYXR0cihcInlcIiwgXCIwXCIpXG4gICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICBtYWluMS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI2NsaXApXCIpXG4gICAgLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAuYXR0cihcImN4XCIsIChkLCBpKSA9PiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKSlcbiAgICAuYXR0cihcImN5XCIsIChkLCBpKSA9PiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKSlcbiAgICAuYXR0cihcInJcIiwgMilcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKTtcblxuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAvIDUgKyBcIixcIiArIChoZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoIC8gMikgKyBcIixcIiArIChoZWlnaHQgKyAocGFkZGluZyAvIDIpKSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cblxuICAgIG1haW4xLmFwcGVuZChcImxpbmVcIilcbiAgICAuYXR0cihcIngxXCIsIHhTY2FsZShtaW5feCkpXG4gICAgLmF0dHIoXCJ5MVwiLCB5U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKG1heF94KSlcbiAgICAuYXR0cihcInkyXCIsIHlTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuXG4gICAgZnVuY3Rpb24gem9vbWVkKCkge1xuICAgICAgICB2YXIgcGFuWCA9IGQzLmV2ZW50LnRyYW5zbGF0ZVswXTtcbiAgICAgICAgdmFyIHBhblkgPSBkMy5ldmVudC50cmFuc2xhdGVbMV07XG4gICAgICAgIHZhciBzY2FsZSA9IGQzLmV2ZW50LnNjYWxlO1xuXG4gICAgICAgIHBhblggPSBwYW5YID4gMTAgPyAxMCA6IHBhblg7XG4gICAgICAgIHZhciBtYXhYID0gLShzY2FsZSAtIDEpICogd2lkdGggLSAxMDtcbiAgICAgICAgcGFuWCA9IHBhblggPCBtYXhYID8gbWF4WCA6IHBhblg7XG5cbiAgICAgICAgcGFuWSA9IHBhblkgPiAxMCA/IDEwIDogcGFuWTtcbiAgICAgICAgdmFyIG1heFkgPSAtKHNjYWxlIC0gMSkgKiBoZWlnaHQgLSAxMDtcbiAgICAgICAgcGFuWSA9IHBhblkgPCBtYXhZID8gbWF4WSA6IHBhblk7XG5cbiAgICAgICAgem9vbS50cmFuc2xhdGUoW3BhblgsIHBhblldKTtcblxuXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2lyY2xlIHggXCIseFNjYWxlKDUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG5cbiAgICAgICAvLyBiZWxvdyBkb2Vzbid0IHdvcmssIHNvIEknbSBqdXN0IGRyb3BwaW5nIHRoZSB6b29tXG4gICAgICAgIG1haW4xLnNlbGVjdChcImxpbmVcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtaW5feCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUobWF4X3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAyKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuICAgIH1cbiAgICAvLyAgZDMuc2VsZWN0KFwiI05BY291bnRcIikudGV4dChcIlRoZXJlIGFyZSBcIiArIG5hbkNvdW50ICsgXCIgbnVtYmVyIG9mIE5BIHZhbHVlcyBpbiB0aGUgcmVsYXRpb24uXCIpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gc2V0eFRhYmxlKGZlYXR1cmVzKSB7XG4gICAgZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucykge1xuICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoJyNzZXR4UmlnaHRCb3R0b21MZWZ0JykuYXBwZW5kKCd0YWJsZScpO1xuICAgICAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoJ3RoZWFkJyk7XG4gICAgICAgIHZhclx0dGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gICAgICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICAgICAgdmFyIHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoJ3RyJylcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndHInKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KVxuICAgICAgICAgICAgLmF0dHIoJ2lkJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93bmFtZSA9IHRoaXMucGFyZW50RWxlbWVudC5maXJzdENoaWxkLmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93bmFtZSArIGQuY29sdW1uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cblxuXG4gICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGk8ZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoYWxsTm9kZXNbZmluZE5vZGVJbmRleChmZWF0dXJlc1tpXSldLnZhbGlkPT0wKSB7XG4gICAgICAgICAgICB4dmFsPTA7XG4gICAgICAgICAgICB4MXZhbD0wO1xuICAgICAgICAgICAgbXlkYXRhLnB1c2goe1wiVmFyaWFibGVzXCI6ZmVhdHVyZXNbaV0sXCJGcm9tXCI6eHZhbCwgXCJUb1wiOngxdmFsfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBteWkgPSBpKzE7XG4gICAgICAgIGxldCBteXN2ZyA9IGZlYXR1cmVzW2ldK1wiX3NldHhMZWZ0X1wiK215aTtcbiAgICAgICAgbGV0IHh2YWwgPSBieUlkKG15c3ZnKS5xdWVyeVNlbGVjdG9yKCcueHZhbCcpLmlubmVySFRNTDtcbiAgICAgICAgbGV0IHgxdmFsID0gYnlJZChteXN2ZykucXVlcnlTZWxlY3RvcignLngxdmFsJykuaW5uZXJIVE1MO1xuICAgICAgICB4dmFsID0geHZhbC5zcGxpdChcIng6IFwiKS5wb3AoKTtcbiAgICAgICAgeDF2YWwgPSB4MXZhbC5zcGxpdChcIngxOiBcIikucG9wKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHh2YWwpO1xuICAgICAgICBjb25zb2xlLmxvZyhteXN2Zyk7XG5cbiAgICAgICAgbXlkYXRhLnB1c2goe1wiVmFyaWFibGVzXCI6ZmVhdHVyZXNbaV0sXCJGcm9tXCI6eHZhbCwgXCJUb1wiOngxdmFsfSk7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIHRoZSB0YWJsZShzKVxuICAgIHRhYnVsYXRlKG15ZGF0YSwgWydWYXJpYWJsZXMnLCAnRnJvbScsICdUbyddKTsgLy8gMiBjb2x1bW4gdGFibGVcbn1cblxuLyoqXG4gIHJwYyBFeHBvcnRQaXBlbGluZShQaXBlbGluZUV4cG9ydFJlcXVlc3QpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBvcnRwaXBlbGluZShwaXBlbGluZUlkKSB7XG4gICAgY29uc29sZS5sb2cocGlwZWxpbmVJZCk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KFxuICAgICAgICBEM01fU1ZDX1VSTCArICdleHBvcnRwaXBlbGluZScsXG4gICAgICAgIHtwaXBlbGluZUlkLCBjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIHBpcGVsaW5lRXhlY1VyaTogJzw8RVhFQ1VUQUJMRV9VUkk+Pid9KTtcbiAgICByZXMgJiYgY29uc29sZS5sb2coYEV4ZWN1dGFibGUgZm9yICR7cGlwZWxpbmVJZH0gaGFzIGJlZW4gd3JpdHRlbmApO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlcGlwZWxpbmUoKSB7XG4gICAgY29uc29sZS5sb2coXCJERUxFVEUgQ0FMTEVEXCIpO1xufVxuXG4vKipcbiAgIEQzTSBBUEkgSEVMUEVSU1xuICAgYmVjYXVzZSB0aGVzZSBnZXQgYnVpbHQgaW4gdmFyaW91cyBwbGFjZXMsIHB1bGxpbmcgdGhlbSBvdXQgZm9yIGVhc3kgbWFuaXB1bGF0aW9uXG4qL1xuZnVuY3Rpb24gYXBpRmVhdHVyZSAodmFycywgdXJpKSB7XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHtmZWF0dXJlSWQ6dmFyc1tpXSxkYXRhVXJpOnVyaX0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBhcGlGZWF0dXJlU2hvcnRQYXRoICh2YXJzLCB1cmkpIHtcbiAgICBsZXQgb3V0ID0gW107XG4gICAgbGV0IHNob3J0VXJpID0gdXJpLnN1YnN0cmluZygwLCB1cmkubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCh7ZmVhdHVyZUlkOnZhcnNbaV0sZGF0YVVyaTpzaG9ydFVyaX0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAgIHNpbGx5IGJ1dCBwZXJoYXBzIHVzZWZ1bCBpZiBpbiB0aGUgZnV0dXJlIFNlc3Npb25Db250ZXh0IHJlcXVpcmVzIG1vcmUgdGhpbmdzIChhcyBzdWdnZXN0IGJ5IGNvcmUpXG4qL1xuZnVuY3Rpb24gYXBpU2Vzc2lvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtzZXNzaW9uX2lkOiBjb250ZXh0fTtcbn1cblxuXG4vKipcbiAqICBTZW5kIGEgc3RhdHVzIG1lc3NhZ2UgdG8gdGhlIFRBMyBjb25zb2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YTNfc2VhcmNoX21lc3NhZ2UodXNlcl9tc2cpe1xuXG4gIGxldCB0YTNfc2VhcmNoX21lc3NhZ2UgPSB7J21lc3NhZ2UnOiB1c2VyX21zZ31cblxuICBjb25zdCBlbmRfc2VhcmNoX3VybCA9ICd0YTMtc2VhcmNoL3NlbmQtcmV2aWV3ZXItbWVzc2FnZSc7XG5cbiAgdHJ5IHtcbiAgICAgIGxldCByZXMgPSBtLnJlcXVlc3QoZW5kX3NlYXJjaF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHttZXRob2Q6ICdQT1NUJywgZGF0YTogdGEzX3NlYXJjaF9tZXNzYWdlfSk7XG4gICAgICBjb25zb2xlLmxvZygndGEzX3NlYXJjaF9tZXNzYWdlIHN1Y2NlZWRlZDonICsgcmVzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZygndGEzX3NlYXJjaF9tZXNzYWdlIGZhaWxlZDogJyArIGVycik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RfbXNnX3RhM19zZWFyY2goKXtcbiAgLy9lbmRfdGEzX3NlYXJjaCh0cnVlLCAnaXQgd29ya2VkIScpO1xuICAvL2VuZF90YTNfc2VhcmNoKGZhbHNlLCAnaXQgZmFpbGVkIScpO1xuICAvL3RhM19zZWFyY2hfbWVzc2FnZSgnanVzdCBzZW5kaW5nIGEgbWVzc2FnZSEnKTtcbn1cblxuLyoqXG4gKiAgRW5kIHRoZSBUQTMgc2VhcmNoLiAgVGhpcyBzZW5kcyBhIG1lc3NhZ2VcbiAqICB0byB0aGUgdGEzX3NlYXJjaCBjb25zb2xlIGFzIHdlbGwgYXMgbWVzc2FnZVxuICogIGZvciB0aGUgY29uc29sZSB0byBleGl0IHdpdGggYTpcbiAqICAtIHJldHVybiBjb2RlIDAgZm9yIHN1Y2Nlc3NcbiAqICAtIHJldHVybiBjb2RlIC0xIGZvciBmYWlsdXJlXG4gKlxuICogID4gaXNfc3VjY2VzcyAtIGJvb2xlYW5cbiAqICA+IHVzZXJfbXNnIC0gc3RyaW5nIHNlbnQgdG8gdGhlIGNvbnNvbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF90YTNfc2VhcmNoKGlzX3N1Y2Nlc3MsIHVzZXJfbXNnKXtcblxuICBsZXQgZW5kX3NlYXJjaF9tc2cgPSB7J2lzX3N1Y2Nlc3MnOiBpc19zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiB1c2VyX21zZ31cblxuICBjb25zdCBlbmRfc2VhcmNoX3VybCA9ICd0YTMtc2VhcmNoL2VuZC1zZWFyY2gnO1xuXG4gIHRyeSB7XG4gICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KGVuZF9zZWFyY2hfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IGVuZF9zZWFyY2hfbXNnfSk7XG4gICAgICBjb25zb2xlLmxvZygnZW5kX3RhM19zZWFyY2ggc3VjY2VlZGVkOicgKyByZXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdlbmRfdGEzX3NlYXJjaCBmYWlsZWQ6ICcgKyBlcnIpO1xuICB9XG5cbn1cblxuLyoqXG4gKiAgcmVjb3JkIHVzZXIgbWV0YWRhdGFcbiAqL1xubGV0IHJlY29yZGVyX2NudCA9IDA7XG5jb25zdCBzYXZlX3dvcmtzcGFjZV91cmwgPSAnL3dvcmtzcGFjZXMvcmVjb3JkLXVzZXItd29ya3NwYWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZF91c2VyX21ldGFkYXRhKCl7XG5cbiAgLy8gKDEpIFNldCBkb21haW4gaWRlbnRpZmllcjogZGlmZmVycyBmb3IgRDNNLCBEYXRhdmVyc2UsIGV0Y1xuICAvL1xuICB2YXIgZG9tYWluX2lkZW50aWZpZXIgPSAndW5rbm93biEnO1xuICBpZiAoSVNfRDNNX0RPTUFJTil7IC8vIGRvbWFpbiBzcGVjaWZpYyBpZGVudGlmaWVyXG4gICAgZG9tYWluX2lkZW50aWZpZXIgPSBkb21haW5JZGVudGlmaWVyO1xuICB9LyplbHNlIGlmIChJU19EQVRBVkVSU0VfRE9NQUlOKXtcbiAgICBkb21haW5faWRlbnRpZmllciA9ICdUT0RPOiBEViBJREVOVElGSUVSJztcbiAgfWVsc2UgaWYgKElTX0VWRU5UREFUQV9ET01BSU4pe1xuICAgIGRvbWFpbl9pZGVudGlmaWVyID0gJ1RPRE86IEVWRU5UREFUQSBJREVOVElGSUVSJztcbiAgfSovXG5cbiAgaWYgKHpwYXJhbXMgPT0gbnVsbCl7XG4gICAgY29uc29sZS5sb2coJ05vIHdvcmtzcGFjZSByZWNvcmRpbmcuIHpwYXJhbXMgbm90IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFsbE5vZGVzID09IG51bGwpe1xuICAgIGNvbnNvbGUubG9nKCdObyB3b3Jrc3BhY2UgcmVjb3JkaW5nLiB6cGFyYW1zIG5vdCBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gKDIpIEZvcm1hdCB3b3Jrc3BhY2UgZGF0YVxuICAvL1xuICBsZXQgd29ya3NwYWNlX2RhdGEgPSB7J2FwcF9kb21haW4nOiBBUFBfRE9NQUlOLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RvbWFpbl9pZGVudGlmaWVyJzogZG9tYWluX2lkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWxsbm9kZXMnOiBhbGxOb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6cGFyYW1zJzogenBhcmFtc31cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCd3b3Jrc3BhY2VfZGF0YTogJyArIHdvcmtzcGFjZV9kYXRhKTtcblxuICAgICAgLy8gKDMpIFNhdmUgd29ya3NwYWNlIGRhdGFcbiAgICAgIC8vXG4gICAgICB0cnkge1xuICAgICAgICAgIGxldCByZXMgPSBtLnJlcXVlc3Qoc2F2ZV93b3Jrc3BhY2VfdXJsLCB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IHdvcmtzcGFjZV9kYXRhfSk7XG4gICAgICAgICAgcmVjb3JkZXJfY250Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gcmVjb3JkZWQ6IChjbnQ6ICcgKyByZWNvcmRlcl9jbnQgKyAnKSAnICsgcmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNvcmRfdXNlcl9tZXRhZGF0YSBmYWlsZWQ6ICcgKyBlcnIpO1xuICAgICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFzc2V0cy9hcHAvYXBwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBa3VCQTtBQTR4REE7QUFZQTtBQTBDQTtBQXlCQTtBQU9BO0FBV0E7QUFZQTtBQWtDQTtBQXlMQTtBQVdBO0FBZ0hBO0FBbVRBO0FBb0NBO0FBUUE7QUFVQTtBQWFBO0FBbUZBO0FBeUpBO0FBc0JBO0FBMExBO0FBYUE7QUFXQTtBQVdBO0FBb0RBO0FBbUdBO0FBSUE7QUE2Q0E7QUFzQkE7QUFvREE7QUF3UkE7QUEwTEE7QUFrRUE7QUFTQTtBQXFDQTtBQWVBO0FBZ0JBO0FBdUJBO0FBQ0E7QUFqcUpBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFOQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFGQTtBQVpBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFGQTtBQVpBO0FBbUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUF0REE7QUE4REE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFGQTtBQVpBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFGQTtBQVpBO0FBbUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUF0REE7QUErREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBc0JBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFBQTtBQUNBO0FBa0NBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBV0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFGQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQVdBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFGQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7OztBQVFBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQXFCQTtBQUdBO0FBQ0E7QUF4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUlBO0FBQUE7QUFKQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFTQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQVFBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFTQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!*****************************!*\
  !*** ./assets/app/plots.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = '#1f77b4'; // d3's default blue\nvar selVarColor = exports.selVarColor = '#fa8072'; // d3.rgb(\"salmon\");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: '#tab2', setxLeft: '#setxLeft', varSummary: '#tab3' }[div];\n    if (!div) return alert(\"Error: incorrect div selected for plots\");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = ['upperBound', 'lowerBound'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log('upperError\\n', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style(\"width\");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tw = document.getElementById('main').offsetWidth;\n\n    var tempHeight = d3.select(div).style(\"height\");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == \"#tab3\") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == \"#tab2\") {\n        width = 200;\n        height = 120;\n    } else if (div == \"#setxLeft\") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it's all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient(\"bottom\");\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on(\"brush\", brushed);\n    var brush2 = d3.svg.brush().x(x).on(\"brush\", brushed2);\n    var area = d3.svg.area().interpolate(\"monotone\").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate(\"monotone\");\n\n    // cumbersome to treat \"tab3\" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == \"#tab3\") {\n        var plotsvg = d3.select(div).selectAll(\"svg\").remove();\n        plotsvg = d3.select(div).append(\"svg\").attr(\"id\", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style(\"width\", 300) // set height to the height of #main.left\n        .style(\"height\", 200).append(\"g\").attr(\"transform\", 'translate(' + margin.left + ',' + margin.top + ')');\n    } else {\n        var plotsvg = d3.select(div).append(\"svg\").attr(\"id\", function () {\n            return node.name.toString().replace(/\\(|\\)/g, \"\").concat(\"_\", div.substr(1), \"_\", node.id);\n        }).style(\"width\", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", 'translate(' + margin.left + ',' + margin.top + ')');\n    };\n    plotsvg.append(\"path\").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr(\"class\", \"area\").attr(\"d\", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append(\"path\").attr(\"class\", \"upperError\").datum(upperError).attr(\"d\", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append(\"path\").attr(\"class\", \"lowerError\").datum(lowerError).attr(\"d\", area);\n\n    plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(node.name);\n\n    // add brush if subset\n    if (div == \"#tab2\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            return \"Range: \".concat(d3.min(xVals).toPrecision(4), \" to \", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append(\"g\").attr(\"class\", \"x brush\").call(brush).selectAll(\"rect\").attr(\"height\", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == \"#setxLeft\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\") // this is bad practice, id is not unique\n        .attr('class', 'xval').attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            return \"x: \".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append(\"text\").attr(\"id\", \"range2\") // this is bad practice, id is not unique\n        .attr('class', 'x1val').attr(\"x\", 25).attr(\"y\", height + 50).text(function (_) {\n            var returnval = \"x1: \".concat((+node.mean).toPrecision(4));\n            return returnval;\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate(\"linear\");\n\n        var colSeq = [\"#A2CD5A\", \"orange\", \"red\"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height * .8 + \")\").call(d3.svg.axis().scale(x).ticks(0).orient(\"bottom\"));\n        var slider = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush);\n        var handle = slider.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .7 + \")\").attr(\"points\", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == '' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + \",\" + -s + \" \" + (xnm + s) + \",\" + -s + \" \" + xnm + \",\" + s * 1.3;\n        });\n        var slider2 = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush2);\n        var handle2 = slider2.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .9 + \")\").attr(\"points\", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == '' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + \",\" + s + \" \" + (xnm + s) + \",\" + s + \" \" + xnm + \",\" + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == \"#tab2\") {\n            plotsvg.select(\"text#range\").text(function () {\n                return brush.empty() ? \"Range: \".concat(d3.min(xVals).toPrecision(4), \" to \", d3.max(xVals).toPrecision(4)) : \"Range: \".concat(brush.extent()[0].toPrecision(4), \" to \", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : [\"\", \"\"];\n        } else if (div == \"#setxLeft\") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr(\"points\", function (_) {\n                return xpos - s + \",\" + -s + \" \" + (xpos + s) + \",\" + -s + \" \" + xpos + \",\" + s * 1.3;\n            });\n            plotsvg.select(\"text#range\").text(function (_) {\n                var returnval = \"x: \".concat(invx(xpos).toPrecision(4));\n                var xval = invx(xpos).toPrecision(4);\n                var mycell = node.name + \"From\"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = xval;\n                }\n                return returnval;\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it's basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr(\"points\", function (_) {\n            return xpos - s + \",\" + s + \" \" + (xpos + s) + \",\" + s + \" \" + xpos + \",\" + -s * 1.3;\n        });\n        plotsvg.select(\"text#range2\").text(function (_) {\n            var returnval = \"x1: \".concat(invx(xpos).toPrecision(4));\n            var x1val = invx(xpos).toPrecision(4);\n            var mycell = node.name + \"To\"; // hardcoded here\n            if (document.getElementById(mycell)) {\n                document.getElementById(mycell).innerText = x1val;\n            }\n            return returnval;\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == \"nominal\") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            // console.log(\"plotvalues in bars\");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == \"numeric\" || yVals.length > 5 & node.numchar == \"character\") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == \"setxLeft\") mydiv = \"#setxLeft\";else if (div == \"varSummary\") mydiv = \"#tab3\";else return alert(\"Error: incorrect div selected for plots\");\n\n    var tempWidth = d3.select(mydiv).style(\"width\");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style(\"height\");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById('main').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == \"#tab3\") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == \"#setxLeft\") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it's all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient(\"bottom\");\n\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on(\"brush\", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on(\"brush\", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat \"tab3\" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == \"#tab3\") {\n        var plotsvg = d3.select(mydiv).selectAll(\"svg\").remove();\n\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style(\"width\", 300) //setting height to the height of #main.left\n        .style(\"height\", 200).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    } else {\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, \"\");\n            return myname.concat(\"_\", mydiv.substr(1), \"_\", node.id);\n        }).style(\"width\", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the \"width\" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll(\"rect\").data(yVals).enter().append(\"rect\").attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(maxY - d);\n    }).attr(\"width\", rectWidth).attr(\"height\", y).attr(\"fill\", \"#1f77b4\");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll(\"line\").data(ciUpperVals).enter().append(\"line\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr(\"y2\", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(\".topTick\").data(ciUpperVals).enter().append(\"line\").attr(\"class\", \"topTick\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr(\"y2\", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(\".bottomTick\").data(ciLowerVals).enter().append(\"line\").attr(\"class\", \"bottomTick\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr(\"y2\", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(\".denseError\").data(yVals).enter().append(\"rect\").attr(\"class\", \"denseError\").attr(\"x\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr(\"y\", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr(\"width\", rectWidth).attr(\"height\", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr(\"fill\", \"silver\");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append(\"rect\").attr(\"x\", x(maxX + 0.5 - barPadding)).attr(\"y\", y(maxY) - node.stabilityBin).attr(\"width\", rectWidth).attr(\"height\", node.stabilityBin).attr(\"fill\", \"silver\");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append(\"line\").style(\"stroke\", \"black\").attr(\"x1\", x(minX - 0.5 + barPadding)).attr(\"y1\", y(maxY) - node.threshold).attr(\"x2\", function () {\n                console.log(\"stabilityBin\");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr(\"y2\", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n    }\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(node.name);\n\n    if (mydiv == \"#setxLeft\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\") // bad practice, not unique\n        .attr('class', 'xval').attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            if (node.nature === \"nominal\") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                var mycell = node.name + \"From\"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[t].x;\n                }\n                return \"x: \" + yValKey[t].x;\n            } else {\n                var _mycell = node.name + \"From\"; // hardcoded here\n                if (document.getElementById(_mycell)) {\n                    document.getElementById(_mycell).innerText = (+node.mean).toPrecision(4).toString();\n                }\n                return \"x: \".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append(\"text\").attr(\"id\", \"range2\") //bad practice, not unique\n        .attr('class', 'x1val').attr(\"x\", 25).attr(\"y\", height + 50).text(function () {\n            if (node.nature === \"nominal\") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return \"x1: \" + yValKey[t].x;\n            } else {\n                return \"x1: \".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate(\"linear\");\n\n        var colSeq = [\"#A2CD5A\", \"orange\", \"red\"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                \"x\": x(i),\n                \"y\": height * .75\n            }, {\n                \"x\": x(i),\n                \"y\": height * .85\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", \"black\").attr(\"stroke-width\", 1).attr(\"fill\", \"none\");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height * .8 + \")\").call(d3.svg.axis().scale(x).ticks(0).orient(\"bottom\"));\n\n        var slider = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush);\n        var slider2 = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == '') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == 'nominal' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + ',' + -s + ' ' + (xnm + s) + ',' + -s + ' ' + xnm + ',' + s * 1.3;\n            };\n        };\n        var handle = slider.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .7 + \")\").attr(\"points\", points(0));\n        var handle2 = slider2.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .9 + \")\").attr(\"points\", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(\".2r\"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, \"\").replace(/\\.$/, \"\"); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr(\"points\", function (d) {\n            return xpos - s + \",\" + -s + \" \" + (xpos + s) + \",\" + -s + \" \" + xpos + \",\" + s * 1.3;\n        });\n        plotsvg.select(\"text#range\").text(function () {\n            if (node.nature === \"nominal\") {\n                var mycell = node.name + \"From\"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return \"x: \" + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell2 = node.name + \"From\"; // hardcoded here\n                if (document.getElementById(_mycell2)) {\n                    document.getElementById(_mycell2).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return \"x: \".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it's basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr(\"points\", function (d) {\n            return xpos - s + \",\" + s + \" \" + (xpos + s) + \",\" + s + \" \" + xpos + \",\" + -s * 1.3;\n        });\n        plotsvg.select(\"text#range2\").text(function () {\n            if (node.nature === \"nominal\") {\n                var mycell = node.name + \"To\"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return \"x1: \" + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell3 = node.name + \"To\"; // hardcoded here\n                if (document.getElementById(_mycell3)) {\n                    document.getElementById(_mycell3).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return \"x1: \".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == \"\" & node.subsetrange[1] == \"\") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, \"\");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === \"nominal\") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = [\"subsetyes\", \"subsetno\"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: \"transparent\"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = \"#tab2\";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient(\"bottom\");\n\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n        return myname.concat(\"_\", mydiv.substr(1), \"_\", node.id);\n    }).style(\"width\", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    var freq = plotsvg.selectAll(\"g.freq\").data(freqs).enter().append(\"g\").attr(\"class\", \"freq\").attr(\"name\", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll(\"rect\").data(Object).enter().append(\"rect\").attr(\"class\", \"bar\").attr(\"name\", function (d, i) {\n        return xVals[i];\n    }).attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(d.y0);\n    }).attr(\"width\", x(minX + 0.5 - 2 * barPadding)) // the \"width\" is the coordinate of the end of the first bar\n    .attr(\"height\", function (d) {\n        return y(d.y1);\n    }).style(\"fill\", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on(\"click\", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute(\"name\");\n        if (this.parentNode.getAttribute(\"name\") == myname.concat(\"subsetno\")) {\n            selectMe = $('[name=\"' + myname.concat(\"subsetyes\") + '\"]').children('[name=\"' + selectName + '\"]')[0];\n        }\n        d3.select(selectMe).style(\"fill\", function (d, i) {\n            var myCol = \"\";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute(\"name\"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute(\"name\"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select(\"text#selectrange\").text(function () {\n            if (node.subsetrange.length == 0) {\n                return \"Selected: all values\";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return \"Selected: \" + selecteds;\n            }\n        });\n    }).on(\"mouseover\", function () {\n        var i = this.getAttribute(\"name\");\n        plotsvg.select(\"text#mymouseover\").text(function () {\n            return yValKey[i].x + \": \" + yValKey[i].y;\n        });\n    }).on(\"mouseout\", function () {\n        var i = this.getAttribute(\"name\");\n        plotsvg.select(\"text#mymouseover\").text(function () {\n            return \"Value: Frequency\";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n    } else {\n        plotsvg.append(\"text\").attr(\"id\", \"mymouseover\").attr(\"x\", 25).attr(\"y\", height + 20).text(function () {\n            return \"Value: Frequency\";\n        });\n    }\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(myname);\n\n    plotsvg.append(\"text\").attr(\"id\", \"selectrange\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return \"Selected: all values\";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return \"Selected: \" + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat(\"nodeplot\");\n\n    if (typeof obj === \"undefined\") {\n        var obj = document.getElementById(node.name.toString() + \"biggroup\");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll(\"svg\")[0].length > 0) d3.select(obj).selectAll(\"svg\").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate(\"monotone\").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert(\"svg\", \":first-child\").attr(\"x\", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn't be hardcoded in the future\n    .attr(\"y\", -45).attr(\"id\", function () {\n        return myname;\n    }).style(\"width\", width).style(\"height\", height).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    plotsvg.append(\"path\").datum(data2).attr(\"class\", \"area\").attr(\"d\", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat(\"nodeplot\");\n\n    if (typeof obj === \"undefined\") {\n        var obj = document.getElementById(node.name.toString() + \"biggroup\");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll(\"svg\")[0].length > 0) {\n            d3.select(obj).selectAll(\"svg\").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === \"nominal\") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert(\"svg\", \":first-child\").attr(\"x\", -40).attr(\"y\", -45).attr(\"id\", function () {\n        return myname;\n    }).style(\"width\", width) // set height to the height of #main.left\n    .style(\"height\", height).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    plotsvg.selectAll(\"rect\").data(yVals).enter().append(\"rect\").attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(maxY - d);\n    }).attr(\"width\", x(minX + 0.5 - 2 * barPadding)) // the \"width\" is the coordinate of the end of the first bar\n    .attr(\"height\", y).attr(\"fill\", \"#1f77b4\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3Bsb3RzLmpzPzM4M2IiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGQzQ29sb3IgPSAnIzFmNzdiNCc7IC8vIGQzJ3MgZGVmYXVsdCBibHVlXG5leHBvcnQgbGV0IHNlbFZhckNvbG9yID0gJyNmYTgwNzInOyAvLyBkMy5yZ2IoXCJzYWxtb25cIik7XG5cbi8vIGZ1bmN0aW9uIHRvIHVzZSBkMyB0byBncmFwaCBkZW5zaXR5IHBsb3RzIHdpdGggcHJlcHJvY2Vzc2VkIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5KG5vZGUsIGRpdiwgcHJpdikge1xuICAgIGRpdiA9IHtzdWJzZXQ6ICcjdGFiMicsIHNldHhMZWZ0OiAnI3NldHhMZWZ0JywgdmFyU3VtbWFyeTogJyN0YWIzJ31bZGl2XTtcbiAgICBpZiAoIWRpdilcbiAgICAgICAgcmV0dXJuIGFsZXJ0KFwiRXJyb3I6IGluY29ycmVjdCBkaXYgc2VsZWN0ZWQgZm9yIHBsb3RzXCIpO1xuXG4gICAgbGV0IFt4VmFscywgeVZhbHNdID0gW25vZGUucGxvdHgsIG5vZGUucGxvdHldO1xuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdENJKSB7XG4gICAgICAgIGxldCBbdXBwZXJFcnJvciwgbG93ZXJFcnJvcl0gPSBbJ3VwcGVyQm91bmQnLCAnbG93ZXJCb3VuZCddLm1hcChcbiAgICAgICAgICAgIGJvdW5kID0+IHhWYWxzLm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdENJW2JvdW5kXVtpXX0pKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd1cHBlckVycm9yXFxuJywgdXBwZXJFcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChkaXYpLnN0eWxlKFwid2lkdGhcIik7XG4gICAgdmFyIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCAodGVtcFdpZHRoLmxlbmd0aCAtIDIpKTtcbiAgICBcbiAgICBsZXQgdHcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLm9mZnNldFdpZHRoO1xuICAgIFxuICAgIHZhciB0ZW1wSGVpZ2h0ID0gZDMuc2VsZWN0KGRpdikuc3R5bGUoXCJoZWlnaHRcIik7XG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDEwXG4gICAgfTtcblxuICAgIC8vIE5lZWQgdG8gZml4IGF1dG9tYXRpYyB3aWR0aCBhbmQgaGVpZ2h0IHNldHRpbmdzIGZvciBsZWZ0cGFuZWwgKCN0YWIyLCAjdGFiMylcbiAgICBpZiAoZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKGRpdiA9PSBcIiN0YWIyXCIpIHtcbiAgICAgICAgd2lkdGggPSAyMDA7XG4gICAgICAgIGhlaWdodCA9IDEyMDtcbiAgICB9IGVsc2UgaWYgKGRpdiA9PSBcIiNzZXR4TGVmdFwiKSB7XG4gICAgICAgIHdpZHRoPXR3Ki4xODUtbWFyZ2luLmxlZnQtbWFyZ2luLnJpZ2h0OyAvL3JpZ2h0cGFuZWwuZXhwYW5kIGlzIDQwIHBlcmNlbnQsIHNldHhMZWZ0IHRvIDUwIHBlcmNlbnQsIHRvZ2dsZSBiYXIgaXMgMTZweCwgcGFkZGluZywgaXQncyBhbGwgYWJvdXQgLjE4NVxuICAgICAgICBoZWlnaHQ9d2lkdGgqLjY7IC8vaGVpZ2h0IHRvIHdpZHRoIGlzIC42XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwLjM1ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLFxuICAgICAgICBoZWlnaHQgPSAwLjI1ICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyg1KVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5leHRlbnQobm9kZS5zdWJzZXRyYW5nZSlcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG4gICAgdmFyIGJydXNoMiA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQyKTtcbiAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIilcbiAgICAgICAgLngoZCA9PiB4KGQueCkpXG4gICAgICAgIC55MChoZWlnaHQpXG4gICAgICAgIC55MShkID0+IHkoZC55KSk7XG4gICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueShkID0+IHkoZC55KSlcbiAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIik7XG5cbiAgICAvLyBjdW1iZXJzb21lIHRvIHRyZWF0IFwidGFiM1wiIGRpZmZlcmVudGx5LCBidXQgd29ya3MgZm9yIG5vd1xuICAgIC8vIHRhYjMsIGhhcyBhbiBpc3N1ZSwgdGhhdCB1bmxlc3Mgd2lkdGggaGVpZ2h0IGhhcmRjb2RlZCwgdGhleSBncm93IHdpdGggZWFjaCBhZGRpdGlvbmFsIGdyYXBoLlxuICAgIGlmIChkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChkaXYuc3Vic3RyKDEpKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIDMwMCkgLy8gc2V0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCAyMDApXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KFwiX1wiLCBkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgKTtcbiAgICB9O1xuICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuZGF0dW0oeFZhbHMubWFwKCh4LCBpKSA9PiAoe3g6ICt4LCB5OiArbm9kZS5wbG90eVtpXX0pKSlcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgLy9hZGQgdXBwZXIgYm91bmRcbiAgICBwcml2ICYmIG5vZGUucGxvdENJICYmIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidXBwZXJFcnJvclwiKVxuICAgICAgICAuZGF0dW0odXBwZXJFcnJvcilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgLy9hZGQgbG93ZXIgYm91bmRcbiAgICBwcml2ICYmIG5vZGUucGxvdENJICYmIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibG93ZXJFcnJvclwiKVxuICAgICAgICAuZGF0dW0obG93ZXJFcnJvcilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuXG4gICAgLy8gYWRkIGJydXNoIGlmIHN1YnNldFxuICAgIGlmIChkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIlJhbmdlOiBcIi5jb25jYXQoZDMubWluKHhWYWxzKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIGQzLm1heCh4VmFscykudG9QcmVjaXNpb24oNCkpKTtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBicnVzaFwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgeiBsaW5lcyBhbmQgc2xpZGVycyBzZXR4XG4gICAgaWYgKGRpdiA9PSBcIiNzZXR4TGVmdFwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpIC8vIHRoaXMgaXMgYmFkIHByYWN0aWNlLCBpZCBpcyBub3QgdW5pcXVlXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCd4dmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwieDogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KSkpO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKSAvLyB0aGlzIGlzIGJhZCBwcmFjdGljZSwgaWQgaXMgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneDF2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoIF8gPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbCA9IFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybnZhbH0pO1xuICAgICAgICBcblxuICAgICAgICAvLyBjcmVhdGUgdGljayBtYXJrcyBhdCBhbGwgenNjb3JlcyBpbiB0aGUgYm91bmRzIG9mIHRoZSBkYXRhXG4gICAgICAgIHZhciBsaW5lRnVuY3Rpb24gPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChkID0+IGQueClcbiAgICAgICAgICAgIC55KGQgPT4gZC55KVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibGluZWFyXCIpO1xuXG4gICAgICAgIHZhciBjb2xTZXEgPSBbXCIjQTJDRDVBXCIsIFwib3JhbmdlXCIsIFwicmVkXCJdOyAvLyB3aWxsIGN5Y2xlIHRocm91Z2ggY29sb3Igc2VxdWVuY2UsIGFuZCB0aGVuIHJlcGVhdCBsYXN0IGNvbG9yXG4gICAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBBcnJheTtcblxuICAgICAgICB2YXIgekxvd2VyID0gLTEgKiAoZDMubWluKHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIHpVcHBlciA9IChkMy5tYXgoeFZhbHMpIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiB1cHBlciBib3VuZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgelVwcGVyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB6TG93ZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgIC50aWNrcygwKVxuICAgICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSk7XG4gICAgICAgIHZhciBzbGlkZXIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHNsaWRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjcgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1swXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4bm0gKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgc2xpZGVyMiA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gyKTtcbiAgICAgICAgdmFyIGhhbmRsZTIgPSBzbGlkZXIyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOSArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgXyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSA2O1xuICAgICAgICAgICAgICAgIGxldCB4bm0gPSBub2RlLnNldHh2YWxzWzFdID09ICcnID8geChub2RlLm1lYW4pIDogeChub2RlLnNldHh2YWxzWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhubSAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeG5tICsgcykgKyBcIixcIiArIHMgKyBcIiBcIiArIHhubSArIFwiLFwiICsgKC1zICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGJydXNoaW5nIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGJydXNoZWQoKSB7XG4gICAgICAgIGlmIChkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBicnVzaC5lbXB0eSgpID9cbiAgICAgICAgICAgICAgICAgICAgXCJSYW5nZTogXCIuY29uY2F0KGQzLm1pbih4VmFscykudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCBkMy5tYXgoeFZhbHMpLnRvUHJlY2lzaW9uKDQpKSA6XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdCgoYnJ1c2guZXh0ZW50KClbMF0pLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgKGJydXNoLmV4dGVudCgpWzFdKS50b1ByZWNpc2lvbig0KSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZSA9IGJydXNoLmV4dGVudCgpWzBdLnRvUHJlY2lzaW9uKDQpICE9IGJydXNoLmV4dGVudCgpWzFdLnRvUHJlY2lzaW9uKDQpID9cbiAgICAgICAgICAgICAgICBbKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgKGJydXNoLmV4dGVudCgpWzFdKS50b1ByZWNpc2lvbig0KV0gOlxuICAgICAgICAgICAgICAgIFtcIlwiLCBcIlwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgICAgICB2YXIgcyA9IDY7XG4gICAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgICAgICBicnVzaC5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgZDMubWluKHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAocyAqIDEuMykpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAudGV4dChfID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIng6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICAgICAgbGV0IHh2YWwgPSBpbnZ4KHhwb3MpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgICAgIG5vZGUuc2V0eHZhbHNbMF0gPSAoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjZXJ0YWlubHkgYSBtb3JlIGNsZXZlciB3YXkgdG8gZG8gdGhpcywgYnV0IGZvciBub3cgaXQncyBiYXNpY2FsbHkgY29waWVkIHdpdGggYnJ1c2ggYW5kIGhhbmRsZSBjaGFuZ2VzIHRvIGJydXNoMiBhbmQgaGFuZGxlMiBhbmQgI3JhbmdlIHRvICNyYW5nZTIgYW5kIHNldHh2YWxzWzBdIHRvIHNldHh2YWxzWzFdXG4gICAgZnVuY3Rpb24gYnJ1c2hlZDIoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoMi5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2OyAvLyBzY2FsaW5nIGZvciB0cmlhbmdsZSBzaGFwZVxuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaDIuZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUyLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpKTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAudGV4dChfID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJldHVybnZhbCA9IFwieDE6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICBsZXQgeDF2YWwgPSBpbnZ4KHhwb3MpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXgxdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9IChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhcnMobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpVXBwZXJWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaUxvd2VyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lTaXplO1xuXG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgaWYgKG5vZGUubmF0dXJlID09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1t4aV0gLSBjaUxvd2VyVmFsc1t4aV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgICAgIHk6IHlWYWxzW3hpXSxcbiAgICAgICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHhpID0geGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHlWYWxLZXkuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgIHlWYWxzLnNvcnQoKGEsIGIpID0+IGIgLSBhKTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgY2lVcHBlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgICAgICBjaUxvd2VyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicGxvdHZhbHVlcyBpbiBiYXJzXCIpO1xuICAgICAgICAgICAgeVZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcml2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1tpXSAtIGNpTG93ZXJWYWxzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCh5VmFscy5sZW5ndGggPiAxNSAmIG5vZGUubnVtY2hhciA9PSBcIm51bWVyaWNcIikgfHwgKHlWYWxzLmxlbmd0aCA+IDUgJiBub2RlLm51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikpXG4gICAgICAgIHBsb3RYYXhpcyA9IGZhbHNlO1xuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTsgLy8gaW4gdGhlIGZ1dHVyZSwgc2V0IG1heFkgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXhpbXVtIGNvbmZpZGVuY2UgbGltaXRcbiAgICBpZiAocHJpdiAmJiBub2RlLnBsb3R2YWx1ZXNDSSkgbWF4WSA9IGQzLm1heChjaVVwcGVyVmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcblxuICAgIGxldCBteWRpdjtcbiAgICBpZiAoZGl2ID09IFwic2V0eExlZnRcIikgbXlkaXYgPSBcIiNzZXR4TGVmdFwiO1xuICAgIGVsc2UgaWYgKGRpdiA9PSBcInZhclN1bW1hcnlcIikgbXlkaXYgPSBcIiN0YWIzXCI7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG5cbiAgICB2YXIgdGVtcFdpZHRoID0gZDMuc2VsZWN0KG15ZGl2KS5zdHlsZShcIndpZHRoXCIpXG4gICAgdmFyIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCAodGVtcFdpZHRoLmxlbmd0aCAtIDIpKTtcbiAgICB2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJoZWlnaHRcIilcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG4gICAgbGV0IHR3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5vZmZzZXRXaWR0aDtcblxuICAgIC8vIE5lZWQgdG8gZml4IGF1dG9tYXRpYyB3aWR0aCBhbmQgaGVpZ2h0IHNldHRpbmdzIGZvciBsZWZ0cGFuZWwgKCN0YWIyLCAjdGFiMylcbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgICAgICBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAobXlkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICAvL3dpZHRoID0gMjAwO1xuICAgICAgICAvL2hlaWdodCA9IDEyMDtcbiAgICAgICAgd2lkdGg9dHcqLjE4NS1tYXJnaW4ubGVmdC1tYXJnaW4ucmlnaHQ7IC8vcmlnaHRwYW5lbC5leHBhbmQgaXMgNDAgcGVyY2VudCwgc2V0eExlZnQgdG8gNTAgcGVyY2VudCwgdG9nZ2xlIGJhciBpcyAxNnB4LCBwYWRkaW5nLCBpdCdzIGFsbCBhYm91dCAuMTg1XG4gICAgICAgIGhlaWdodD13aWR0aCouNjsgLy9oZWlnaHQgdG8gd2lkdGggaXMgLjZcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IDAuMzUgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCk7XG4gICAgICAgIGhlaWdodCA9IDAuMjUgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH07XG5cbiAgICBpZiAocHJpdiAmJiBub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMS41XSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB9XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKHlWYWxzLmxlbmd0aClcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLmV4dGVudCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMSA/XG4gICAgICAgICAgICAgICAgW25vZGUuc3Vic2V0cmFuZ2VbMF0sIG5vZGUuc3Vic2V0cmFuZ2VbMF1dXG4gICAgICAgICAgICAgICAgOiBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkKTtcblxuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG5cbiAgICAvLyBDcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICAvLyBjdW1iZXJzb21lIHRvIHRyZWF0IFwidGFiM1wiIGRpZmZlcmVudGx5LCBidXQgd29ya3MgZm9yIG5vd1xuICAgIC8vIHRhYjMsIGhhcyBhbiBpc3N1ZSwgdGhhdCB1bmxlc3Mgd2lkdGggaGVpZ2h0IGhhcmRjb2RlZCwgdGhleSBncm93IHdpdGggZWFjaCBhZGRpdGlvbmFsIGdyYXBoLlxuICAgIGlmIChteWRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChteWRpdi5zdWJzdHIoMSkpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgMzAwKSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIDIwMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbXluYW1lID0gbXluYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoXCJfXCIsIG15ZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlY3RXaWR0aCA9IHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKTsgLy90aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuXG4gICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5KVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMWY3N2I0XCIpO1xuXG4gICAgLy8gZHJhdyBlcnJvciBiYXJzLCB0aHJlc2hvbGQgbGluZSBhbmQgZXh0cmEgYmluXG4gICAgaWYgKHByaXYpIHtcbiAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lVcHBlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgXHQuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeTIgPSB5KG1heFkgLSBkICsgY2lTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkyID49IHkobWF4WSkgPyB5KG1heFkpIDogeTI7XG4gICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2RyYXcgdG9wIHRpY2tzIG9uIGVycm9yIGJhcnNcbiAgICAgICAgICAgIC8vbmVlZCB0byBmaXggdGhlIGhlaWdodCBvZiB0aGUgZ3JhcGhzIC0gdGhlIHRvcHMgb2YgZXJyb3IgYmFycyBhcmUgZ2V0dGluZyBjdXQgb2ZmXG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi50b3BUaWNrXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lVcHBlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0b3BUaWNrXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpIC8vbWFrZSB0aWNrIGJpZ2dlciB0byBpbmNyZWFzZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC40ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShtYXhZIC0gZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8vbWFrZSB0aWNrIGJpZ2dlciB0byBpbmNyZWFzZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC42ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB5KG1heFkgLSBkKSk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgYm90dG9tIHRpY2tzIG9mIGVycm9yIGJhcnNcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLmJvdHRvbVRpY2tcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaUxvd2VyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJvdHRvbVRpY2tcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjQgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjYgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHkobWF4WSAtIGQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLmRlbnNlRXJyb3JcIilcbiAgICAgICAgICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRlbnNlRXJyb3JcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5KG1heFkgLSBkKSAtIC4xICogeShkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+ICh5KG1heFkgLSBkKSArIC4xICogeShkKSkgLSAoeShtYXhZIC0gZCkgLSAuMSAqIHkoZCkpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcInNpbHZlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgc3RhdGVtZW50IGZvciBzdGFiaWxpdHkgaGlzdG9ncmFtc1xuICAgICAgICAvL2V4dHJhIHN0YWJpbGl0eSBiaW5cbiAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeChtYXhYICsgMC41IC0gYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHkobWF4WSkgLSBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RocmVzaG9sZCBsaW5lXG4gICAgICAgIGlmIChub2RlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgobWluWCAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShtYXhZKSAtIG5vZGUudGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhYmlsaXR5QmluXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlLnN0YWJpbGl0eUJpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkobWF4WSkgLSBub2RlLnRocmVzaG9sZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgfVxuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIGlmIChteWRpdiA9PSBcIiNzZXR4TGVmdFwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpIC8vIGJhZCBwcmFjdGljZSwgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneHZhbCcpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gTWF0aC5yb3VuZCh5VmFsS2V5Lmxlbmd0aCAvIDIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eVZhbEtleVt0XS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbdF0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9KCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKSAvL2JhZCBwcmFjdGljZSwgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneDF2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKG1pblggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAobWF4WCAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGQzLm1pbih4VmFscyk7IGkgPD0gZDMubWF4KHhWYWxzKTsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoaSksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43NVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuODVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIHNsaWRlQm94ID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjggKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgLnRpY2tzKDApXG4gICAgICAgICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpKTtcblxuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuXG4gICAgICAgIGxldCBwb2ludHMgPSBpID0+IGQgPT4ge1xuICAgICAgICAgICAgbGV0IHhubSwgcyA9IDY7XG4gICAgICAgICAgICBpZiAobm9kZS5zZXR4dmFsc1tpXSA9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vbWluYWwsIHVzZSB0aGUgbWVkaWFuIGZyZXF1ZW5jeSBhcyB0aGUgcG9zaXRpb24gZm9yIHRoZSBzZXR4IHNsaWRlclxuICAgICAgICAgICAgICAgIHhubSA9IG5vZGUubmF0dXJlID09ICdub21pbmFsJyA/IHgoTWF0aC5yb3VuZCh4VmFscy5sZW5ndGggLyAyKSAtIDEpIDogeChub2RlLm1lYW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bm0gPSB4KG5vZGUuc2V0eHZhbHNbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBgJHt4bm0gLSBzfSwkey1zfSAke3hubSArIHN9LCR7LXN9ICR7eG5tfSwke3MgKiAxLjN9YDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHNsaWRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjcgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygwKSk7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHdvU0YoeCkge1xuICAgICAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjJyXCIpOyAvLyBmb3JtYXQgdG8gdHdvIHNpZ25pZmljYW50IGZpZ3VyZXMgYWZ0ZXIgdGhlIGRlY2ltYWwgcGxhY2VcbiAgICAgICAgcmV0dXJuIHRzZih4KS5yZXBsYWNlKC8wKyQvLCBcIlwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7IC8vIHRyaW0gdHJhaWxpbmcgemVyb3MgYWZ0ZXIgYSBwZXJpb2QsIGFuZCBhbnkgb3JwaGFuZWQgcGVyaW9kXG4gICAgfVxuXG4gICAgLy8gYnJ1c2hpbmcgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjtcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4WCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChtYXhYKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IG1pblgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgobWluWCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoTWF0aC5yb3VuZCh2YWx1ZSkgLSB2YWx1ZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHhwb3MgLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKHMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIgKyB5VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PSsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIuY29uY2F0KCsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBub2RlLnNldHh2YWxzWzBdID0gKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG5cbiAgICAvLyBjZXJ0YWlubHkgYSBtb3JlIGNsZXZlciB3YXkgdG8gZG8gdGhpcywgYnV0IGZvciBub3cgaXQncyBiYXNpY2FsbHkgY29waWVkIHdpdGggYnJ1c2ggYW5kIGhhbmRsZSBjaGFuZ2VzIHRvIGJydXNoMiBhbmQgaGFuZGxlMiBhbmQgI3JhbmdlIHRvICNyYW5nZTIgYW5kIHNldHh2YWxzWzBdIHRvIHNldHh2YWxzWzFdXG4gICAgZnVuY3Rpb24gYnJ1c2hlZDIoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoMi5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2OyAvLyBzY2FsaW5nIGZvciB0cmlhbmdsZSBzaGFwZVxuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaDIuZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4WCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChtYXhYKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IG1pblgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgobWluWCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoTWF0aC5yb3VuZCh2YWx1ZSkgLSB2YWx1ZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUyLmF0dHIoXCJwb2ludHNcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICh4cG9zIC0gcykgKyBcIixcIiArIHMgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArIHMgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArICgtcyAqIDEuMyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2UyXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJUb1wiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD15VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIiArIHlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIlRvXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PSsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxufVxuXG4vLyBkcmF3cyBiYXJwbG90cyBpbiBzdWJzZXQgdGFiXG5leHBvcnQgZnVuY3Rpb24gYmFyc1N1YnNldChub2RlKSB7XG4gICAgLy8gaWYgdW50b3VjaGVkLCBzZXQgbm9kZS5zdWJzZXRyYW5nZSB0byBhbiBlbXB0eSBhcnJheSwgbWVhbmluZyBhbGwgdmFsdWVzIHNlbGVjdGVkIGJ5IGRlZmF1bHRcbiAgICBpZiAobm9kZS5zdWJzZXRyYW5nZVswXSA9PSBcIlwiICYgbm9kZS5zdWJzZXRyYW5nZVsxXSA9PSBcIlwiKSB7XG4gICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBWYXJpYWJsZSBuYW1lXG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgIH0pO1xuICAgICAgICB4aSA9IHhpICsgMTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikgeyAvLyBpZiBub21pbmFsLCBvcmRlcnMgYmFycyBsZWZ0IHRvIHJpZ2h0LCBoaWdoZXN0IGZyZXF1ZW5jeSB0byBsb3dlc3RcbiAgICAgICAgeVZhbEtleS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICB9XG5cbiAgICBwbG90WGF4aXMgPSBmYWxzZTtcblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuICAgIHZhciBnbmFtZSA9IFtcInN1YnNldHllc1wiLCBcInN1YnNldG5vXCJdO1xuXG4gICAgdmFyIHlWYWxzMiA9IFtdO1xuICAgIHZhciB5VmFsczEgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeVZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeVZhbHMxLnB1c2goe1xuICAgICAgICAgICAgeTA6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIHkxOiB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogZDNDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgeVZhbHMyLnB1c2goe1xuICAgICAgICAgICAgeTA6IDAsXG4gICAgICAgICAgICB5MTogbWF4WSAtIHlWYWxzW2ldLFxuICAgICAgICAgICAgY29sOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmcmVxcyA9IFt5VmFsczEsIHlWYWxzMl07XG5cbiAgICAvLyB5MCBpcyB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAvLyB5MSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXJcblxuICAgIHZhciBteWRpdiA9IFwiI3RhYjJcIjtcbiAgICB2YXIgd2lkdGggPSAyMDA7XG4gICAgdmFyIGhlaWdodCA9IDEyMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDUwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHZhciBmcmVxID0gcGxvdHN2Zy5zZWxlY3RBbGwoXCJnLmZyZXFcIilcbiAgICAgICAgLmRhdGEoZnJlcXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZXFcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KGduYW1lW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcmVjdCA9IGZyZXEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YShPYmplY3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhclwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWxzW2ldO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID4gMCAmIGQuY29sID09PSBkM0NvbG9yICYgJC5pbkFycmF5KHhWYWxzW2ldLnRvU3RyaW5nKCksIG5vZGUuc3Vic2V0cmFuZ2UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT0gbXluYW1lLmNvbmNhdChcInN1YnNldG5vXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSAkKCdbbmFtZT1cIicgKyBteW5hbWUuY29uY2F0KFwic3Vic2V0eWVzXCIpICsgJ1wiXScpLmNoaWxkcmVuKCdbbmFtZT1cIicgKyBzZWxlY3ROYW1lICsgJ1wiXScpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5maWxsID09PSBzZWxWYXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15aW5kZXggPSBub2RlLnN1YnNldHJhbmdlLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2Uuc3BsaWNlKG15aW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBkM0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBteUNvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNzZWxlY3RyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IHlWYWxLZXlbaV0ueCArIFwiOiBcIiArIHlWYWxLZXlbaV0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDIwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG15bmFtZSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNlbGVjdHJhbmdlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAudGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UuZm9yRWFjaCh2YWwgPT4gIHNlbGVjdGVkcy5wdXNoKHlWYWxLZXlbdmFsXS54KSk7XG4gICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHM7XG4gICAgICAgIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5Tm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHlWYWxzID0gbm9kZS5wbG90eTtcbiAgICB2YXIgeFZhbHMgPSBub2RlLnBsb3R4O1xuICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICBsZXQgZGF0YTIgPSBub2RlLnBsb3R4Lm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDsgLy8gaGFyZGNvZGVkLCBzaG91bGQgYmUgc2V0IGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuXG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApIC8vIE5PVEU6IE5vdCBzdXJlIGV4YWN0bHkgd2h5IHRoZXNlIG51bWJlcnMgd29yaywgYnV0IHRoZXNlIGhhcmRjb2RlZCB2YWx1ZXMgc2VlbSB0byBwb3NpdGlvbiB0aGUgcGxvdCBpbnNpZGUgZyBjb3JyZWN0bHkuICB0aGlzIHNob3VsZG4ndCBiZSBoYXJkY29kZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKGRhdGEyKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzTm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDtcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChvYmopXG4gICAgICAgIC5pbnNlcnQoXCJzdmdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC00MClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+ICB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+ICB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZykpIC8vIHRoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiMxZjc3YjRcIik7XG59XG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXNzZXRzL2FwcC9wbG90cy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFJQTtBQXFVQTtBQStoQkE7QUE2TkE7QUFzREE7QUEzbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFJQTtBQUdBO0FBSUE7QUFHQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFGQTtBQU9BO0FBQ0E7QUFFQTtBQUFBO0FBRkE7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUFBO0FBRkE7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUdBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBSkE7QUFDQTtBQVNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUtBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFBQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUFBO0FBSkE7QUFDQTtBQVNBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFMQTtBQVNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!************************************!*\
  !*** ./assets/app/views/Search.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ../app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(/*! ../plots */ 2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz80YTc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/* no static exports found */
/* all exports used */
/*!*******************************!*\
  !*** ./assets/app/explore.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.get_width = get_width;\nexports.linechart = linechart;\nexports.explore = explore;\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ./app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(/*! ./plots */ 2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $private = false;\n\nfunction heatmap(x_Axis_name, y_Axis_name) {\n    document.getElementById('heatchart').style.display = \"block\";\n    d3.select(\"#heatchart\").select(\"svg\").remove();\n    $('#heatchart').html(\"\");\n\n    var margin_heat = { top: 30, right: 10, bottom: 60, left: 60 },\n        width_heat = 500 - margin_heat.left - margin_heat.right,\n        height_heat = 300 - margin_heat.top - margin_heat.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 100;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 100;\n\n    var x = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width_heat]);\n\n    var y = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height_heat, 0]);\n\n    var z = d3.scale.linear().range([\"#EF9A9A\", \"#EF5350\"]);\n\n    // This could be inferred from the data if it weren't sparse.\n    var xStep = avg_x + 0.1,\n        yStep = avg_y + 0.2;\n    var svg_heat = d3.select(\"#heatchart\").append(\"svg\").attr(\"width\", width_heat + margin_heat.left + margin_heat.right).attr(\"height\", height_heat + margin_heat.top + margin_heat.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin_heat.left + \",\" + margin_heat.top + \")\").style(\"background-color\", \"#FFEBEE\");\n\n    // Compute the scale domains.\n    x.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    }));\n    y.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    }));\n    z.domain([0, d3.max(data_plot, function (d, i) {\n        return data_plot[i].score;\n    })]);\n\n    // Extend the x- and y-domain to fit the last bucket.\n    // For example, the y-bucket 3200 corresponds to values [3200, 3300].\n    x.domain([x.domain()[0], +x.domain()[1] + xStep]);\n    y.domain([y.domain()[0], y.domain()[1] + yStep]);\n\n    // Display the tiles for each non-zero bucket.\n    // See http://bl.ocks.org/3074470 for an alternative implementation.\n    svg_heat.selectAll(\".tile\").data(data_plot).enter().append(\"rect\").attr(\"class\", \"tile\").attr(\"x\", function (d, i) {\n        return x(data_plot[i].xaxis);\n    }).attr(\"y\", function (d, i) {\n        return y(data_plot[i].yaxis + yStep);\n    }).attr(\"width\", 15).attr(\"height\", 15).attr(\"dx\", \".35em\").attr(\"dy\", \".35em\").style(\"fill\", function (d, i) {\n        return z(data_plot[i].score);\n    });\n\n    svg_heat.append(\"text\").attr(\"class\", \"label\").attr(\"x\", width_heat + 20).attr(\"y\", 10).attr(\"dy\", \".35em\").text(\"Count\");\n\n    // Add an x-axis with label.\n    svg_heat.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height_heat + \")\").call(d3.svg.axis().scale(x).ticks(5).tickSize(-height_heat).orient(\"bottom\")).append(\"text\").attr(\"class\", \"label\").attr(\"x\", width_heat).attr(\"y\", -6).attr(\"text-anchor\", \"end\").text(\"\");\n\n    // Add a y-axis with label.\n    svg_heat.append(\"g\").attr(\"class\", \"y axis\").call(d3.svg.axis().scale(y).tickSize(-width_heat).orient(\"left\")).append(\"text\").attr(\"class\", \"label\").attr(\"y\", 6).attr(\"dy\", \".71em\").attr(\"text-anchor\", \"end\").attr(\"transform\", \"rotate(-90)\").text(\"\");\n\n    svg_heat.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(-40,\" + height_heat / 2 + \")rotate(-90)\") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    svg_heat.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + width_heat / 2 + \",\" + (height_heat + padding / 4) + \")\") // centre below axis\n    .text(x_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n}\n\nvar heatxaxis = void 0,\n    heatyaxis = void 0;\nvar data_plot = [];\n\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    heatxaxis = x_Axis_name;\n    heatyaxis = y_Axis_name;\n    app.byId('scatterplot').style.display = 'block';\n    d3.select(\"#scatterplot\").html(\"\");\n    d3.select(\"#scatterplot\").select(\"svg\").remove();\n\n    // scatter plot\n    data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < 1000; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 20, right: 15, bottom: 40, left: 60 },\n        width = 500 - margin.left - margin.right,\n        height = 280 - margin.top - margin.bottom,\n        padding = 100;\n\n    var min_x = d3.min(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient('left').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on(\"zoom\", zoomed);\n\n    var chart_scatter = d3.select('#scatterplot').append('svg:svg').attr('width', width + margin.right + margin.left).attr('height', height + margin.top + margin.bottom).call(zoom);\n\n    var main1 = chart_scatter.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('width', width + margin.right + margin.left).attr('height', height + margin.top + margin.bottom).attr('class', 'main');\n\n    main1.append('g').attr('transform', 'translate(0,' + height + ')').attr('class', 'x axis').call(xAxis);\n\n    main1.append('g').attr('transform', 'translate(0,0)').attr('class', 'y axis').call(yAxis);\n\n    var clip = main1.append(\"defs\").append(\"svg:clipPath\").attr(\"id\", \"clip\").append(\"svg:rect\").attr(\"id\", \"clip-rect\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr('width', width).attr('height', height);\n\n    main1.append(\"g\").attr(\"clip-path\", \"url(#clip)\").selectAll(\"circle\").data(data_plot).enter().append(\"circle\").attr(\"cx\", function (_, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr(\"cy\", function (_, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr(\"r\", 2).style(\"fill\", \"#B71C1C\");\n    chart_scatter.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + padding / 5 + \",\" + height / 2 + \")rotate(-90)\") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    chart_scatter.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height + padding / 2) + \")\") // centre below axis\n    .text(x_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(\".x.axis\").call(xAxis);\n        main1.select(\".y.axis\").call(yAxis);\n        main1.selectAll(\"circle\").attr(\"cx\", function (_, i) {\n            return xScale(data_plot[i].xaxis);\n        }).attr(\"cy\", function (_, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr(\"r\", 2.5).style(\"fill\", \"#B71C1C\");\n    }\n\n    d3.select('#NAcount').style('display', 'block');\n    d3.select(\"#NAcount\").text(\"There are \" + nanCount + \" number of NA values in the relation.\");\n}\n\nvar plotnamea = void 0,\n    plotnameb = void 0,\n    varn1 = void 0,\n    varn2 = void 0,\n    varsize1 = void 0,\n    varsize2 = void 0;\n\nvar continuous_n = 0;\nvar bar_n = 0;\n\nfunction get_width(id) {\n    return 50 * (id === 'plotA' ? continuous_n : bar_n);\n}\n\nfunction crossTabPlots(PlotNameA, PlotNameB, json_obj) {\n    plotnamea = PlotNameA;\n    plotnameb = PlotNameB;\n    $(\"#input1\").attr(\"placeholder\", PlotNameA).blur();\n    $(\"#input2\").attr(\"placeholder\", PlotNameB).blur();\n    var plot_a = '#plotA',\n        plot_b = '#plotB';\n\n\n    var margin_cross = { top: 30, right: 35, bottom: 40, left: 40 },\n        width_cross = 300 - margin_cross.left - margin_cross.right,\n        height_cross = 160 - margin_cross.top - margin_cross.bottom;\n    var padding_cross = 100;\n\n    d3.select(\"#input1\").on(\"mouseover\", function () {\n        d3.select(\"#tooltipPlotA\").style(\"visibility\", \"visible\").style(\"opacity\", \"1\").text(PlotNameA);\n    }).on(\"mouseout\", function () {\n        d3.select(\"#tooltipPlotA\").style(\"visibility\", \"hidden\").style(\"opacity\", \"0\");\n    });\n    d3.select(\"#input2\").on(\"mouseover\", function () {\n        d3.select(\"#tooltipPlotB\").style(\"visibility\", \"visible\").style(\"opacity\", \"1\").text(PlotNameB);\n    }).on(\"mouseout\", function () {\n        d3.select(\"#tooltipPlotB\").style(\"visibility\", \"hidden\").style(\"opacity\", \"0\");\n    });\n\n    var plot_nodes = app.nodes.slice();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = plot_nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === PlotNameA) {\n                if (node.plottype === \"continuous\") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === \"bar\") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            } else if (node.name === PlotNameB) {\n                if (node.plottype === \"continuous\") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === \"bar\") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var plotA_size = void 0,\n        plotB_size = void 0,\n        plotA_sizem = void 0,\n        plotB_sizem = void 0;\n    var varn1 = void 0,\n        varn2 = void 0,\n        varsize1 = void 0,\n        varsize2 = void 0;\n    $(\"#Equidistance1\").click(function () {\n        varn1 = \"equidistance\";\n        plotA_size = parseInt(d3.select(\"#input1\")[0][0].value);\n        varsize1 = plotA_size;\n        equidistance(PlotNameA, plotA_size);\n        document.getElementById(\"plotA_status\").innerHTML = PlotNameA + ' : ' + varn1 + ' distribution with ' + varsize1 + ' divisions';\n    });\n    $(\"#Equimass1\").click(function () {\n        plotA_sizem = parseInt(d3.select(\"#input1\")[0][0].value);\n        varsize1 = plotA_sizem;\n        equimass(PlotNameA, plotA_sizem);\n        varn1 = \"equimass\";\n        document.getElementById(\"plotA_status\").innerHTML = PlotNameA + ' : ' + varn1 + ' distribution with ' + varsize1 + ' divisions';\n    });\n    $(\"#Equidistance2\").click(function () {\n        varn2 = \"equidistance\";\n        plotB_size = parseInt(d3.select(\"#input2\")[0][0].value);\n        equidistance(PlotNameB, plotB_size);\n        varsize2 = plotB_size;\n        document.getElementById(\"plotB_status\").innerHTML = PlotNameB + ' : ' + varn2 + ' distribution with ' + varsize2 + ' divisions';\n    });\n    $(\"#Equimass2\").click(function () {\n        varn2 = \"equimass\";\n        plotB_sizem = parseInt(d3.select(\"#input2\")[0][0].value);\n        equimass(PlotNameB, plotB_sizem);\n        varsize2 = plotB_sizem;\n        document.getElementById(\"plotB_status\").innerHTML = PlotNameB + ' : ' + varn2 + ' distribution with ' + varsize2 + ' divisions';\n    });\n\n    // this is the function to add  the density plot if any\n    function density_cross(density_env, a, method_name) {\n        // setup the x_cord according to the size given by user\n        var yVals = density_env.ploty;\n        var xVals = density_env.plotx;\n\n        // an array of objects\n        var data2 = [];\n        for (var i = 0; i < density_env.plotx.length; i++) {\n            data2.push({ x: density_env.plotx[i], y: density_env.ploty[i] });\n        }\n        data2.forEach(function (d) {\n            d.x = +d.x;\n            d.y = +d.y;\n        });\n\n        var min_x = d3.min(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var max_x = d3.max(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var avg_x = (max_x - min_x) / 10;\n        var min_y = d3.min(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var max_y = d3.max(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var avg_y = (max_y - min_y) / 10;\n        var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width_cross]);\n        var invx = d3.scale.linear().range([d3.min(data2.map(function (d) {\n            return d.x;\n        })), d3.max(data2.map(function (d) {\n            return d.x;\n        }))]).domain([0, width_cross]);\n        var y = d3.scale.linear().domain([d3.min(data2.map(function (d) {\n            return d.y;\n        })), d3.max(data2.map(function (d) {\n            return d.y;\n        }))]).range([height_cross, 0]);\n        var xAxis = d3.svg.axis().scale(x).ticks(5).orient(\"bottom\");\n        var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n        var area = d3.svg.area().interpolate(\"monotone\").x(function (d) {\n            return x(d.x);\n        }).y0(height_cross - avg_y).y1(function (d) {\n            return y(d.y);\n        });\n        var line = d3.svg.line().x(function (d) {\n            return x(d.x);\n        }).y(function (d) {\n            return y(d.y);\n        }).interpolate(\"monotone\");\n\n        var plotsvg = d3.select(plot_a).append(\"svg\").attr(\"id\", \"plotsvg_id\").style(\"width\", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style(\"height\", height_cross + margin_cross.top + margin_cross.bottom).style(\"margin-left\", \"20px\").append(\"g\").attr(\"transform\", \"translate(0,\" + margin_cross.top + \")\");\n        plotsvg.append(\"path\").attr(\"id\", \"path1\").datum(data2).attr(\"class\", \"area\").attr(\"d\", area);\n        plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height_cross + \")\").call(xAxis);\n        plotsvg.append(\"text\").attr(\"x\", width_cross / 2).attr(\"y\", margin_cross.top + padding_cross - 10).attr(\"text-anchor\", \"middle\").text(density_env.name).style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n        if (isNaN(a) || a === 0) {\n            var upper_limit = d3.max(xVals);\n            var lower_limit = d3.min(xVals);\n            var z = 10;\n            var diff = upper_limit - lower_limit;\n            var buffer = diff / z;\n            var x_cord = [];\n            var push_data = lower_limit;\n            for (var i = 0; i < z - 1; i++) {\n                push_data = push_data + buffer;\n                x_cord.push(push_data);\n                plotsvg.append(\"line\").attr(\"id\", \"line1\").attr(\"x1\", x(x_cord[i])).attr(\"x2\", x(x_cord[i])).attr(\"y1\", y(d3.min(yVals))).attr(\"y2\", y(d3.max(yVals))).style(\"stroke\", \"#0D47A1\").style(\"stroke-dasharray\", \"3\");\n            }\n        } else {\n            if (method_name === \"equidistance\") {\n                var upper_limit = d3.max(xVals);\n                var lower_limit = d3.min(xVals);\n                var diff = upper_limit - lower_limit;\n                var buffer = diff / a;\n                var x_cord = [];\n                var push_data = lower_limit;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data = push_data + buffer;\n                    x_cord.push(push_data);\n                    plotsvg.append(\"line\").attr(\"id\", \"line1\").attr(\"x1\", x(x_cord[i])).attr(\"x2\", x(x_cord[i])).attr(\"y1\", y(d3.min(yVals))).attr(\"y2\", y(d3.max(yVals))).style(\"stroke\", \"#0D47A1\").style(\"stroke-dasharray\", \"4\");\n                }\n            } else if (method_name === \"equimass\") {\n                // here we use the data from equimassCalculation to draw lines\n                var temp = [];\n                temp = equimassCalculation(density_env, a);\n                for (var i = 1; i < a; i++) {\n                    plotsvg.append(\"line\").attr(\"id\", \"line1\").attr(\"x1\", x(temp[i])).attr(\"x2\", x(temp[i])).attr(\"y1\", y(d3.min(yVals))).attr(\"y2\", y(d3.max(yVals))).style(\"stroke\", \"#0D47A1\").style(\"stroke-dasharray\", \"4\");\n                }\n            }\n        }\n    }\n\n    // this is the function to add the bar plot if any\n    function bar_cross(bar_env, a, method_name) {\n        var barPadding = .015; // Space between bars\n        var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n        var plotXaxis = true;\n\n        // Data\n        var keys = Object.keys(bar_env.plotvalues);\n        var yVals = new Array();\n        var ciUpperVals = new Array();\n        var ciLowerVals = new Array();\n        var ciSize;\n\n        var xVals = new Array();\n        var yValKey = new Array();\n\n        if (bar_env.nature === \"nominal\") {\n            var xi = 0;\n            for (var i = 0; i < keys.length; i++) {\n                if (bar_env.plotvalues[keys[i]] == 0) {\n                    continue;\n                }\n                yVals[xi] = bar_env.plotvalues[keys[i]];\n                xVals[xi] = xi;\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[xi] = bar_env.plotValuesCI.lowerBound[keys[i]];\n                        ciUpperVals[xi] = bar_env.plotValuesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n                }\n                yValKey.push({ y: yVals[xi], x: keys[i] });\n                xi = xi + 1;\n            }\n            yValKey.sort(function (a, b) {\n                return b.y - a.y;\n            }); // array of objects, each object has y, the same as yVals, and x, the category\n            yVals.sort(function (a, b) {\n                return b - a;\n            }); // array of y values, the height of the bars\n            ciUpperVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n            ciLowerVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n        } else {\n            for (var i = 0; i < keys.length; i++) {\n                yVals[i] = bar_env.plotvalues[keys[i]];\n                xVals[i] = Number(keys[i]);\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[i] = bar_env.plotvaluesCI.lowerBound[keys[i]];\n                        ciUpperVals[i] = bar_env.plotvaluesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[i] - ciLowerVals[i];\n                }\n            }\n        }\n\n        if (yVals.length > 15 & bar_env.numchar === \"numeric\" | yVals.length > 5 & bar_env.numchar === \"character\") {\n            plotXaxis = false;\n        }\n        var minY = d3.min(yVals);\n        var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n        var minX = d3.min(xVals);\n        var maxX = d3.max(xVals);\n        var x_1 = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width_cross]);\n\n        var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width_cross]);\n\n        var y_1 = d3.scale.linear()\n        // .domain([0, maxY])\n        .domain([0, maxY]).range([0, height_cross]);\n\n        var xAxis = d3.svg.axis().scale(x_1).ticks(yVals.length).orient(\"bottom\");\n\n        var yAxis = d3.svg.axis().scale(y_1).orient(\"left\");\n\n        var plotsvg1 = d3.select(plot_b).append(\"svg\").attr(\"id\", \"plotsvg1_id\").style(\"width\", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style(\"height\", height_cross + margin_cross.top + margin_cross.bottom).style(\"margin-left\", \"20px\").append(\"g\").attr(\"transform\", \"translate(0,\" + margin_cross.top + \")\");\n\n        var rectWidth = x_1(minX + 0.5 - 2 * barPadding); //the \"width\" is the coordinate of the end of the first bar\n        plotsvg1.selectAll(\"rect\").data(yVals).enter().append(\"rect\").attr(\"id\", \"path2\").attr(\"x\", function (d, i) {\n            return x_1(xVals[i] - 0.5 + barPadding);\n        }).attr(\"y\", function (d) {\n            return y_1(maxY - d);\n        }).attr(\"width\", rectWidth).attr(\"height\", function (d) {\n            return y_1(d);\n        }).attr(\"fill\", \"#fa8072\");\n\n        if (plotXaxis) {\n            plotsvg1.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height_cross + \")\").call(xAxis);\n        }\n\n        plotsvg1.append(\"text\").attr(\"x\", width_cross / 2).attr(\"y\", margin_cross.top + padding_cross - 10).attr(\"text-anchor\", \"middle\").text(bar_env.name).style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n        if (isNaN(a) || a === 0) {\n            x_cord2 = equimass_bar(bar_env, keys.length);\n            for (var i = 0; i < keys.length - 1; i++) {\n                plotsvg1.append(\"line\").attr(\"id\", \"line2\").attr(\"x1\", x_1(x_cord2[i])).attr(\"x2\", x_1(x_cord2[i])).attr(\"y1\", y_1(0)).attr(\"y2\", y_1(maxY)).style(\"stroke\", \"#212121\").style(\"stroke-dasharray\", \"4\");\n            }\n        } else {\n            if (method_name === \"equidistance\") {\n                var upper_limit1 = maxX;\n                var lower_limit1 = minX;\n                var diff1 = upper_limit1 - lower_limit1;\n                var buffer1 = diff1 / a;\n                var x_cord1 = [];\n                var push_data1 = lower_limit1;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data1 = push_data1 + buffer1;\n                    x_cord1.push(push_data1);\n                    plotsvg1.append(\"line\").attr(\"id\", \"line2\").attr(\"x1\", x_1(x_cord1[i])).attr(\"x2\", x_1(x_cord1[i])).attr(\"y1\", y_1(0)).attr(\"y2\", y_1(maxY)).style(\"stroke\", \"#0D47A1\").style(\"stroke-dasharray\", \"4\");\n                }\n            } else if (method_name === \"equimass\") {\n                var x_cord2 = [];\n                x_cord2 = equimass_bar(bar_env, a);\n                for (var i = 0; i < a - 1; i++) {\n                    plotsvg1.append(\"line\").attr(\"id\", \"line2\").attr(\"x1\", x_1(x_cord2[i])).attr(\"x2\", x_1(x_cord2[i])).attr(\"y1\", y_1(0)).attr(\"y2\", y_1(maxY)).style(\"stroke\", \"#0D47A1\").style(\"stroke-dasharray\", \"4\");\n                }\n            }\n        }\n    }\n\n    function equidistance(A, a) {\n        var method_name = \"equidistance\";\n        // json object to be sent to r server\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === \"continuous\") {\n                    $(\"#plotsvg_id\").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === \"bar\") {\n                    $(\"#plotsvg1_id\").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log(\"not found\");\n            }\n        }\n    }\n    function equimass(A, a) {\n        //equimass function to call the plot function\n        var method_name = \"equimass\";\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === \"continuous\") {\n                    $(\"#plotsvg_id\").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === \"bar\") {\n                    $(\"#plotsvg1_id\").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log(\"not found\");\n            }\n        }\n    }\n\n    function equimassCalculation(plot_ev, n) {\n        // here we find the coordinates using CDF values\n        //var n =v-1;\n        var arr_y = [];\n        var arr_x = [];\n\n        arr_y = plot_ev.cdfploty; // cdfploty data stored\n        arr_x = plot_ev.cdfplotx; // cdfplotx data stored\n\n        var Upper_limitY = d3.max(arr_y);\n        var Lower_limitY = d3.min(arr_y);\n        var diffy = Upper_limitY - Lower_limitY;\n        var e = diffy / n; // e is the variable to store the average distance between the points in the cdfy in order to divide the cdfy\n\n        var arr_c = []; //array to store the cdfy divided coordinates data\n        var push_data = arr_y[0];\n        for (var i = 0; i < n; i++) {\n            push_data = push_data + e;\n            arr_c.push(push_data);\n        }\n\n        var temp_cdfx = [];\n        var temp = [];\n        var store = [];\n\n        for (var i = 0; i < n; i++) //to get through each arr_c\n        {\n            for (var j = 0; j < 50; j++) // to compare with cdfy or arr_y\n            {\n                if (arr_c[i] === arr_y[j]) {\n                    store.push({ val: i, coor1: j, coor2: j, diff1: 0.34, diff2: 0 }); // for testing purpose\n                }\n            }\n        }\n        for (var i = 0; i < n; i++) {\n            var diff_val1, diff_val2; // here the diff is not actual difference, it is the fraction of the distance from the two points\n            var x1, x2, x3, x4;\n            for (var j = 0; j < 50; j++) {\n                if (arr_y[j] < arr_c[i] && arr_c[i] < arr_y[j + 1]) {\n                    x1 = arr_c[i];\n                    x2 = arr_c[i] - arr_y[j];\n                    x3 = arr_y[j + 1] - arr_c[i];\n                    x4 = arr_y[j + 1] - arr_y[j];\n                    diff_val1 = x2 / x4;\n                    diff_val2 = x3 / x4;\n                    store.push({ val: i, coor1: j, coor2: j + 1, diff1: diff_val1, diff2: diff_val2 });\n                }\n            }\n        }\n\n        for (var i = 0; i < n; i++) {\n            var y1, y2, y3, diffy1, diffy2;\n            y1 = store[i].val;\n            y2 = store[i].coor1;\n            y3 = store[i].coor2;\n            diffy1 = store[i].diff1;\n            diffy2 = store[i].diff2;\n            var x_coor1 = arr_x[y2];\n            var x_coor2 = arr_x[y3];\n            var x_diff = x_coor2 - x_coor1;\n            var distance1 = x_diff * diffy1;\n            var val_x = x_coor1 + distance1;\n            temp.push(val_x);\n        }\n        return temp;\n    }\n\n    function equimass_bar(plot_ev, n) {\n        var keys = Object.keys(plot_ev.plotvalues);\n        var k = keys.length;\n        var temp = [];\n        var count = 0;\n\n        if (k < n) {\n            alert(\"error enter vaild size\");\n        } else {\n            while (k > 0) {\n                temp.push({ pos: count, val: k });\n                count++;\n                k--;\n                if (count >= n) {\n                    count = 0;\n                }\n            }\n\n            var temp2 = new Array(n);\n            for (var i = 0; i < temp2.length; i++) {\n                temp2[i] = 0;\n            }\n            for (var i = 0; i < keys.length; i++) {\n                keys[i] = (keys[i] + 5) / 10; // to get the increase in the actual values by 0.5 according to the xaxis in plot\n            }\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < temp.length; j++) {\n                    if (temp[j].pos === i) {\n                        temp2[i] = temp2[i] + 1;\n                    }\n                }\n            }\n\n            var j = 0,\n                k = 0;\n            var temp_final = new Array(n);\n            for (var i = 0; i < keys.length; i++) {\n                temp2[j] = temp2[j] - 1;\n                if (temp2[j] === 0) {\n                    j++;\n                    temp_final[k] = keys[i];\n                    k++;\n                }\n            }\n            return temp_final;\n        }\n    }\n}\n\nfunction linechart(x_Axis_name, y_Axis_name) {\n    document.getElementById('linechart').style.display = \"block\";\n    d3.select(\"#lineChart\").select(\"svg\").remove();\n    $('#linechart').html(\"\");\n    var padding = 10;\n    var w_linechart = 480;\n    var h_linechart = 300;\n    var margin_linechart = { top: 20, right: 80, bottom: 30, left: 50 };\n    var width_linechart = w_linechart - margin_linechart.left - margin_linechart.right;\n    var height_linechart = h_linechart - margin_linechart.top - margin_linechart.bottom;\n\n    var svg = d3.select(\"#linechart\").append(\"svg\").attr(\"id\", \"chart\").attr(\"width\", w_linechart).attr(\"height\", h_linechart);\n    var chart = svg.append(\"g\").classed(\"display\", true).attr(\"transform\", \"translate(\" + margin_linechart.left + \",\" + margin_linechart.top + \")\");\n    var x = d3.scale.linear().domain(d3.extent(data_plot, function (d) {\n        return d.xaxis;\n    })).range([0, width_linechart]);\n    var y = d3.scale.linear().domain([d3.min(data_plot, function (d) {\n        return d.yaxis;\n    }), d3.max(data_plot, function (d) {\n        return d.yaxis;\n    })]).range([height_linechart, 0]);\n    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\").ticks(5);\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\").ticks(5);\n    var line = d3.svg.line().x(function (d) {\n        return x(d.xaxis);\n    }).y(function (d) {\n        return y(d.yaxis);\n    });\n\n    function plot(params) {\n        this.append(\"g\").classed(\"x axis\", true).attr(\"transform\", \"translate(0,\" + height_linechart + \")\").call(params.axis.x);\n        this.append(\"g\").classed(\"y axis\", true).attr(\"transform\", \"translate(0,0)\").call(params.axis.y);\n        //enter()\n        this.selectAll(\".trendline\").data([params.data]).enter().append(\"path\").classed(\"trendline\", true);\n        this.selectAll(\".point\").data(params.data).enter().append(\"circle\").classed(\"point\", true).attr(\"r\", 2);\n        //update\n        this.selectAll(\".trendline\").attr(\"d\", function (d) {\n            return line(d);\n        });\n        this.selectAll(\".point\").attr(\"cx\", function (d) {\n            var date = d.xaxis;\n            return x(date);\n        }).attr(\"cy\", function (d) {\n            return y(d.yaxis);\n        }).style(\"color\", \"#EF5350\");\n        //exit()\n        this.selectAll(\".trendline\").data([params.data]).exit().remove();\n        this.selectAll(\".point\").data(params.data).exit().remove();\n    }\n\n    var temp = d3.select(\"#main.left\").style(\"width\");\n    var width = temp.substring(0, temp.length - 2);\n    var height = $(window).height() - 120;\n    svg.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + padding + \",\" + height / 3 + \")rotate(-90)\") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n    svg.append(\"text\").attr(\"text-anchor\", \"middle\") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr(\"transform\", \"translate(\" + width / 5 + \",\" + (height - padding - 128) + \")\") // centre below axis\n    .text(x_Axis_name).style(\"fill\", \"#424242\").style(\"text-indent\", \"20px\").style(\"font-size\", \"12px\").style(\"font-weight\", \"bold\");\n\n    plot.call(chart, {\n        data: data_plot,\n        axis: {\n            x: xAxis,\n            y: yAxis\n        }\n    });\n}\n\nfunction viz(m, json_vizexplore, model_name_set) {\n    d3.select(\"#plotA\").html(\"\");\n    d3.select(\"#plotB\").html(\"\");\n    d3.select(\"#tabular_1\").style(\"display\", \"block\");\n    d3.select(\"#tabular_2\").style(\"display\", \"block\");\n\n    var get_data = model_name_set.split(\"-\");\n    var model_name1 = get_data[0] + \"-\" + get_data[1];\n    var model_name2 = get_data[1] + \"-\" + get_data[0];\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var json = json_vizexplore;\n    // pipe in figures to right panel\n    var filelist = new Array();\n\n    // image added to the div\n    var x_axis = [];\n    var y_axis = [];\n    for (var i in json.plotdata) {\n        for (var j in json.plotdata[i].varname) {\n            if (json.plotdata[i].varname[j] === get_data[0]) {\n                for (var k in json.plotdata[i].data) {\n                    x_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n            if (json.plotdata[i].varname[j] === get_data[1]) {\n                for (var k in json.plotdata[i].data) {\n                    y_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n        }\n    }\n\n    bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n\n    $('#scatterplot_img').on('click', function () {\n        $(\"#scatterplot_img\").fadeOut(\"fast\").fadeIn().fadeTo(\"fast\", 1.0);\n    });\n    $('#heatmap_img').on('click', function () {\n        $(\"#heatmap_img\").fadeOut(\"fast\").fadeIn().fadeTo(\"fast\", 1.0);\n    });\n    $('#linechart_img').on('click', function () {\n        $(\"#linechart_img\").fadeOut(\"fast\").fadeIn().fadeTo(\"fast\", 1.0);\n    });\n    $('#scatterplot_img').click(function () {\n        document.getElementById('heatchart').style.display = \"none\";\n        document.getElementById('linechart').style.display = \"none\";\n        bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n    });\n    $('#heatmap_img').click(function () {\n        document.getElementById('scatterplot').style.display = \"none\";\n        document.getElementById('linechart').style.display = \"none\";\n        heatmap(get_data[0], get_data[1]);\n    });\n    $('#linechart_img').click(function () {\n        document.getElementById('heatchart').style.display = \"none\";\n        document.getElementById('scatterplot').style.display = \"none\";\n        linechart(get_data[0], get_data[1]);\n    });\n\n    var empty = [];\n    crossTabPlots(get_data[0], get_data[1], empty);\n\n    var cork = [];\n    var corp = [];\n    var cors = [];\n    var var1 = [];\n    var var2 = [];\n    var table_obj = [];\n    var colnames = [];\n    var colvar = [];\n    var table_data = [];\n    var rowvar = [];\n    var rownames = [];\n    function crossTab_Table(json) {\n        table_data = [];\n        table_obj = [];\n        var push = function push(i, key) {\n            return json.tabular[i][key].map(function (v) {\n                return v;\n            });\n        };\n        // data for statistics\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                colnames = push(i, 'colnames');\n                rownames = push(i, 'rownames');\n                rowvar = push(i, 'rowvar');\n                colvar = push(i, 'colvar');\n            }\n        }\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var n in json.tabular[i].data) {\n                    table_data[n] = [];\n                    for (var a = 0; a < colnames.length; a++) {\n                        table_data[n].push(json.tabular[i].data[n][a]);\n                    }\n                }\n            }\n        }\n        for (var p = 0; p < rownames.length; p++) {\n            for (var l = 0; l < colnames.length; l++) {\n                table_obj.push({ rowname: rownames[p], colname: colnames[l], value: table_data[p][l] });\n            }\n        }\n        d3table1(table_obj);\n    }\n\n    // for the statistics\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var a in json.statistical[key].cork) {\n                cork.push(json.statistical[key].cork[a]);\n            }\n        }\n    }\n    for (var key1 in json.statistical) {\n        if (key1 == model_name1 || key1 == model_name2) {\n            for (var b in json.statistical[key1].corp) {\n                corp.push(json.statistical[key1].corp[b]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var c in json.statistical[key].cors) {\n                cors.push(json.statistical[key].cors[c]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var d in json.statistical[key].var1) {\n                var1.push(json.statistical[key].var1[d]);\n            }\n        }\n    }\n    for (var key4 in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var e in json.statistical[key].var2) {\n                var2.push(json.statistical[key].var2[e]);\n            }\n        }\n    }\n    for (var i = 0; i < app.zparams.zvars.length; i++) {\n        var resultsArray = [];\n    }\n    for (var key in json.tabular) {\n        if (key == \"colnames\") {\n            console.log(\"colnames found\");\n            continue;\n        }\n        var obj = json.tabular[key];\n        resultsArray.push(obj);\n    }\n\n    function d3table1(data) {\n        var width = 120,\n            // width of svg\n        height = 160,\n            // height of svg\n        padding = 22; // space around the chart, not including labels\n\n        d3.select(\"#tabular_2\").html(\"\").style(\"background-color\", \"#fff\").append(\"h5\").text(\"CROSS-TABS \").style(\"color\", \"#424242\");\n\n        var sv = d3.select(\"#tabular_2\").append(\"svg\").attr(\"width\", \"100%\").attr(\"height\", \"100%\").style(\"overflow\", \"visible\");\n        var fo = sv.append('foreignObject').attr(\"width\", \"100%\").attr(\"height\", \"100%\").style(\"padding\", 10).attr(\"overflow\", \"visible\");\n        var table = fo.append(\"xhtml:table\").attr(\"class\", \"table\").style(\"border-collapse\", \" collapse\"),\n            th = table.append(\"tr\").style(\"border\", 1).text(\"_\").style(\"color\", \"#fff\");\n        for (var i = 0; i < colnames.length; i++) {\n            th.append(\"td\").style(\"border-bottom\", 1).style(\"text-align\", \"center\").style(\"background-color\", plots.selVarColor).append(\"b\").text(colnames[i]);\n        }\n        for (var k = 0; k < rownames.length; k++) {\n            var pos = 0;\n            var tr = table.append(\"tr\").style(\"margin-left\", 20).style(\"background-color\", \"#BDBDBD\").style(\"border\", 1).style(\"text-align\", \"center\").text(rownames[k]);\n            for (var m = 0; m < colnames.length; m++) {\n                for (var z = 0; z < data.length; z++) {\n                    if (rownames[k] === data[z].rowname && colnames[m] === data[z].colname) {\n                        tr.append(\"td\").style(\"border\", 1).style(\"text-align\", \"center\").style(\"position\", \"relative\").style(\"background-color\", app.varColor).text(data[z].value);\n                    }\n                }\n            }\n        }\n    }\n\n    crossTab_Table(json);\n\n    var plotAval = varsize1,\n        plotBval = varsize2;\n    if (isNaN(plotAval)) plotAval = 10;\n    if (isNaN(plotBval)) plotBval = 10;\n    var crosstabs = {\n        var1: {\n            name: plotnamea,\n            value: plotAval,\n            buttonType: varn1\n        },\n        var2: {\n            name: plotnameb,\n            value: plotBval,\n            buttonType: varn2\n        }\n    };\n\n    function removeData(key) {\n        for (var key1 in app.zparams) {\n            if (app.zparams.hasOwnProperty(key1) && key === key1 && app.zparams[key1.length] > 0) app.zparams[key1] = [];\n        }\n    }\n\n    var zbreaks = [];\n    var zbreaks_tabular = [];\n    $('#SelectionData1').click(function () {\n        d3.select(\"#tabular_2\").html(\"\");\n        removeData('zcrosstab');\n        app.zparams.zcrosstab.push(crosstabs);\n        explore_crosstab(json);\n        app.estimateLadda.stop();\n        app.estimated = true;\n        zbreaks.push(crosstabs);\n        zbreaks_tabular.push(json.tabular);\n        d3.select('#breakspace').append(\"span\").text('\\xA0 \\xA0 \\xA0 \\xA0   ').style(\"margin-top\", 0).style(\"white-space\", \"pre\").style(\"display\", \"inline-block\").style(\"float\", \"left\").append(\"span\").append(\"button\") // top stack for results\n        .attr(\"class\", \"btn btn-default btn-xs\").attr(\"id\", zbreaks.length).text(\"break \" + (zbreaks.length + 1)).on(\"click\", function () {\n            d3.select(\"#tabular_2\").html(\"\");\n            removeData();\n            app.zparams.zcrosstab.push(zbreaks[this.id]);\n            explore_crosstab(zbreaks_tabular[this.id]);\n\n            var inputvalue1, inputvalue2;\n            inputvalue1 = zbreaks[this.id].var1.value;\n            inputvalue2 = zbreaks[this.id].var2.value;\n            document.getElementById(\"input1\").value = inputvalue1;\n            document.getElementById(\"input2\").value = inputvalue2;\n\n            var json_obj = zbreaks[this.id];\n            var varn1, varn2, varsize1, varsize2;\n            if (json_obj.length === 0) {\n                console.log(\"break not called\");\n            } else {\n                varn1 = json_obj.var1.buttonType;\n                varn2 = json_obj.var2.buttonType;\n                varsize1 = json_obj.var1.value;\n                varsize2 = json_obj.var2.value;\n                if (varn1 === \"equidistance\") {\n                    crossTabPlots.equidistance(get_data[0], varsize1);\n                } else if (varn1 === \"equimass\") {\n                    crossTabPlots.equimass(get_data[0], varsize1);\n                }\n                if (varn2 === \"equidistance\") {\n                    crossTabPlots.equidistance(get_data[1], varsize2);\n                } else if (varn2 === \"equimass\") {\n                    crossTabPlots.equimass(get_data[1], varsize2);\n                }\n            }\n        });\n    });\n\n    async function explore_crosstab(btn) {\n        if (app.downloadIncomplete()) {\n            return;\n        }\n        app.zPop();\n\n        app.estimateLadda.start();\n        // write links to file & run R CMD\n        app.zparams.callHistory = app.callHistory;\n        var json = await app.makeRequest(ROOK_SVC_URL + 'exploreapp', app.zparams);\n        app.estimateLadda.start();\n        app.estimated = false;\n        d3.json(\"static/result.json\", function (err, json) {\n            if (err) {\n                return console.warn(err);\n            }\n            crossTab_Table(json);\n            app.estimateLadda.stop();\n            app.estimated = true;\n        });\n    }\n\n    // data for the statistical div\n    var string1 = cork.toString();\n    var string3 = string1.substring(string1.indexOf(\":\"), string1.length);\n    var string2 = string1.substring(0, string1.indexOf(\"c\"));\n    var string4 = corp.toString();\n    var string6 = string4.substring(string4.indexOf(\":\"), string4.length);\n    var string5 = string4.substring(0, string4.indexOf(\"c\"));\n    var string7 = cors.toString();\n    var string9 = string7.substring(string7.indexOf(\":\"), string7.length);\n    var string8 = string7.substring(0, string7.indexOf(\"c\"));\n    var statistical_data = [{ correlation: string2, value: string3 }, { correlation: string5, value: string6 }, { correlation: string8, value: string9 }];\n\n    function d3table(data) {\n        d3.select(\"#resultsView_statistics\").html(\"\").style(\"background-color\", \"#fff\").append(\"h5\").text(\"CORRELATION STATISTICS \").style(\"color\", \"#424242\");\n        var table = d3.select(\"#resultsView_statistics\").append(\"table\").attr(\"class\", \"table\").style(\"border-collapse\", \" collapse\"),\n            th = table.append(\"tr\").style(\"border\", 1);\n        for (var i in Object.keys(data[0])) {\n            th.append(\"td\").style(\"border-bottom\", 1).style(\"text-align\", \"left\").style(\"background-color\", plots.selVarColor).append(\"b\").text(Object.keys(data[0])[i]);\n        }\n        for (var row in data) {\n            var tr = table.append(\"tr\").style(\"margin-left\", 40).style(\"border\", 1).style(\"text-align\", \"left\");\n            for (var td in data[row]) {\n                tr.append(\"td\").style(\"border\", 1).style(\"text-align\", \"left\").style(\"position\", \"relative\").style(\"background-color\", app.varColor).text(data[row][td]);\n            }\n        }\n    }\n    d3table(statistical_data);\n}\n\nfunction model_selection(model_selection_name, count_value, json) {\n    if (count_value % 2 == 0 && count_value != 0) {\n        d3.select(\"#modelView\").append(\"span\").text('\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 ').style(\"margin-top\", 0).style(\"white-space\", \"pre\").style(\"display\", \"inline-block\").style(\"float\", \"left\").append(\"span\").text(\"|\").style(\"margin-top\", 0).style(\"white-space\", \"pre\").style(\"display\", \"inline-block\").style(\"float\", \"left\").append(\"span\").text('\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 ').style(\"margin-top\", 0).style(\"white-space\", \"pre\").style(\"display\", \"inline-block\").style(\"float\", \"left\");\n    }\n    d3.select(\"#modelView\").append(\"span\").text(' \\xA0').style(\"margin-top\", 0).style(\"float\", \"left\").style(\"display\", \"inline-block\").style(\"white-space\", \"pre\").style(\"overflow-y\", \"hidden\").style(\"overflow-x\", \"scroll\").append(\"button\") // top stack for results\n    //      .append(\"xhtml:button\")\n    .attr(\"class\", \"btn btn-outline-success\").style(\"padding\", \"4px\").attr(\"id\", model_selection_name).text(model_selection_name).style('background-color', function () {\n        var color1 = \"#FFD54F\";\n        return count == count1 ? plots.selVarColor : color1;\n    }).style(\"display\", \"inline-block\").style(\"white-space\", \"pre\").style(\"margin-top\", 0).style(\"float\", \"left\").on(\"click\", function () {\n        var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n        var b = app.hexToRgba(plots.selVarColor).replace(/\\s*/g, \"\");\n        if (a.substr(0, 17) === b.substr(0, 17)) {\n            return; //escapes the function early if the displayed model is clicked\n        }\n        viz(this.id, json, model_selection_name);\n        d3.select(\"#modelView\").selectAll(\"button\").style('background-color', \"#FFD54F\");\n        d3.select(this).style('background-color', plots.selVarColor);\n    });\n}\n\nfunction showLog() {\n    if (app.logArray.length > 0) {\n        app.byId('logdiv').setAttribute(\"style\", \"display:block\");\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(app.logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n        return;\n    }\n    app.byId('logdiv').setAttribute(\"style\", \"display:none\");\n}\n\nfunction univariatePart() {\n    d3.select(\"#decisionTree\").style(\"display\", \"block\");\n    d3.select(\"#left_thumbnail\").style(\"display\", \"none\");\n    d3.select(\"#result_left\").style(\"display\", \"none\");\n    d3.select(\"#result_left1\").style(\"display\", \"none\");\n    d3.select(\"#result_right\").style(\"display\", \"none\");\n    d3.select(\"#modelView_Container\").style(\"display\", \"none\");\n    d3.select(\"#modelView\").style(\"display\", \"none\");\n    d3.select(\"#resultsView_tabular\").style(\"display\", \"none\");\n    d3.select(\"#plotA\").style(\"display\", \"none\");\n    d3.select(\"#plotB\").style(\"display\", \"none\");\n    d3.select(\"#SelectionData\").style(\"display\", \"none\");\n    d3.select(\"#resultsView_statistics\").style(\"display\", \"none\");\n}\n\nvar count = 0;\nvar count1 = 0;\n\n/**\n   called by clicking 'Explore' in explore mode\n*/\nasync function explore() {\n    if (app.downloadIncomplete()) {\n        return;\n    }\n\n    app.zPop();\n    console.log('zpop:', app.zparams);\n\n    // write links to file & run R CMD\n    app.zparams.callHistory = app.callHistory;\n    app.estimateLadda.start(); // start spinner\n    var json = await app.makeRequest(ROOK_SVC_URL + 'exploreapp', app.zparams);\n    if (!json) {\n        return;\n    }\n    app.allResults.push(json);\n\n    d3.select('#rightpanel').style('width', '75%');\n\n    var parent = app.byId('rightContentArea');\n    app.estimated || parent.removeChild(app.byId('resultsHolder'));\n    app.estimated = true;\n\n    d3.select(\"#decisionTree\").style(\"display\", \"none\");\n    d3.select(\"#modelView\").html('');\n    d3.select(\"#resultsView_statistics\").html('');\n    [\"#left_thumbnail\", \"#result_left\", \"#result_left1\", \"#result_right\", \"#modelView_Container\", \"#modelView\", \"#resultsView_tabular\", \"#plotA\", \"#plotB\", \"#SelectionData\", \"#resultsView_statistics\"].forEach(function (id) {\n        return d3.select(id).style(\"display\", \"block\");\n    });\n\n    d3.select(\"#modelView\").style('background-color', app.hexToRgba(app.varColor)).style(\"overflow-y\", \"hidden\").style(\"overflow-x\", \"scroll\").append(\"span\").style(\"white-space\", \"pre\").style(\"margin-top\", 0).style(\"float\", \"left\").style(\"position\", \"relative\").style(\"color\", \"#757575\").text(\"MODEL SELECTION :  \");\n\n    // programmatic click on Results button\n    $(\"#btnBivariate\").trigger(\"click\");\n    var model_name = void 0;\n    for (var img in json.images) {\n        if (count === 0) {\n            model_name = img;\n        }\n        model_selection(img, count, json); // for entering all the variables\n        count++;\n    }\n    count1 = count - 1;\n    app.modelCount++;\n\n    var rCall = [];\n    rCall[0] = json.call;\n    app.logArray.push(\"explore: \".concat(rCall[0]));\n    showLog();\n    viz(model_name, json, model_name);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL2V4cGxvcmUuanM/ZmZmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4vYXBwJztcbmltcG9ydCAqIGFzIHBsb3RzIGZyb20gJy4vcGxvdHMnO1xuXG5jb25zdCAkcHJpdmF0ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoZWF0bWFwKHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWF0Y2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGQzLnNlbGVjdChcIiNoZWF0Y2hhcnRcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICQoJyNoZWF0Y2hhcnQnKS5odG1sKFwiXCIpO1xuXG4gICAgdmFyIG1hcmdpbl9oZWF0ID0ge3RvcDogMzAsIHJpZ2h0OiAxMCwgYm90dG9tOiA2MCwgbGVmdDogNjB9LFxuICAgICAgICB3aWR0aF9oZWF0ID0gNTAwIC0gbWFyZ2luX2hlYXQubGVmdCAtIG1hcmdpbl9oZWF0LnJpZ2h0LFxuICAgICAgICBoZWlnaHRfaGVhdCA9IDMwMCAtIG1hcmdpbl9oZWF0LnRvcCAtIG1hcmdpbl9oZWF0LmJvdHRvbTtcbiAgICB2YXIgcGFkZGluZyA9IDEwMDtcblxuICAgIHZhciBtaW5feCA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgfSk7XG4gICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICB9KTtcbiAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwMDtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3ggLSBhdmdfeCwgbWF4X3ggKyBhdmdfeF0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhfaGVhdF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5feSAtIGF2Z195LCBtYXhfeSArIGF2Z195XSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHRfaGVhdCwgMF0pO1xuXG4gICAgdmFyIHogPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbXCIjRUY5QTlBXCIsIFwiI0VGNTM1MFwiXSk7XG5cbiAgICAvLyBUaGlzIGNvdWxkIGJlIGluZmVycmVkIGZyb20gdGhlIGRhdGEgaWYgaXQgd2VyZW4ndCBzcGFyc2UuXG4gICAgdmFyIHhTdGVwID0gYXZnX3grIDAuMSxcbiAgICAgICAgeVN0ZXAgPSBhdmdfeSArIDAuMjtcbiAgICB2YXIgc3ZnX2hlYXQgPSBkMy5zZWxlY3QoXCIjaGVhdGNoYXJ0XCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoX2hlYXQgKyBtYXJnaW5faGVhdC5sZWZ0ICsgbWFyZ2luX2hlYXQucmlnaHQpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodF9oZWF0ICsgbWFyZ2luX2hlYXQudG9wICsgbWFyZ2luX2hlYXQuYm90dG9tKVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbl9oZWF0LmxlZnQgKyBcIixcIiArIG1hcmdpbl9oZWF0LnRvcCsgXCIpXCIpXG4gICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRkZFQkVFXCIpO1xuXG5cbiAgICAvLyBDb21wdXRlIHRoZSBzY2FsZSBkb21haW5zLlxuICAgIHguZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgfSkpO1xuICAgIHkuZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSkpO1xuICAgIHouZG9tYWluKFswLCBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnNjb3JlO1xuICAgIH0pXSk7XG5cbiAgICAvLyBFeHRlbmQgdGhlIHgtIGFuZCB5LWRvbWFpbiB0byBmaXQgdGhlIGxhc3QgYnVja2V0LlxuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgeS1idWNrZXQgMzIwMCBjb3JyZXNwb25kcyB0byB2YWx1ZXMgWzMyMDAsIDMzMDBdLlxuICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdLCAreC5kb21haW4oKVsxXSArIHhTdGVwXSk7XG4gICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0sIHkuZG9tYWluKClbMV0gKyB5U3RlcF0pO1xuXG4gICAgLy8gRGlzcGxheSB0aGUgdGlsZXMgZm9yIGVhY2ggbm9uLXplcm8gYnVja2V0LlxuICAgIC8vIFNlZSBodHRwOi8vYmwub2Nrcy5vcmcvMzA3NDQ3MCBmb3IgYW4gYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgc3ZnX2hlYXQuc2VsZWN0QWxsKFwiLnRpbGVcIilcbiAgICAgICAgLmRhdGEoZGF0YV9wbG90KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWxlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geShkYXRhX3Bsb3RbaV0ueWF4aXMgKyB5U3RlcCApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDE1KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxNSlcbiAgICAgICAgLmF0dHIoXCJkeFwiLCBcIi4zNWVtXCIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geihkYXRhX3Bsb3RbaV0uc2NvcmUpO1xuICAgICAgICB9KTtcblxuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoX2hlYXQgKyAyMClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDEwKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgLnRleHQoXCJDb3VudFwiKTtcblxuICAgIC8vIEFkZCBhbiB4LWF4aXMgd2l0aCBsYWJlbC5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9oZWF0ICsgXCIpXCIpXG4gICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKCkuc2NhbGUoeCkudGlja3MoNSkudGlja1NpemUoLWhlaWdodF9oZWF0KS5vcmllbnQoXCJib3R0b21cIikpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgd2lkdGhfaGVhdClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC02KVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC50ZXh0KFwiXCIpO1xuXG4gICAgLy8gQWRkIGEgeS1heGlzIHdpdGggbGFiZWwuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKCkuc2NhbGUoeSkudGlja1NpemUoLXdpZHRoX2hlYXQpLm9yaWVudChcImxlZnRcIikpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInlcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAgICAgICAudGV4dChcIlwiKTtcblxuICAgIHN2Z19oZWF0LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtNDAsXCIgKyAoaGVpZ2h0X2hlYXQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGhfaGVhdCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0X2hlYXQgKyBwYWRkaW5nIC8gNCkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG59XG5cbmxldCBoZWF0eGF4aXMsIGhlYXR5YXhpcztcbmxldCBkYXRhX3Bsb3QgPSBbXTtcblxuZnVuY3Rpb24gYml2YXJpYXRlUGxvdCh4X0F4aXMsIHlfQXhpcywgeF9BeGlzX25hbWUsIHlfQXhpc19uYW1lKSB7XG4gICAgaGVhdHhheGlzID0geF9BeGlzX25hbWU7XG4gICAgaGVhdHlheGlzID0geV9BeGlzX25hbWU7XG4gICAgYXBwLmJ5SWQoJ3NjYXR0ZXJwbG90Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgZDMuc2VsZWN0KFwiI3NjYXR0ZXJwbG90XCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3NjYXR0ZXJwbG90XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcblxuICAgIC8vIHNjYXR0ZXIgcGxvdFxuICAgIGRhdGFfcGxvdCA9IFtdO1xuICAgIGxldCBuYW5Db3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKHhfQXhpc1tpXSkgfHwgaXNOYU4oeV9BeGlzW2ldKSkge1xuICAgICAgICAgICAgbmFuQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdOdW1iZXIxID0geF9BeGlzW2ldO1xuICAgICAgICAgICAgbGV0IG5ld051bWJlcjIgPSB5X0F4aXNbaV07XG4gICAgICAgICAgICBkYXRhX3Bsb3QucHVzaCh7eGF4aXM6IG5ld051bWJlcjEsIHlheGlzOiBuZXdOdW1iZXIyLCBzY29yZTogTWF0aC5yYW5kb20oKSAqIDEwMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMTUsIGJvdHRvbTogNDAsIGxlZnQ6IDYwfSxcbiAgICAgICAgd2lkdGggPSA1MDAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgaGVpZ2h0ID0gMjgwIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgIHBhZGRpbmcgPSAxMDA7XG5cbiAgICBsZXQgbWluX3ggPSBkMy5taW4oZGF0YV9wbG90LCAoXywgaSkgPT4gZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICBsZXQgbWF4X3ggPSBkMy5tYXgoZGF0YV9wbG90LCAoXywgaSkgPT4gZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDtcbiAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBtYXhfeSA9IGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSk7XG4gICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG5cbiAgICB2YXIgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3ggLSBhdmdfeCwgbWF4X3ggKyBhdmdfeF0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5feSAtIGF2Z195LCBtYXhfeSArIGF2Z195XSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHhTY2FsZSlcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tTaXplKC1oZWlnaHQpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeVNjYWxlKVxuICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICAgICAgLnRpY2tzKDUpXG4gICAgICAgIC50aWNrU2l6ZSgtd2lkdGgpO1xuXG4gICAgdmFyIHpvb20gPSBkMy5iZWhhdmlvci56b29tKClcbiAgICAgICAgLngoeFNjYWxlKVxuICAgICAgICAueSh5U2NhbGUpXG4gICAgICAgIC5zY2FsZUV4dGVudChbMSwgMTBdKVxuICAgICAgICAub24oXCJ6b29tXCIsIHpvb21lZCk7XG5cbiAgICB2YXIgY2hhcnRfc2NhdHRlciA9IGQzLnNlbGVjdCgnI3NjYXR0ZXJwbG90JylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnN2ZycpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmNhbGwoem9vbSk7XG5cbiAgICB2YXIgbWFpbjEgPSBjaGFydF9zY2F0dGVyLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbWFpbicpO1xuXG4gICAgbWFpbjEuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0ICsgJyknKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAneCBheGlzJylcbiAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgbWFpbjEuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd5IGF4aXMnKVxuICAgICAgICAuY2FsbCh5QXhpcyk7XG5cbiAgICB2YXIgY2xpcCA9IG1haW4xLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwic3ZnOmNsaXBQYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6cmVjdFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiY2xpcC1yZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCBcIjBcIilcbiAgICAgICAgLmF0dHIoXCJ5XCIsIFwiMFwiKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICBtYWluMS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI2NsaXApXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAgICAgLmRhdGEoZGF0YV9wbG90KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgIC5hdHRyKFwiY3hcIiwgKF8sIGkpID0+IHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpKVxuICAgICAgICAuYXR0cihcImN5XCIsIChfLCBpKSA9PiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpO1xuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAvIDUgKyBcIixcIiArIChoZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBjaGFydF9zY2F0dGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0ICsgKHBhZGRpbmcgLyAyKSkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBmdW5jdGlvbiB6b29tZWQoKSB7XG4gICAgICAgIHZhciBwYW5YID0gZDMuZXZlbnQudHJhbnNsYXRlWzBdO1xuICAgICAgICB2YXIgcGFuWSA9IGQzLmV2ZW50LnRyYW5zbGF0ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlID0gZDMuZXZlbnQuc2NhbGU7XG5cbiAgICAgICAgcGFuWCA9IHBhblggPiAxMCA/IDEwIDogcGFuWDtcbiAgICAgICAgdmFyIG1heFggPSAtKHNjYWxlIC0gMSkgKiB3aWR0aCAtIDEwO1xuICAgICAgICBwYW5YID0gcGFuWCA8IG1heFggPyBtYXhYIDogcGFuWDtcblxuICAgICAgICBwYW5ZID0gcGFuWSA+IDEwID8gMTAgOiBwYW5ZO1xuICAgICAgICB2YXIgbWF4WSA9IC0oc2NhbGUgLSAxKSAqIGhlaWdodCAtIDEwO1xuICAgICAgICBwYW5ZID0gcGFuWSA8IG1heFkgPyBtYXhZIDogcGFuWTtcblxuICAgICAgICB6b29tLnRyYW5zbGF0ZShbcGFuWCwgcGFuWV0pO1xuXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCAoXywgaSkgPT4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcykpXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIChfLCBpKSA9PiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKSlcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCAyLjUpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKTtcbiAgICB9XG5cbiAgICBkMy5zZWxlY3QoJyNOQWNvdW50Jykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICBkMy5zZWxlY3QoXCIjTkFjb3VudFwiKS50ZXh0KFwiVGhlcmUgYXJlIFwiICsgbmFuQ291bnQgKyBcIiBudW1iZXIgb2YgTkEgdmFsdWVzIGluIHRoZSByZWxhdGlvbi5cIik7XG59XG5cbmxldCBwbG90bmFtZWEsIHBsb3RuYW1lYiwgdmFybjEsIHZhcm4yLCB2YXJzaXplMSwgdmFyc2l6ZTI7XG5cbmxldCBjb250aW51b3VzX24gPSAwO1xubGV0IGJhcl9uID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldF93aWR0aChpZCkge1xuICAgIHJldHVybiA1MCAqIChpZCA9PT0gJ3Bsb3RBJyA/IGNvbnRpbnVvdXNfbiA6IGJhcl9uKTtcbn1cblxuZnVuY3Rpb24gY3Jvc3NUYWJQbG90cyhQbG90TmFtZUEsIFBsb3ROYW1lQiwganNvbl9vYmopIHtcbiAgICBwbG90bmFtZWEgPSBQbG90TmFtZUE7XG4gICAgcGxvdG5hbWViID0gUGxvdE5hbWVCO1xuICAgICQoXCIjaW5wdXQxXCIpLmF0dHIoXCJwbGFjZWhvbGRlclwiLCBQbG90TmFtZUEpLmJsdXIoKTtcbiAgICAkKFwiI2lucHV0MlwiKS5hdHRyKFwicGxhY2Vob2xkZXJcIiwgUGxvdE5hbWVCKS5ibHVyKCk7XG4gICAgbGV0IFtwbG90X2EsIHBsb3RfYl0gPSBbJyNwbG90QScsICcjcGxvdEInXTtcblxuICAgIHZhciBtYXJnaW5fY3Jvc3MgPSB7dG9wOiAzMCwgcmlnaHQ6IDM1LCBib3R0b206IDQwLCBsZWZ0OiA0MH0sXG4gICAgICAgIHdpZHRoX2Nyb3NzID0gMzAwIC0gbWFyZ2luX2Nyb3NzLmxlZnQgLSBtYXJnaW5fY3Jvc3MucmlnaHQsXG4gICAgICAgIGhlaWdodF9jcm9zcyA9IDE2MCAtIG1hcmdpbl9jcm9zcy50b3AgLSBtYXJnaW5fY3Jvc3MuYm90dG9tO1xuICAgIHZhciBwYWRkaW5nX2Nyb3NzID0gMTAwO1xuXG4gICAgZDMuc2VsZWN0KFwiI2lucHV0MVwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Rvb2x0aXBQbG90QVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixcIjFcIilcbiAgICAgICAgICAgIC50ZXh0KFBsb3ROYW1lQSk7XG4gICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbigpe1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3Rvb2x0aXBQbG90QVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsXCIwXCIpO1xuICAgICAgICB9KTtcbiAgICBkMy5zZWxlY3QoXCIjaW5wdXQyXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdG9vbHRpcFBsb3RCXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLFwiMVwiKVxuICAgICAgICAgICAgLnRleHQoUGxvdE5hbWVCKTtcbiAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdG9vbHRpcFBsb3RCXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixcIjBcIik7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIHBsb3Rfbm9kZXMgPSBhcHAubm9kZXMuc2xpY2UoKTtcbiAgICBmb3IgKGxldCBub2RlIG9mIHBsb3Rfbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gUGxvdE5hbWVBKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51b3VzX24rKztcbiAgICAgICAgICAgICAgICBkZW5zaXR5X2Nyb3NzKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgYmFyX24rKztcbiAgICAgICAgICAgICAgICBiYXJfY3Jvc3Mobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5uYW1lID09PSBQbG90TmFtZUIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNfbisrO1xuICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3Mobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICBiYXJfbisrO1xuICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwbG90QV9zaXplLCBwbG90Ql9zaXplLCBwbG90QV9zaXplbSwgcGxvdEJfc2l6ZW07XG4gICAgbGV0IHZhcm4xLCB2YXJuMiwgdmFyc2l6ZTEsIHZhcnNpemUyO1xuICAgICQoXCIjRXF1aWRpc3RhbmNlMVwiKS5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICB2YXJuMSA9IFwiZXF1aWRpc3RhbmNlXCI7XG4gICAgICAgIHBsb3RBX3NpemUgPSBwYXJzZUludChkMy5zZWxlY3QoXCIjaW5wdXQxXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgdmFyc2l6ZTEgPSBwbG90QV9zaXplO1xuICAgICAgICBlcXVpZGlzdGFuY2UoUGxvdE5hbWVBLCBwbG90QV9zaXplKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbG90QV9zdGF0dXNcIikuaW5uZXJIVE1MID0gYCR7UGxvdE5hbWVBfSA6ICR7dmFybjF9IGRpc3RyaWJ1dGlvbiB3aXRoICR7dmFyc2l6ZTF9IGRpdmlzaW9uc2A7XG4gICAgfSk7XG4gICAgJChcIiNFcXVpbWFzczFcIikuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgcGxvdEFfc2l6ZW0gPSBwYXJzZUludChkMy5zZWxlY3QoXCIjaW5wdXQxXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgdmFyc2l6ZTEgPSBwbG90QV9zaXplbTtcbiAgICAgICAgZXF1aW1hc3MoUGxvdE5hbWVBLCBwbG90QV9zaXplbSk7XG4gICAgICAgIHZhcm4xID0gXCJlcXVpbWFzc1wiO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsb3RBX3N0YXR1c1wiKS5pbm5lckhUTUwgPSBgJHtQbG90TmFtZUF9IDogJHt2YXJuMX0gZGlzdHJpYnV0aW9uIHdpdGggJHt2YXJzaXplMX0gZGl2aXNpb25zYDtcbiAgICB9KTtcbiAgICAkKFwiI0VxdWlkaXN0YW5jZTJcIikuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFybjIgPSBcImVxdWlkaXN0YW5jZVwiO1xuICAgICAgICBwbG90Ql9zaXplID0gcGFyc2VJbnQoZDMuc2VsZWN0KFwiI2lucHV0MlwiKVswXVswXS52YWx1ZSk7XG4gICAgICAgIGVxdWlkaXN0YW5jZShQbG90TmFtZUIsIHBsb3RCX3NpemUpO1xuICAgICAgICB2YXJzaXplMiA9IHBsb3RCX3NpemU7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdEJfc3RhdHVzXCIpLmlubmVySFRNTCA9IGAke1Bsb3ROYW1lQn0gOiAke3Zhcm4yfSBkaXN0cmlidXRpb24gd2l0aCAke3ZhcnNpemUyfSBkaXZpc2lvbnNgO1xuICAgIH0pO1xuICAgICQoXCIjRXF1aW1hc3MyXCIpLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhcm4yID0gXCJlcXVpbWFzc1wiO1xuICAgICAgICBwbG90Ql9zaXplbSA9IHBhcnNlSW50KGQzLnNlbGVjdChcIiNpbnB1dDJcIilbMF1bMF0udmFsdWUpO1xuICAgICAgICBlcXVpbWFzcyhQbG90TmFtZUIsIHBsb3RCX3NpemVtKTtcbiAgICAgICAgdmFyc2l6ZTIgPSBwbG90Ql9zaXplbTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbG90Ql9zdGF0dXNcIikuaW5uZXJIVE1MID0gYCR7UGxvdE5hbWVCfSA6ICR7dmFybjJ9IGRpc3RyaWJ1dGlvbiB3aXRoICR7dmFyc2l6ZTJ9IGRpdmlzaW9uc2A7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBmdW5jdGlvbiB0byBhZGQgIHRoZSBkZW5zaXR5IHBsb3QgaWYgYW55XG4gICAgZnVuY3Rpb24gZGVuc2l0eV9jcm9zcyhkZW5zaXR5X2VudixhLG1ldGhvZF9uYW1lKSB7XG4gICAgICAgIC8vIHNldHVwIHRoZSB4X2NvcmQgYWNjb3JkaW5nIHRvIHRoZSBzaXplIGdpdmVuIGJ5IHVzZXJcbiAgICAgICAgdmFyIHlWYWxzID0gZGVuc2l0eV9lbnYucGxvdHk7XG4gICAgICAgIHZhciB4VmFscyA9IGRlbnNpdHlfZW52LnBsb3R4O1xuXG4gICAgICAgIC8vIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgdmFyIGRhdGEyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVuc2l0eV9lbnYucGxvdHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGEyLnB1c2goe3g6IGRlbnNpdHlfZW52LnBsb3R4W2ldLCB5OiBkZW5zaXR5X2Vudi5wbG90eVtpXX0pO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEyLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQueCA9ICtkLng7XG4gICAgICAgICAgICBkLnkgPSArZC55O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbWluX3ggPSBkMy5taW4oZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhfeCA9IGQzLm1heChkYXRhMiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMltpXS54O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgICAgIHZhciBtaW5feSA9IGQzLm1pbihkYXRhMiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMltpXS55O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGEyLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEyW2ldLnk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYXZnX3kgPSAobWF4X3kgLSBtaW5feSkgLyAxMDtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoX2Nyb3NzXSk7XG4gICAgICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbZDMubWluKGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLng7XG4gICAgICAgICAgICB9KSksIGQzLm1heChkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC54O1xuICAgICAgICAgICAgfSkpXSlcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHdpZHRoX2Nyb3NzXSk7XG4gICAgICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1pbihkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC55O1xuICAgICAgICAgICAgfSkpLCBkMy5tYXgoZGF0YTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQueTtcbiAgICAgICAgICAgIH0pKV0pXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodF9jcm9zcywgMF0pO1xuICAgICAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC50aWNrcyg1KVxuICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcbiAgICAgICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcbiAgICAgICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geChkLngpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC55MChoZWlnaHRfY3Jvc3MgLSBhdmdfeSlcbiAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5KGQueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQueCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KHBsb3RfYSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJwbG90c3ZnX2lkXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aF9jcm9zcyArIG1hcmdpbl9jcm9zcy5sZWZ0ICsgbWFyZ2luX2Nyb3NzLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodF9jcm9zcyArIG1hcmdpbl9jcm9zcy50b3AgKyBtYXJnaW5fY3Jvc3MuYm90dG9tKVxuICAgICAgICAgICAgLnN0eWxlKFwibWFyZ2luLWxlZnRcIixcIjIwcHhcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgbWFyZ2luX2Nyb3NzLnRvcCArIFwiKVwiKTtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicGF0aDFcIilcbiAgICAgICAgICAgIC5kYXR1bShkYXRhMilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIChoZWlnaHRfY3Jvc3MgICkgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoX2Nyb3NzIC8gMikpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgKG1hcmdpbl9jcm9zcy50b3AgKyBwYWRkaW5nX2Nyb3NzIC0xMCkpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChkZW5zaXR5X2Vudi5uYW1lKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICAgICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IDApIHtcbiAgICAgICAgICAgIHZhciB1cHBlcl9saW1pdCA9IGQzLm1heCh4VmFscyk7XG4gICAgICAgICAgICB2YXIgbG93ZXJfbGltaXQgPSBkMy5taW4oeFZhbHMpO1xuICAgICAgICAgICAgdmFyIHogPSAxMDtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdXBwZXJfbGltaXQgLSBsb3dlcl9saW1pdDtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBkaWZmIC8gejtcbiAgICAgICAgICAgIHZhciB4X2NvcmQgPSBbXTtcbiAgICAgICAgICAgIHZhciBwdXNoX2RhdGEgPSBsb3dlcl9saW1pdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHB1c2hfZGF0YSA9IHB1c2hfZGF0YSArIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB4X2NvcmQucHVzaChwdXNoX2RhdGEpO1xuICAgICAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTFcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KHhfY29yZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeCh4X2NvcmRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkoZDMubWluKHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShkMy5tYXgoeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiM1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZXRob2RfbmFtZSA9PT0gXCJlcXVpZGlzdGFuY2VcIikge1xuICAgICAgICAgICAgICAgIHZhciB1cHBlcl9saW1pdCA9IGQzLm1heCh4VmFscyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvd2VyX2xpbWl0ID0gZDMubWluKHhWYWxzKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHVwcGVyX2xpbWl0IC0gbG93ZXJfbGltaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGRpZmYgLyBhO1xuICAgICAgICAgICAgICAgIHZhciB4X2NvcmQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaF9kYXRhID0gbG93ZXJfbGltaXQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hfZGF0YSA9IHB1c2hfZGF0YSArIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgeF9jb3JkLnB1c2gocHVzaF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeCh4X2NvcmRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KHhfY29yZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkoZDMubWluKHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkoZDMubWF4KHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZF9uYW1lID09PSBcImVxdWltYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIHVzZSB0aGUgZGF0YSBmcm9tIGVxdWltYXNzQ2FsY3VsYXRpb24gdG8gZHJhdyBsaW5lc1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW107XG4gICAgICAgICAgICAgICAgdGVtcCA9IGVxdWltYXNzQ2FsY3VsYXRpb24oZGVuc2l0eV9lbnYsIGEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgodGVtcFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHgodGVtcFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkoZDMubWluKHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkoZDMubWF4KHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBmdW5jdGlvbiB0byBhZGQgdGhlIGJhciBwbG90IGlmIGFueVxuICAgIGZ1bmN0aW9uIGJhcl9jcm9zcyhiYXJfZW52LGEsbWV0aG9kX25hbWUpIHtcbiAgICAgICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgICAgICAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhiYXJfZW52LnBsb3R2YWx1ZXMpO1xuICAgICAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciBjaVVwcGVyVmFscyA9IG5ldyBBcnJheTtcbiAgICAgICAgdmFyIGNpTG93ZXJWYWxzID0gbmV3IEFycmF5O1xuICAgICAgICB2YXIgY2lTaXplO1xuXG4gICAgICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICAgICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgaWYgKGJhcl9lbnYubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiYXJfZW52LnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeVZhbHNbeGldID0gYmFyX2Vudi5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICAgICAgICAgIGlmICgkcHJpdmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFyX2Vudi5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW3hpXSA9IGJhcl9lbnYucGxvdFZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1t4aV0gPSBiYXJfZW52LnBsb3RWYWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW3hpXSAtIGNpTG93ZXJWYWxzW3hpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeVZhbEtleS5wdXNoKHt5OiB5VmFsc1t4aV0sIHg6IGtleXNbaV19KTtcbiAgICAgICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlWYWxLZXkuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgICAgICAgICBjaVVwcGVyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgICAgICAgICBjaUxvd2VyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB5VmFsc1tpXSA9IGJhcl9lbnYucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoJHByaXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhcl9lbnYucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1tpXSA9IGJhcl9lbnYucGxvdHZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1tpXSA9IGJhcl9lbnYucGxvdHZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbaV0gLSBjaUxvd2VyVmFsc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHlWYWxzLmxlbmd0aCA+IDE1ICYgYmFyX2Vudi5udW1jaGFyID09PSBcIm51bWVyaWNcIikgfCAoeVZhbHMubGVuZ3RoID4gNSAmIGJhcl9lbnYubnVtY2hhciA9PT0gXCJjaGFyYWN0ZXJcIikpIHtcbiAgICAgICAgICAgIHBsb3RYYXhpcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5ZPWQzLm1pbih5VmFscyk7XG4gICAgICAgIHZhciAgbWF4WSA9IGQzLm1heCh5VmFscyk7IC8vIGluIHRoZSBmdXR1cmUsIHNldCBtYXhZIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb25maWRlbmNlIGxpbWl0XG4gICAgICAgIHZhciAgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgICAgIHZhciAgbWF4WCA9IGQzLm1heCh4VmFscyk7XG4gICAgICAgIHZhciAgIHhfMSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhfY3Jvc3NdKTtcblxuICAgICAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhfY3Jvc3NdKTtcblxuICAgICAgICB2YXIgIHlfMSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC8vIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF9jcm9zc10pO1xuXG4gICAgICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh4XzEpXG4gICAgICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgICAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeV8xKVxuICAgICAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAgICAgdmFyIHBsb3RzdmcxID0gZDMuc2VsZWN0KHBsb3RfYilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIixcInBsb3RzdmcxX2lkXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aF9jcm9zcyArIG1hcmdpbl9jcm9zcy5sZWZ0ICsgbWFyZ2luX2Nyb3NzLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodF9jcm9zcyArIG1hcmdpbl9jcm9zcy50b3AgKyBtYXJnaW5fY3Jvc3MuYm90dG9tKVxuICAgICAgICAgICAgLnN0eWxlKFwibWFyZ2luLWxlZnRcIixcIjIwcHhcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgbWFyZ2luX2Nyb3NzLnRvcCArIFwiKVwiKTtcblxuICAgICAgICB2YXIgcmVjdFdpZHRoID0geF8xKG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZyk7IC8vdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgcGxvdHN2ZzEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIixcInBhdGgyXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geF8xKHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlfMShtYXhZIC0gZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5XzEoZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiI2ZhODA3MlwiKTtcblxuICAgICAgICBpZiAocGxvdFhheGlzKSB7XG4gICAgICAgICAgICBwbG90c3ZnMS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHRfY3Jvc3MgKyBcIilcIilcbiAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90c3ZnMS5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoX2Nyb3NzIC8gMikpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgbWFyZ2luX2Nyb3NzLnRvcCArIHBhZGRpbmdfY3Jvc3MtMTApXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChiYXJfZW52Lm5hbWUpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgICAgICBpZihpc05hTihhKXx8IGE9PT0wKSB7XG4gICAgICAgICAgICB4X2NvcmQyID0gZXF1aW1hc3NfYmFyKGJhcl9lbnYsIGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwbG90c3ZnMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMlwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeF8xKHhfY29yZDJbaV0gKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5XzEoMCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeV8xKG1heFkpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMjEyMTIxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1ldGhvZF9uYW1lID09PSBcImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwcGVyX2xpbWl0MSA9IG1heFg7XG4gICAgICAgICAgICAgICAgdmFyIGxvd2VyX2xpbWl0MSA9IG1pblg7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYxID0gdXBwZXJfbGltaXQxIC0gbG93ZXJfbGltaXQxO1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIxID0gZGlmZjEgLyBhO1xuICAgICAgICAgICAgICAgIHZhciB4X2NvcmQxID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHB1c2hfZGF0YTEgPSBsb3dlcl9saW1pdDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hfZGF0YTEgPSBwdXNoX2RhdGExICsgYnVmZmVyMTtcbiAgICAgICAgICAgICAgICAgICAgeF9jb3JkMS5wdXNoKHB1c2hfZGF0YTEpO1xuICAgICAgICAgICAgICAgICAgICBwbG90c3ZnMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeF8xKHhfY29yZDFbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4XzEoeF9jb3JkMVtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHlfMSgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeV8xKG1heFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2RfbmFtZT09PVwiZXF1aW1hc3NcIikge1xuICAgICAgICAgICAgICAgIHZhciB4X2NvcmQyID0gW107XG4gICAgICAgICAgICAgICAgeF9jb3JkMiA9IGVxdWltYXNzX2JhcihiYXJfZW52LCBhKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHlfMSgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeV8xKG1heFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aWRpc3RhbmNlKEEsYSkge1xuICAgICAgICB2YXIgbWV0aG9kX25hbWU9IFwiZXF1aWRpc3RhbmNlXCI7XG4gICAgICAgIC8vIGpzb24gb2JqZWN0IHRvIGJlIHNlbnQgdG8gciBzZXJ2ZXJcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgb2JqLnBsb3ROYW1lQSA9IEE7XG4gICAgICAgIG9iai5lcXVpZGlzdGFuY2UgPSBhO1xuICAgICAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbG90X25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5uYW1lID09PSBBKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjcGxvdHN2Z19pZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjcGxvdHN2ZzFfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1aW1hc3MoQSxhKSB7XG4gICAgICAgIC8vZXF1aW1hc3MgZnVuY3Rpb24gdG8gY2FsbCB0aGUgcGxvdCBmdW5jdGlvblxuICAgICAgICB2YXIgbWV0aG9kX25hbWU9IFwiZXF1aW1hc3NcIjtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgb2JqLnBsb3ROYW1lQSA9IEE7XG4gICAgICAgIG9iai5lcXVpZGlzdGFuY2UgPSBhO1xuICAgICAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbG90X25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5uYW1lID09PSBBKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjcGxvdHN2Z19pZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjcGxvdHN2ZzFfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVpbWFzc0NhbGN1bGF0aW9uKHBsb3RfZXYsbikge1xuICAgICAgICAvLyBoZXJlIHdlIGZpbmQgdGhlIGNvb3JkaW5hdGVzIHVzaW5nIENERiB2YWx1ZXNcbiAgICAgICAgLy92YXIgbiA9di0xO1xuICAgICAgICB2YXIgYXJyX3k9W107XG4gICAgICAgIHZhciBhcnJfeD1bXTtcblxuICAgICAgICBhcnJfeT1wbG90X2V2LmNkZnBsb3R5Oy8vIGNkZnBsb3R5IGRhdGEgc3RvcmVkXG4gICAgICAgIGFycl94PXBsb3RfZXYuY2RmcGxvdHg7Ly8gY2RmcGxvdHggZGF0YSBzdG9yZWRcblxuICAgICAgICB2YXIgVXBwZXJfbGltaXRZPSBkMy5tYXgoYXJyX3kpO1xuICAgICAgICB2YXIgTG93ZXJfbGltaXRZPWQzLm1pbihhcnJfeSk7XG4gICAgICAgIHZhciBkaWZmeT1VcHBlcl9saW1pdFktTG93ZXJfbGltaXRZO1xuICAgICAgICB2YXIgZT0oZGlmZnkpL247IC8vIGUgaXMgdGhlIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBhdmVyYWdlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyBpbiB0aGUgY2RmeSBpbiBvcmRlciB0byBkaXZpZGUgdGhlIGNkZnlcblxuICAgICAgICB2YXIgYXJyX2M9W107IC8vYXJyYXkgdG8gc3RvcmUgdGhlIGNkZnkgZGl2aWRlZCBjb29yZGluYXRlcyBkYXRhXG4gICAgICAgIHZhciBwdXNoX2RhdGE9YXJyX3lbMF07XG4gICAgICAgIGZvcih2YXIgaT0wO2k8bjtpKyspIHtcbiAgICAgICAgICAgIHB1c2hfZGF0YT1wdXNoX2RhdGErZTtcbiAgICAgICAgICAgIGFycl9jLnB1c2gocHVzaF9kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZW1wX2NkZng9W107XG4gICAgICAgIHZhciB0ZW1wPVtdO1xuICAgICAgICB2YXIgc3RvcmU9W107XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG47IGkrKykvL3RvIGdldCB0aHJvdWdoIGVhY2ggYXJyX2NcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA1MDsgaisrKS8vIHRvIGNvbXBhcmUgd2l0aCBjZGZ5IG9yIGFycl95XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGFycl9jW2ldID09PSBhcnJfeVtqXSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHt2YWw6IGksIGNvb3IxOiBqLCBjb29yMjogaiwgZGlmZjE6IDAuMzQsIGRpZmYyOiAwfSk7Ly8gZm9yIHRlc3RpbmcgcHVycG9zZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuO2krKykge1xuICAgICAgICAgICAgdmFyIGRpZmZfdmFsMSwgZGlmZl92YWwyOy8vIGhlcmUgdGhlIGRpZmYgaXMgbm90IGFjdHVhbCBkaWZmZXJlbmNlLCBpdCBpcyB0aGUgZnJhY3Rpb24gb2YgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHR3byBwb2ludHNcbiAgICAgICAgICAgIHZhciB4MSwgeDIsIHgzLHg0O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA1MDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycl95W2pdIDwgYXJyX2NbaV0gJiYgYXJyX2NbaV0gPCBhcnJfeVtqICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBhcnJfY1tpXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBhcnJfY1tpXS1hcnJfeVtqXTtcbiAgICAgICAgICAgICAgICAgICAgeDMgPSBhcnJfeVtqKzFdLWFycl9jW2ldO1xuICAgICAgICAgICAgICAgICAgICB4ND1hcnJfeVtqKzFdLWFycl95W2pdO1xuICAgICAgICAgICAgICAgICAgICBkaWZmX3ZhbDEgPSB4Mi8geDQ7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZfdmFsMiA9IHgzIC8geDQ7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goe3ZhbDogaSwgY29vcjE6IGosIGNvb3IyOiBqICsgMSwgZGlmZjE6IGRpZmZfdmFsMSwgZGlmZjI6IGRpZmZfdmFsMn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHkxLHkyLHkzLGRpZmZ5MSxkaWZmeTI7XG4gICAgICAgICAgICB5MT1zdG9yZVtpXS52YWw7XG4gICAgICAgICAgICB5Mj0gc3RvcmVbaV0uY29vcjE7XG4gICAgICAgICAgICB5Mz0gc3RvcmVbaV0uY29vcjI7XG4gICAgICAgICAgICBkaWZmeTE9c3RvcmVbaV0uZGlmZjE7XG4gICAgICAgICAgICBkaWZmeTI9c3RvcmVbaV0uZGlmZjI7XG4gICAgICAgICAgICB2YXIgeF9jb29yMT0gYXJyX3hbeTJdO1xuICAgICAgICAgICAgdmFyIHhfY29vcjI9YXJyX3hbeTNdO1xuICAgICAgICAgICAgdmFyIHhfZGlmZj14X2Nvb3IyLXhfY29vcjE7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UxPSB4X2RpZmYqZGlmZnkxO1xuICAgICAgICAgICAgdmFyIHZhbF94PXhfY29vcjErZGlzdGFuY2UxO1xuICAgICAgICAgICAgdGVtcC5wdXNoKHZhbF94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVpbWFzc19iYXIocGxvdF9ldixuKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGxvdF9ldi5wbG90dmFsdWVzKTtcbiAgICAgICAgdmFyIGsgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICBpZiAoayA8IG4pIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiZXJyb3IgZW50ZXIgdmFpbGQgc2l6ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAucHVzaCh7cG9zOiBjb3VudCwgdmFsOiBrfSk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRlbXAyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRlbXAyW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleXNbaV0gPSAoa2V5c1tpXSArIDUpIC8gMTA7Ly8gdG8gZ2V0IHRoZSBpbmNyZWFzZSBpbiB0aGUgYWN0dWFsIHZhbHVlcyBieSAwLjUgYWNjb3JkaW5nIHRvIHRoZSB4YXhpcyBpbiBwbG90XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcFtqXS5wb3MgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAyW2ldID0gdGVtcDJbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaiA9IDAsIGsgPSAwO1xuICAgICAgICAgICAgdmFyIHRlbXBfZmluYWwgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMltqXSA9IHRlbXAyW2pdIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcDJbal0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wX2ZpbmFsW2tdID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZW1wX2ZpbmFsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZWNoYXJ0KHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lY2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGQzLnNlbGVjdChcIiNsaW5lQ2hhcnRcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICQoJyNsaW5lY2hhcnQnKS5odG1sKFwiXCIpO1xuICAgIGxldCBwYWRkaW5nID0gMTA7XG4gICAgdmFyIHdfbGluZWNoYXJ0ID0gNDgwO1xuICAgIHZhciBoX2xpbmVjaGFydCA9IDMwMDtcbiAgICB2YXIgbWFyZ2luX2xpbmVjaGFydCA9IHt0b3A6IDIwLCByaWdodDogODAsIGJvdHRvbTogMzAsIGxlZnQ6IDUwfTtcbiAgICB2YXIgd2lkdGhfbGluZWNoYXJ0ID0gd19saW5lY2hhcnQgLSBtYXJnaW5fbGluZWNoYXJ0LmxlZnQgLSBtYXJnaW5fbGluZWNoYXJ0LnJpZ2h0O1xuICAgIHZhciBoZWlnaHRfbGluZWNoYXJ0ID0gaF9saW5lY2hhcnQgLSBtYXJnaW5fbGluZWNoYXJ0LnRvcCAtIG1hcmdpbl9saW5lY2hhcnQuYm90dG9tO1xuXG4gICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChcIiNsaW5lY2hhcnRcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjaGFydFwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdfbGluZWNoYXJ0KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoX2xpbmVjaGFydCk7XG4gICAgdmFyIGNoYXJ0ID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgLmNsYXNzZWQoXCJkaXNwbGF5XCIsIHRydWUpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luX2xpbmVjaGFydC5sZWZ0ICsgXCIsXCIgKyBtYXJnaW5fbGluZWNoYXJ0LnRvcCArIFwiKVwiKTtcbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oZDMuZXh0ZW50KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnhheGlzO1xuICAgICAgICB9KSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9saW5lY2hhcnRdKTtcbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC55YXhpcztcbiAgICAgICAgfSksIGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC55YXhpcztcbiAgICAgICAgfSldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodF9saW5lY2hhcnQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpXG4gICAgICAgIC50aWNrcyg1KTtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKVxuICAgICAgICAudGlja3MoNSk7XG4gICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4geChkLnhheGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueWF4aXMpO1xuICAgICAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJ4IGF4aXNcIiwgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHRfbGluZWNoYXJ0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChwYXJhbXMuYXhpcy54KTtcbiAgICAgICAgdGhpcy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInkgYXhpc1wiLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuICAgICAgICAgICAgLmNhbGwocGFyYW1zLmF4aXMueSk7XG4gICAgICAgIC8vZW50ZXIoKVxuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi50cmVuZGxpbmVcIilcbiAgICAgICAgICAgIC5kYXRhKFtwYXJhbXMuZGF0YV0pXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwidHJlbmRsaW5lXCIsIHRydWUpO1xuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi5wb2ludFwiKVxuICAgICAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJwb2ludFwiLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoXCJyXCIsIDIpO1xuICAgICAgICAvL3VwZGF0ZVxuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi50cmVuZGxpbmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnBvaW50XCIpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBkLnhheGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGRhdGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnlheGlzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiNFRjUzNTBcIik7XG4gICAgICAgIC8vZXhpdCgpXG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnRyZW5kbGluZVwiKVxuICAgICAgICAgICAgLmRhdGEoW3BhcmFtcy5kYXRhXSlcbiAgICAgICAgICAgIC5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAgICAgLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wID0gZDMuc2VsZWN0KFwiI21haW4ubGVmdFwiKS5zdHlsZShcIndpZHRoXCIpO1xuICAgIGxldCB3aWR0aCA9IHRlbXAuc3Vic3RyaW5nKDAsICh0ZW1wLmxlbmd0aCAtIDIpKTtcbiAgICBsZXQgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gMTIwO1xuICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwYWRkaW5nICArIFwiLFwiICsgKGhlaWdodCAvIDMpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcbiAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoIC8gNSkgKyBcIixcIiArIChoZWlnaHQgLSBwYWRkaW5nIC0gMTI4ICkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBwbG90LmNhbGwoY2hhcnQsIHtcbiAgICAgICAgZGF0YTogZGF0YV9wbG90LFxuICAgICAgICBheGlzOiB7XG4gICAgICAgICAgICB4OiB4QXhpcyxcbiAgICAgICAgICAgIHk6IHlBeGlzXG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdml6KG0sIGpzb25fdml6ZXhwbG9yZSwgbW9kZWxfbmFtZV9zZXQpIHtcbiAgICBkMy5zZWxlY3QoXCIjcGxvdEFcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcGxvdEJcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8xXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIikuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICBsZXQgZ2V0X2RhdGEgPSBtb2RlbF9uYW1lX3NldC5zcGxpdChcIi1cIik7XG4gICAgdmFyIG1vZGVsX25hbWUxID0gZ2V0X2RhdGFbMF0gKyBcIi1cIiArIGdldF9kYXRhWzFdO1xuICAgIHZhciBtb2RlbF9uYW1lMiA9IGdldF9kYXRhWzFdICsgXCItXCIgKyBnZXRfZGF0YVswXTtcbiAgICB2YXIgbXltID0gK20uc3Vic3RyKDUsIDUpIC0gMTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUtpZHMocGFyZW50KSB7XG4gICAgICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBqc29uID0ganNvbl92aXpleHBsb3JlO1xuICAgIC8vIHBpcGUgaW4gZmlndXJlcyB0byByaWdodCBwYW5lbFxuICAgIHZhciBmaWxlbGlzdCA9IG5ldyBBcnJheTtcblxuICAgIC8vIGltYWdlIGFkZGVkIHRvIHRoZSBkaXZcbiAgICB2YXIgeF9heGlzID0gW107XG4gICAgdmFyIHlfYXhpcyA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4ganNvbi5wbG90ZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBqIGluIGpzb24ucGxvdGRhdGFbaV0udmFybmFtZSkge1xuICAgICAgICAgICAgaWYgKGpzb24ucGxvdGRhdGFbaV0udmFybmFtZVtqXSA9PT0gZ2V0X2RhdGFbMF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGpzb24ucGxvdGRhdGFbaV0uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB4X2F4aXNba10gPSBqc29uLnBsb3RkYXRhW2ldLmRhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24ucGxvdGRhdGFbaV0udmFybmFtZVtqXSA9PT0gZ2V0X2RhdGFbMV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGpzb24ucGxvdGRhdGFbaV0uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB5X2F4aXNba10gPSBqc29uLnBsb3RkYXRhW2ldLmRhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYml2YXJpYXRlUGxvdCh4X2F4aXMsIHlfYXhpcywgZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdKTtcblxuICAgICQoJyNzY2F0dGVycGxvdF9pbWcnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAkKFwiI3NjYXR0ZXJwbG90X2ltZ1wiKS5mYWRlT3V0KFwiZmFzdFwiKS5mYWRlSW4oKS5mYWRlVG8oXCJmYXN0XCIsMS4wKTtcbiAgICB9KTtcbiAgICAkKCcjaGVhdG1hcF9pbWcnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAkKFwiI2hlYXRtYXBfaW1nXCIpLmZhZGVPdXQoXCJmYXN0XCIpLmZhZGVJbigpLmZhZGVUbyhcImZhc3RcIiwxLjApO1xuICAgIH0pO1xuICAgICQoJyNsaW5lY2hhcnRfaW1nJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgJChcIiNsaW5lY2hhcnRfaW1nXCIpLmZhZGVPdXQoXCJmYXN0XCIpLmZhZGVJbigpLmZhZGVUbyhcImZhc3RcIiwxLjApO1xuICAgIH0pO1xuICAgICQoJyNzY2F0dGVycGxvdF9pbWcnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYXRjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbmVjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgYml2YXJpYXRlUGxvdCh4X2F4aXMsIHlfYXhpcywgZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdKTtcbiAgICB9KTtcbiAgICAkKCcjaGVhdG1hcF9pbWcnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjYXR0ZXJwbG90Jykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZWNoYXJ0Jykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBoZWF0bWFwKGdldF9kYXRhWzBdLCBnZXRfZGF0YVsxXSk7XG4gICAgfSk7XG4gICAgJCgnI2xpbmVjaGFydF9pbWcnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYXRjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjYXR0ZXJwbG90Jykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBsaW5lY2hhcnQoZ2V0X2RhdGFbMF0sZ2V0X2RhdGFbMV0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGVtcHR5PVtdO1xuICAgIGNyb3NzVGFiUGxvdHMoZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdLGVtcHR5KTtcblxuICAgIHZhciBjb3JrID0gW107XG4gICAgdmFyIGNvcnAgPSBbXTtcbiAgICB2YXIgY29ycyA9IFtdO1xuICAgIHZhciB2YXIxID0gW107XG4gICAgdmFyIHZhcjIgPSBbXTtcbiAgICB2YXIgdGFibGVfb2JqID0gW107XG4gICAgdmFyIGNvbG5hbWVzID0gW107XG4gICAgdmFyIGNvbHZhciA9IFtdO1xuICAgIHZhciB0YWJsZV9kYXRhID0gW107XG4gICAgdmFyIHJvd3ZhciA9IFtdO1xuICAgIHZhciByb3duYW1lcyA9IFtdO1xuICAgIGZ1bmN0aW9uIGNyb3NzVGFiX1RhYmxlKGpzb24pIHtcbiAgICAgICAgdGFibGVfZGF0YSA9IFtdO1xuICAgICAgICB0YWJsZV9vYmogPSBbXTtcbiAgICAgICAgbGV0IHB1c2ggPSAoaSwga2V5KSA9PiBqc29uLnRhYnVsYXJbaV1ba2V5XS5tYXAodiA9PiB2KTtcbiAgICAgICAgLy8gZGF0YSBmb3Igc3RhdGlzdGljc1xuICAgICAgICBmb3IgKHZhciBpIGluIGpzb24udGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGNvbG5hbWVzID0gcHVzaChpLCAnY29sbmFtZXMnKTtcbiAgICAgICAgICAgICAgICByb3duYW1lcyA9IHB1c2goaSwgJ3Jvd25hbWVzJyk7XG4gICAgICAgICAgICAgICAgcm93dmFyID0gcHVzaChpLCAncm93dmFyJyk7XG4gICAgICAgICAgICAgICAgY29sdmFyID0gcHVzaChpLCdjb2x2YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIGpzb24udGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4ganNvbi50YWJ1bGFyW2ldLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVfZGF0YVtuXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGNvbG5hbWVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZV9kYXRhW25dLnB1c2goanNvbi50YWJ1bGFyW2ldLmRhdGFbbl1bYV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcm93bmFtZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgY29sbmFtZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICB0YWJsZV9vYmoucHVzaCh7cm93bmFtZTogcm93bmFtZXNbcF0sIGNvbG5hbWU6IGNvbG5hbWVzW2xdLCB2YWx1ZTogdGFibGVfZGF0YVtwXVtsXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQzdGFibGUxKHRhYmxlX29iaik7XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBzdGF0aXN0aWNzXG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcmspIHtcbiAgICAgICAgICAgICAgICBjb3JrLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcmtbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleTEgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5MSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkxID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiIGluIGpzb24uc3RhdGlzdGljYWxba2V5MV0uY29ycCkge1xuICAgICAgICAgICAgICAgIGNvcnAucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleTFdLmNvcnBbYl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JzKSB7XG4gICAgICAgICAgICAgICAgY29ycy5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JzW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09IG1vZGVsX25hbWUxIHx8IGtleSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiBqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMSkge1xuICAgICAgICAgICAgICAgIHZhcjEucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMVtkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5NCBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIyKSB7XG4gICAgICAgICAgICAgICAgdmFyMi5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIyW2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwcC56cGFyYW1zLnp2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24udGFidWxhcikge1xuICAgICAgICBpZiAoa2V5ID09IFwiY29sbmFtZXNcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb2xuYW1lcyBmb3VuZFwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmogPSBqc29uLnRhYnVsYXJba2V5XTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkM3RhYmxlMShkYXRhKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDEyMCwgLy8gd2lkdGggb2Ygc3ZnXG4gICAgICAgICAgICBoZWlnaHQgPSAxNjAsLy8gaGVpZ2h0IG9mIHN2Z1xuICAgICAgICAgICAgcGFkZGluZyA9IDIyOyAvLyBzcGFjZSBhcm91bmQgdGhlIGNoYXJ0LCBub3QgaW5jbHVkaW5nIGxhYmVsc1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImg1XCIpXG4gICAgICAgICAgICAudGV4dChcIkNST1NTLVRBQlMgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiM0MjQyNDJcIik7XG5cbiAgICAgICAgdmFyIHN2ID0gZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5hcHBlbmQoXCJzdmdcIikuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKS5zdHlsZShcIm92ZXJmbG93XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgdmFyIGZvID0gc3YuYXBwZW5kKCdmb3JlaWduT2JqZWN0JykuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKS5zdHlsZShcInBhZGRpbmdcIiwgMTApLmF0dHIoXCJvdmVyZmxvd1wiLCBcInZpc2libGVcIik7XG4gICAgICAgIHZhciB0YWJsZSA9IGZvLmFwcGVuZChcInhodG1sOnRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRhYmxlXCIpLnN0eWxlKFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiIGNvbGxhcHNlXCIpLFxuICAgICAgICAgICAgdGggPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcImJvcmRlclwiLCAxKS50ZXh0KFwiX1wiKS5zdHlsZShcImNvbG9yXCIsIFwiI2ZmZlwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGguYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXItYm90dG9tXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgcGxvdHMuc2VsVmFyQ29sb3IpLmFwcGVuZChcImJcIikudGV4dChjb2xuYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByb3duYW1lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgICAgICB2YXIgdHIgPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIDIwKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjQkRCREJEXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKS50ZXh0KHJvd25hbWVzW2tdKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY29sbmFtZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGRhdGEubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd25hbWVzW2tdID09PSBkYXRhW3pdLnJvd25hbWUgJiYgY29sbmFtZXNbbV0gPT09IGRhdGFbel0uY29sbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXJcIiwgMSkuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgYXBwLnZhckNvbG9yKS50ZXh0KGRhdGFbel0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3Jvc3NUYWJfVGFibGUoanNvbik7XG5cbiAgICB2YXIgcGxvdEF2YWw9dmFyc2l6ZTEscGxvdEJ2YWw9dmFyc2l6ZTI7XG4gICAgaWYgKGlzTmFOKHBsb3RBdmFsKSkgcGxvdEF2YWwgPSAxMDtcbiAgICBpZiAoaXNOYU4ocGxvdEJ2YWwpKSBwbG90QnZhbCA9IDEwO1xuICAgIGxldCBjcm9zc3RhYnMgPSAge1xuICAgICAgICB2YXIxOiB7XG4gICAgICAgICAgICBuYW1lOiBwbG90bmFtZWEsXG4gICAgICAgICAgICB2YWx1ZTogcGxvdEF2YWwsXG4gICAgICAgICAgICBidXR0b25UeXBlOiB2YXJuMVxuICAgICAgICB9LFxuICAgICAgICB2YXIyOiB7XG4gICAgICAgICAgICBuYW1lOiBwbG90bmFtZWIsXG4gICAgICAgICAgICB2YWx1ZTogcGxvdEJ2YWwsXG4gICAgICAgICAgICBidXR0b25UeXBlOiB2YXJuMlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZURhdGEoa2V5KSB7XG4gICAgICAgIGZvciAodmFyIGtleTEgaW4gYXBwLnpwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhcHAuenBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkxKSAmJiBrZXkgPT09IGtleTEgJiYgYXBwLnpwYXJhbXNba2V5MS5sZW5ndGhdID4gMCkgYXBwLnpwYXJhbXNba2V5MV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCB6YnJlYWtzID0gW107XG4gICAgbGV0IHpicmVha3NfdGFidWxhciA9IFtdO1xuICAgICQoJyNTZWxlY3Rpb25EYXRhMScpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8yXCIpLmh0bWwoXCJcIik7XG4gICAgICAgIHJlbW92ZURhdGEoJ3pjcm9zc3RhYicpO1xuICAgICAgICBhcHAuenBhcmFtcy56Y3Jvc3N0YWIucHVzaChjcm9zc3RhYnMpO1xuICAgICAgICBleHBsb3JlX2Nyb3NzdGFiKGpzb24pO1xuICAgICAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIGFwcC5lc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICB6YnJlYWtzLnB1c2goY3Jvc3N0YWJzKTtcbiAgICAgICAgemJyZWFrc190YWJ1bGFyLnB1c2goanNvbi50YWJ1bGFyKTtcbiAgICAgICAgZDMuc2VsZWN0KCcjYnJlYWtzcGFjZScpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImJ1dHRvblwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImJ0biBidG4tZGVmYXVsdCBidG4teHNcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgemJyZWFrcy5sZW5ndGgpXG4gICAgICAgICAgICAudGV4dChcImJyZWFrIFwiICsgKHpicmVha3MubGVuZ3RoICsgMSkpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5odG1sKFwiXCIpO1xuICAgICAgICAgICAgICAgIHJlbW92ZURhdGEoKTtcbiAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56Y3Jvc3N0YWIucHVzaCh6YnJlYWtzW3RoaXMuaWRdKTtcbiAgICAgICAgICAgICAgICBleHBsb3JlX2Nyb3NzdGFiKHpicmVha3NfdGFidWxhclt0aGlzLmlkXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXR2YWx1ZTEsaW5wdXR2YWx1ZTI7XG4gICAgICAgICAgICAgICAgaW5wdXR2YWx1ZTE9emJyZWFrc1t0aGlzLmlkXS52YXIxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlucHV0dmFsdWUyPXpicmVha3NbdGhpcy5pZF0udmFyMi52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0MVwiKS52YWx1ZSA9IGlucHV0dmFsdWUxO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXQyXCIpLnZhbHVlID0gaW5wdXR2YWx1ZTI7XG5cbiAgICAgICAgICAgICAgICB2YXIganNvbl9vYmo9emJyZWFrc1t0aGlzLmlkXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFybjEsdmFybjIsdmFyc2l6ZTEsdmFyc2l6ZTI7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25fb2JqLmxlbmd0aD09PTApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJicmVhayBub3QgY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcm4xPWpzb25fb2JqLnZhcjEuYnV0dG9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFybjI9anNvbl9vYmoudmFyMi5idXR0b25UeXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXJzaXplMT1qc29uX29iai52YXIxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXJzaXplMj1qc29uX29iai52YXIyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFybjE9PT1cImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWlkaXN0YW5jZShnZXRfZGF0YVswXSwgdmFyc2l6ZTEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcm4xPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWltYXNzKGdldF9kYXRhWzBdLHZhcnNpemUxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFybjI9PT1cImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWlkaXN0YW5jZShnZXRfZGF0YVsxXSwgdmFyc2l6ZTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcm4yPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWltYXNzKGdldF9kYXRhWzFdLCB2YXJzaXplMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cGxvcmVfY3Jvc3N0YWIoYnRuKSB7XG4gICAgICAgIGlmIChhcHAuZG93bmxvYWRJbmNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcHAuelBvcCgpO1xuXG4gICAgICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7XG4gICAgICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAgICAgYXBwLnpwYXJhbXMuY2FsbEhpc3RvcnkgPSBhcHAuY2FsbEhpc3Rvcnk7XG4gICAgICAgIGxldCBqc29uID0gYXdhaXQgYXBwLm1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdleHBsb3JlYXBwJywgYXBwLnpwYXJhbXMpO1xuICAgICAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdGFydCgpO1xuICAgICAgICBhcHAuZXN0aW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGQzLmpzb24oXCJzdGF0aWMvcmVzdWx0Lmpzb25cIiwgKGVyciwganNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyb3NzVGFiX1RhYmxlKGpzb24pO1xuICAgICAgICAgICAgYXBwLmVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgYXBwLmVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGRhdGEgZm9yIHRoZSBzdGF0aXN0aWNhbCBkaXZcbiAgICB2YXIgc3RyaW5nMSA9IGNvcmsudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyaW5nMyA9IHN0cmluZzEuc3Vic3RyaW5nKHN0cmluZzEuaW5kZXhPZihcIjpcIiksIHN0cmluZzEubGVuZ3RoKTtcbiAgICB2YXIgc3RyaW5nMiA9IHN0cmluZzEuc3Vic3RyaW5nKDAsIHN0cmluZzEuaW5kZXhPZihcImNcIikpO1xuICAgIHZhciBzdHJpbmc0ID0gY29ycC50b1N0cmluZygpO1xuICAgIHZhciBzdHJpbmc2ID0gc3RyaW5nNC5zdWJzdHJpbmcoc3RyaW5nNC5pbmRleE9mKFwiOlwiKSwgc3RyaW5nNC5sZW5ndGgpO1xuICAgIHZhciBzdHJpbmc1ID0gc3RyaW5nNC5zdWJzdHJpbmcoMCwgc3RyaW5nNC5pbmRleE9mKFwiY1wiKSk7XG4gICAgdmFyIHN0cmluZzcgPSBjb3JzLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN0cmluZzkgPSBzdHJpbmc3LnN1YnN0cmluZyhzdHJpbmc3LmluZGV4T2YoXCI6XCIpLCBzdHJpbmc3Lmxlbmd0aCk7XG4gICAgdmFyIHN0cmluZzggPSBzdHJpbmc3LnN1YnN0cmluZygwLCBzdHJpbmc3LmluZGV4T2YoXCJjXCIpKTtcbiAgICB2YXIgc3RhdGlzdGljYWxfZGF0YSA9IFtcbiAgICAgICAge2NvcnJlbGF0aW9uOiBzdHJpbmcyLCB2YWx1ZTogc3RyaW5nM30sXG4gICAgICAgIHtjb3JyZWxhdGlvbjogc3RyaW5nNSwgdmFsdWU6IHN0cmluZzZ9LFxuICAgICAgICB7Y29ycmVsYXRpb246IHN0cmluZzgsIHZhbHVlOiBzdHJpbmc5fVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBkM3RhYmxlKGRhdGEpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3NcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImg1XCIpXG4gICAgICAgICAgICAudGV4dChcIkNPUlJFTEFUSU9OIFNUQVRJU1RJQ1MgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiM0MjQyNDJcIik7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmFwcGVuZChcInRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRhYmxlXCIpLnN0eWxlKFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiIGNvbGxhcHNlXCIpLFxuICAgICAgICAgICAgdGggPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcImJvcmRlclwiLCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBPYmplY3Qua2V5cyhkYXRhWzBdKSkge1xuICAgICAgICAgICAgdGguYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXItYm90dG9tXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHBsb3RzLnNlbFZhckNvbG9yKS5hcHBlbmQoXCJiXCIpLnRleHQoT2JqZWN0LmtleXMoZGF0YVswXSlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJvdyBpbiBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIDQwKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgdGQgaW4gZGF0YVtyb3ddKVxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBhcHAudmFyQ29sb3IpLnRleHQoZGF0YVtyb3ddW3RkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZDN0YWJsZShzdGF0aXN0aWNhbF9kYXRhKTtcbn1cblxuXG5mdW5jdGlvbiBtb2RlbF9zZWxlY3Rpb24obW9kZWxfc2VsZWN0aW9uX25hbWUsIGNvdW50X3ZhbHVlLCBqc29uKSB7XG4gICAgaWYgKGNvdW50X3ZhbHVlICUgMiA9PSAwICYmIGNvdW50X3ZhbHVlICE9IDApIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC50ZXh0KFwiXFx1MDBBMCBcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCAgIFxcdTAwQTAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJ8XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXFx1MDBBMCBcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmbG9hdFwiLCBcImxlZnRcIik7XG5cbiAgICB9XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAudGV4dChcIiBcXHUwMEEwXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG5cbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXhcIiwgXCJzY3JvbGxcIilcbiAgICAgICAgLmFwcGVuZChcImJ1dHRvblwiKS8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgIC8vICAgICAgLmFwcGVuZChcInhodG1sOmJ1dHRvblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLW91dGxpbmUtc3VjY2Vzc1wiKVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCI0cHhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbF9zZWxlY3Rpb25fbmFtZSlcbiAgICAgICAgLnRleHQobW9kZWxfc2VsZWN0aW9uX25hbWUpXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yMSA9IFwiI0ZGRDU0RlwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09IGNvdW50MSA/IHBsb3RzLnNlbFZhckNvbG9yIDogY29sb3IxO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGIgPSBhcHAuaGV4VG9SZ2JhKHBsb3RzLnNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PT0gYi5zdWJzdHIoMCwgMTcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL2VzY2FwZXMgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZSBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdml6KHRoaXMuaWQsIGpzb24sIG1vZGVsX3NlbGVjdGlvbl9uYW1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgXCIjRkZENTRGXCIpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgcGxvdHMuc2VsVmFyQ29sb3IpO1xuICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZiAoYXBwLmxvZ0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXBwLmJ5SWQoJ2xvZ2RpdicpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgIC5kYXRhKGFwcC5sb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHAuYnlJZCgnbG9nZGl2Jykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG59XG5cbmZ1bmN0aW9uIHVuaXZhcmlhdGVQYXJ0KCkge1xuICAgIGQzLnNlbGVjdChcIiNkZWNpc2lvblRyZWVcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIGQzLnNlbGVjdChcIiNsZWZ0X3RodW1ibmFpbFwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0X2xlZnRcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdF9sZWZ0MVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0X3JpZ2h0XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdfQ29udGFpbmVyXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3X3RhYnVsYXJcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RBXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNwbG90QlwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjU2VsZWN0aW9uRGF0YVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdfc3RhdGlzdGljc1wiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbn1cblxubGV0IGNvdW50ID0gMDtcbmxldCBjb3VudDEgPSAwO1xuXG4vKipcbiAgIGNhbGxlZCBieSBjbGlja2luZyAnRXhwbG9yZScgaW4gZXhwbG9yZSBtb2RlXG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGxvcmUoKSB7XG4gICAgaWYgKGFwcC5kb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBwLnpQb3AoKTtcbiAgICBjb25zb2xlLmxvZygnenBvcDonLCBhcHAuenBhcmFtcyk7XG5cbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgYXBwLnpwYXJhbXMuY2FsbEhpc3RvcnkgPSBhcHAuY2FsbEhpc3Rvcnk7XG4gICAgYXBwLmVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIGxldCBqc29uID0gYXdhaXQgYXBwLm1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdleHBsb3JlYXBwJywgYXBwLnpwYXJhbXMpO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwcC5hbGxSZXN1bHRzLnB1c2goanNvbik7XG5cbiAgICBkMy5zZWxlY3QoJyNyaWdodHBhbmVsJylcbiAgICAgICAgLnN0eWxlKCd3aWR0aCcsICc3NSUnKTtcblxuICAgIGxldCBwYXJlbnQgPSBhcHAuYnlJZCgncmlnaHRDb250ZW50QXJlYScpO1xuICAgIGFwcC5lc3RpbWF0ZWQgfHwgcGFyZW50LnJlbW92ZUNoaWxkKGFwcC5ieUlkKCdyZXN1bHRzSG9sZGVyJykpO1xuICAgIGFwcC5lc3RpbWF0ZWQgPSB0cnVlO1xuXG4gICAgZDMuc2VsZWN0KFwiI2RlY2lzaW9uVHJlZVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpLmh0bWwoJycpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmh0bWwoJycpO1xuICAgIFtcIiNsZWZ0X3RodW1ibmFpbFwiLFxuICAgICBcIiNyZXN1bHRfbGVmdFwiLFxuICAgICBcIiNyZXN1bHRfbGVmdDFcIixcbiAgICAgXCIjcmVzdWx0X3JpZ2h0XCIsXG4gICAgIFwiI21vZGVsVmlld19Db250YWluZXJcIixcbiAgICAgXCIjbW9kZWxWaWV3XCIsXG4gICAgIFwiI3Jlc3VsdHNWaWV3X3RhYnVsYXJcIixcbiAgICAgXCIjcGxvdEFcIixcbiAgICAgXCIjcGxvdEJcIixcbiAgICAgXCIjU2VsZWN0aW9uRGF0YVwiLFxuICAgICBcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCJcbiAgICBdLmZvckVhY2goaWQgPT4gZDMuc2VsZWN0KGlkKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGFwcC5oZXhUb1JnYmEoYXBwLnZhckNvbG9yKSlcbiAgICAgICAgLnN0eWxlKFwib3ZlcmZsb3cteVwiLCBcImhpZGRlblwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy14XCIsIFwic2Nyb2xsXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzcGFuXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjNzU3NTc1XCIpXG4gICAgICAgIC50ZXh0KFwiTU9ERUwgU0VMRUNUSU9OIDogIFwiKTtcblxuICAgIC8vIHByb2dyYW1tYXRpYyBjbGljayBvbiBSZXN1bHRzIGJ1dHRvblxuICAgICQoXCIjYnRuQml2YXJpYXRlXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICBsZXQgbW9kZWxfbmFtZTtcbiAgICBmb3IgKGxldCBpbWcgaW4ganNvbi5pbWFnZXMpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBtb2RlbF9uYW1lID0gaW1nO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsX3NlbGVjdGlvbihpbWcsIGNvdW50LCBqc29uKTsgLy8gZm9yIGVudGVyaW5nIGFsbCB0aGUgdmFyaWFibGVzXG4gICAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGNvdW50MSA9IGNvdW50IC0gMTtcbiAgICBhcHAubW9kZWxDb3VudCsrO1xuXG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgYXBwLmxvZ0FycmF5LnB1c2goXCJleHBsb3JlOiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgICBzaG93TG9nKCk7XG4gICAgdml6KG1vZGVsX25hbWUsIGpzb24sIG1vZGVsX25hbWUpO1xufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXNzZXRzL2FwcC9leHBsb3JlLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQXVTQTtBQXFrQkE7QUFpakJBO0FBQ0E7QUE5NUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBVUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFRQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFuQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQW9DQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVFBO0FBS0E7QUFJQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFLQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU5BO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFXQTtBQVhBO0FBaUJBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** ./assets/app/views/Panel.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.btnWidths = btnWidths;\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ../app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel) {\n    return cls + (panel.closed ? '.closepanel' : panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '');\n};\n\nfunction btnWidths(btns) {\n    lis.forEach(function (li) {\n        li.addEventListener('mouseover', function () {\n            lis.forEach(function (li) {\n                return li.style.width = shrinkwidth;\n            });\n            this.style.width = expandwidth;\n        });\n        li.addEventListener('mouseout', function () {\n            return lis.forEach(function (li) {\n                return li.style.width = width;\n            });\n        });\n    });\n}\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title,\n                buttons = _vnode$attrs.buttons;\n\n            var btns = buttons;\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            var width = 100 / btns.length;\n            var expandwidth = 35;\n            var shrinkwidth = 65 / (btns.length - 1);\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), (0, _mithril2.default)('ul' + (side === 'right' ? '#rightpanelbuttons' : '') + '.accordion', btns.map(function (b) {\n                b.attrs.style = b.attrs.style + '; width: 100%';\n                var id = b.attrs.id;\n                var w = _this.active_btn === id ? shrinkwidth : _this.active_btn === null ? width : expandwidth;\n                return (0, _mithril2.default)('li', { style: { width: width + '%', 'max-width': '150px' },\n                    onmouseover: function onmouseover(_) {\n                        return _this.active_btn = id;\n                    },\n                    onmouseout: function onmouseout(_) {\n                        return _this.active_btn = null;\n                    } }, b);\n            })), (0, _mithril2.default)(getClasses('.row-fluid', this), (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 213px); overflow: auto]', vnode.children))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzMyMjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IGdldENsYXNzZXMgPSBmdW5jdGlvbihjbHMsIHBhbmVsKSB7XG4gICAgcmV0dXJuIGNscyArIChwYW5lbC5jbG9zZWQgPyAnLmNsb3NlcGFuZWwnIDpcbiAgICAgICAgKHBhbmVsLnNpZGUgPT09ICdsZWZ0JyAmJiBhcHAubGVmdHRhYiA9PT0gJ3RhYjInKSA/ICcuZXhwYW5kcGFuZWwnIDpcbiAgICAgICAgJycpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ0bldpZHRocyhidG5zKSB7XG4gICAgbGlzLmZvckVhY2gobGkgPT4ge1xuICAgICAgICBsaS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxpcy5mb3JFYWNoKGxpID0+IGxpLnN0eWxlLndpZHRoID0gc2hyaW5rd2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IGV4cGFuZHdpZHRoO1xuICAgICAgICB9KTtcbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiBsaXMuZm9yRWFjaChsaSA9PiBsaS5zdHlsZS53aWR0aCA9IHdpZHRoKSk7XG4gICAgfSk7XG59XG5cbmNsYXNzIFBhbmVsIHtcbiAgICBvbmluaXQodm5vZGUpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7c2lkZSwgdGl0bGUsIGJ1dHRvbnN9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBidG5zID0gYnV0dG9ucztcbiAgICAgICAgbGV0IGRvdCA9IFttLnRydXN0KCcmIzk2Nzk7JyksIG0oJ2JyJyldO1xuICAgICAgICBsZXQgd2lkdGggPSAxMDAgLyBidG5zLmxlbmd0aDtcbiAgICAgICAgbGV0IGV4cGFuZHdpZHRoID0gMzU7XG4gICAgICAgIGxldCBzaHJpbmt3aWR0aCA9IDY1IC8gKGJ0bnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgZ2V0Q2xhc3NlcyhgIyR7c2lkZX1wYW5lbC5zaWRlcGFuZWwuY29udGFpbmVyLmNsZWFyZml4YCwgdGhpcyksXG4gICAgICAgICAgICBtKGAjdG9nZ2xlJHtzaWRlID09PSAnbGVmdCcgPyAnTCcgOiAnUid9cGFuZWxpY29uLnBhbmVsYmFyW3N0eWxlPWhlaWdodDogMTAwJV1gLFxuICAgICAgICAgICAgICBtKCdzcGFuJywge29uY2xpY2s6IF8gPT4gdGhpcy5jbG9zZWQgPSAhdGhpcy5jbG9zZWR9LCBkb3QsIGRvdCwgZG90LCBkb3QpKSxcbiAgICAgICAgICAgIG0oYCMke3NpZGV9cGFuZWx0aXRsZS5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyYCxcbiAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsIHRpdGxlKSksXG4gICAgICAgICAgICBtKGB1bCR7c2lkZSA9PT0gJ3JpZ2h0JyA/ICcjcmlnaHRwYW5lbGJ1dHRvbnMnIDogJyd9LmFjY29yZGlvbmAsXG4gICAgICAgICAgICAgIGJ0bnMubWFwKGIgPT4ge1xuICAgICAgICAgICAgICAgICAgYi5hdHRycy5zdHlsZSA9IGIuYXR0cnMuc3R5bGUgKyAnOyB3aWR0aDogMTAwJSc7XG4gICAgICAgICAgICAgICAgICBsZXQgaWQgPSBiLmF0dHJzLmlkO1xuICAgICAgICAgICAgICAgICAgbGV0IHcgPSB0aGlzLmFjdGl2ZV9idG4gPT09IGlkID8gc2hyaW5rd2lkdGggOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlX2J0biA9PT0gbnVsbCA/IHdpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICBleHBhbmR3aWR0aDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgICAge3N0eWxlOiB7d2lkdGg6IHdpZHRoICsgJyUnLCAnbWF4LXdpZHRoJzogJzE1MHB4J30sXG4gICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuYWN0aXZlX2J0biA9IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBfID0+IHRoaXMuYWN0aXZlX2J0biA9IG51bGx9LFxuICAgICAgICAgICAgICAgICAgICAgIGIpO1xuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBtKGdldENsYXNzZXMoJy5yb3ctZmx1aWQnLCB0aGlzKSxcbiAgICAgICAgICAgICAgbShgIyR7c2lkZX1wYW5lbGNvbnRlbnRgLFxuICAgICAgICAgICAgICAgIG0oYCMke3NpZGV9Q29udGVudEFyZWFbc3R5bGU9aGVpZ2h0OiBjYWxjKDEwMHZoIC0gMjEzcHgpOyBvdmVyZmxvdzogYXV0b11gLCB2bm9kZS5jaGlsZHJlbikpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBWEE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUlBOzs7Ozs7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./assets/app/views/PanelButton.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.when = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ../app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar when = exports.when = function when(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || when(left ? 'left' : 'right', id2, 'active', 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.tabLeft(id2) : app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzPzBhZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IHdoZW4gPSBmdW5jdGlvbihzaWRlLCB2YWwsIHk9J2Jsb2NrJywgbj0nbm9uZScpIHtcbiAgICByZXR1cm4gYXBwW3NpZGUgKyAndGFiJ10gPT09IHZhbCA/IHkgOiBuO1xufTtcblxuY2xhc3MgUGFuZWxCdXR0b24ge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtpZCwgaWQyLCBjbGFzc2VzLCBvbmNsaWNrLCBzdHlsZSwgdGl0bGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBsZWZ0ID0gaWQyID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBpZDIgPSBpZDIgfHwgaWQ7XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgYGJ1dHRvbiMke2lkfS5idG4uJHtjbGFzc2VzIHx8IHdoZW4obGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsIGlkMiwgJ2FjdGl2ZScsICdidG4tZGVmYXVsdCcpfVt0eXBlPWJ1dHRvbl1gLCB7XG4gICAgICAgICAgICBvbmNsaWNrOiBvbmNsaWNrIHx8IChfID0+IGxlZnQgPyBhcHAudGFiTGVmdChpZDIpIDogYXBwLnRhYlJpZ2h0KGlkMikpLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlfSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFzc2V0cy9hcHAvdmlld3MvUGFuZWxCdXR0b24uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/* no static exports found */
/* all exports used */
/*!***************************************!*\
  !*** ./assets/app/views/PanelList.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ../app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(/*! ../plots */ 2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Search = __webpack_require__(/*! ./Search */ 3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelList = function () {\n    function PanelList() {\n        _classCallCheck(this, PanelList);\n    }\n\n    _createClass(PanelList, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                items = _vnode$attrs.items,\n                content = _vnode$attrs.content,\n                title = _vnode$attrs.title,\n                probDesc = _vnode$attrs.probDesc;\n\n            return (0, _mithril2.default)('#varList[style=display: block]', items.map(function (v, i) {\n                return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n                    class: probDesc ? app.d3mProblemDescription[probDesc] === v ? 'item-select' : app.locktoggle ? 'item-default item-lineout' : 'item-default' : '',\n                    style: {\n                        'background-color': probDesc ? '' : app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n                            return n.name;\n                        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n                        'border-color': '#000000',\n                        'border-style': !probDesc && _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n                    },\n                    onclick: probDesc || app.clickVar,\n                    onmouseover: function onmouseover() {\n                        $(this).popover('toggle');\n                        if (probDesc) return;\n                        $(\"body div.popover\").addClass(\"variables\");\n                        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n                    },\n                    onmouseout: \"$(this).popover('toggle');\",\n                    'data-container': 'body',\n                    'data-content': content ? content(v) : app.popoverContent(app.findNodeIndex(v, true)),\n                    'data-html': 'true',\n                    'data-original-title': title,\n                    'data-placement': probDesc ? 'top' : 'right',\n                    'data-toggle': 'popover',\n                    'data-trigger': 'hover' }, v);\n            }));\n        }\n    }]);\n\n    return PanelList;\n}();\n\nexports.default = PanelList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsTGlzdC5qcz84NGZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCAqIGFzIHBsb3RzIGZyb20gJy4uL3Bsb3RzJztcblxuaW1wb3J0IHtzZWFyY2hJbmRleH0gZnJvbSAnLi9TZWFyY2gnO1xuXG5jbGFzcyBQYW5lbExpc3Qge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtpdGVtcywgY29udGVudCwgdGl0bGUsIHByb2JEZXNjfSA9IHZub2RlLmF0dHJzO1xuICAgICAgICByZXR1cm4gbShcbiAgICAgICAgICAgICcjdmFyTGlzdFtzdHlsZT1kaXNwbGF5OiBibG9ja10nLFxuICAgICAgICAgICAgaXRlbXMubWFwKCh2LCBpKSA9PlxuICAgICAgICAgICAgICAgICAgICAgIG0oYHAjJHt2LnJlcGxhY2UoL1xcVy9nLCAnXycpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHByb2JEZXNjID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcHAuZDNtUHJvYmxlbURlc2NyaXB0aW9uW3Byb2JEZXNjXSA9PT0gdiA/ICdpdGVtLXNlbGVjdCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5sb2NrdG9nZ2xlID8gJ2l0ZW0tZGVmYXVsdCBpdGVtLWxpbmVvdXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXRlbS1kZWZhdWx0JykgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogcHJvYkRlc2MgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnpwYXJhbXMuemR2LmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAuZHZDb2xvcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC56cGFyYW1zLnpub20uaW5jbHVkZXModikgPyBhcHAuaGV4VG9SZ2JhKGFwcC5ub21Db2xvcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5ub2Rlcy5tYXAobiA9PiBuLm5hbWUpLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShwbG90cy5zZWxWYXJDb2xvcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC52YXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItY29sb3InOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLXN0eWxlJzogIXByb2JEZXNjICYmIHNlYXJjaEluZGV4ICYmIGkgPCBzZWFyY2hJbmRleCA/ICdzb2xpZCcgOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogcHJvYkRlc2MgfHwgYXBwLmNsaWNrVmFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2JEZXNjKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyIGRpdi5wb3BvdmVyLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJmb3JtLWhvcml6b250YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29udGFpbmVyJzogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jb250ZW50JzogY29udGVudCA/IGNvbnRlbnQodikgOiBhcHAucG9wb3ZlckNvbnRlbnQoYXBwLmZpbmROb2RlSW5kZXgodiwgdHJ1ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1odG1sJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZSc6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1wbGFjZW1lbnQnOiBwcm9iRGVzYyA/ICd0b3AnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdG9nZ2xlJzogJ3BvcG92ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10cmlnZ2VyJzogJ2hvdmVyJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICB2KSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFuZWxMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFzc2V0cy9hcHAvdmlld3MvUGFuZWxMaXN0LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7Ozs7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0JBO0FBaUNBOzs7Ozs7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/* no static exports found */
/* all exports used */
/*!**************************************!*\
  !*** ./assets/app/views/Subpanel.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ../app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzPzIxNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5jbGFzcyBTdWJwYW5lbCB7XG4gICAgb25pbml0KHZub2RlKSB7XG4gICAgICAgIHRoaXMuaGlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHRpdGxlID0gdm5vZGUuYXR0cnMudGl0bGU7XG4gICAgICAgIGxldCBsZWdlbmQgPSB0aXRsZSA9PT0gJ0xlZ2VuZCc7XG4gICAgICAgIGxldCB0YXJnZXQgPSAnY29sbGFwc2UnICsgdGl0bGU7XG4gICAgICAgIGxldCB6ID0gYXBwLnpwYXJhbXM7XG4gICAgICAgIHJldHVybiBtKGAjJHtsZWdlbmQgPyBcImxlZ2VuZC5sZWdlbmRhcnlcIiA6IFwibG9nZGl2LmxvZ2JveFwifS5wYW5lbC5wYW5lbC1kZWZhdWx0YCwge1xuICAgICAgICAgICAgc3R5bGU6IHtkaXNwbGF5OiBsZWdlbmQgJiYgei56dGltZS5sZW5ndGggKyB6Lnpjcm9zcy5sZW5ndGggKyB6Lnpkdi5sZW5ndGggKyB6Lnpub20ubGVuZ3RoIHx8ICFsZWdlbmQgJiYgYXBwLmxvZ0FycmF5Lmxlbmd0aCA+IDAgPyAnYmxvY2snIDogJ25vbmUnfX0sXG4gICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtaGVhZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICBtKGBzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbGFyZ2UuZ2x5cGhpY29uLWNoZXZyb24tJHt0aGlzLmhpZGUgPyAndXAnOiAnZG93bid9LnB1bGwtcmlnaHRbZGF0YS10YXJnZXQ9IyR7dGFyZ2V0fV1bZGF0YS10b2dnbGU9Y29sbGFwc2VdW2hyZWY9IyR7dGFyZ2V0fV1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjdXJzb3I6IHBvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gdGhpcy5oaWRlID0gIXRoaXMuaGlkZX0pKSksXG4gICAgICAgICAgICAgICAgIG0oYCMke3RhcmdldH0ucGFuZWwtY29sbGFwc2UuY29sbGFwc2UuaW5gLFxuICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCAhbGVnZW5kID8gYXBwLmxvZ0FycmF5Lm1hcCh4ID0+IG0oJ3AnLCB4KSkgOiB2bm9kZS5hdHRycy5idXR0b25zLm1hcCh4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0oYCMke3hbMF19LmNsZWFyZml4LiR7elt4WzFdXS5sZW5ndGggPT09IDAgPyBcImhpZGVcIiA6IFwic2hvd1wifWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdENvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1tzdHlsZT13aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4XVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0xMF1bY3k9MTBdW2ZpbGw9d2hpdGVdW3I9OV1bc3Ryb2tlPWJsYWNrXVtzdHJva2Utd2lkdGg9Ml1cIikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIiwgeFsyXSkpO30pKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3VicGFuZWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXNzZXRzL2FwcC92aWV3cy9TdWJwYW5lbC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7OztBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/* no static exports found */
/* all exports used */
/*!****************************!*\
  !*** ./assets/css/app.css ***!
  \****************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2Nzcy9hcHAuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/* no static exports found */
/* all exports used */
/*!********************************************************!*\
  !*** ./assets/pkgs/Ladda/dist/ladda-themeless.min.css ***!
  \********************************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9wa2dzL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/* no static exports found */
/* all exports used */
/*!***********************************************************!*\
  !*** ./assets/pkgs/bootstrap/css/bootstrap-theme.min.css ***!
  \***********************************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9wa2dzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/* no static exports found */
/* all exports used */
/*!********************************************!*\
  !*** ./~/hopscotch/dist/css/hopscotch.css ***!
  \********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2Nzcy9ob3BzY290Y2guY3NzPzYyZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/* no static exports found */
/* all exports used */
/*!*****************************!*\
  !*** ./assets/app/index.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../css/app.css */ 10);\n\n__webpack_require__(/*! ../pkgs/bootstrap/css/bootstrap-theme.min.css */ 12);\n\n__webpack_require__(/*! ../pkgs/Ladda/dist/ladda-themeless.min.css */ 11);\n\n__webpack_require__(/*! ../../~/hopscotch/dist/css/hopscotch.css */ 13);\n\nvar _mithril = __webpack_require__(/*! mithril */ 0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(/*! ./app */ 1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _explore = __webpack_require__(/*! ./explore */ 5);\n\nvar exp = _interopRequireWildcard(_explore);\n\nvar _plots = __webpack_require__(/*! ./plots */ 2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(/*! ./views/Panel */ 6);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(/*! ./views/PanelButton */ 7);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _PanelList = __webpack_require__(/*! ./views/PanelList */ 8);\n\nvar _PanelList2 = _interopRequireDefault(_PanelList);\n\nvar _Search = __webpack_require__(/*! ./views/Search */ 3);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(/*! ./views/Subpanel */ 9);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction setBackgroundColor(color) {\n    return function () {\n        this.style['background-color'] = color;\n    };\n}\n\nfunction leftpanel(mode) {\n    if (mode == \"results\") {\n        return (0, _mithril2.default)(_Panel2.default, { side: 'left',\n            title: 'Pipelines',\n            buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnVariables',\n                id2: 'tab1',\n                title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2' }, 'Subset'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSelect',\n                classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n                onclick: function onclick(_) {\n                    return app.subsetSelect('btnSelect');\n                },\n                style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n                title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Select'))] }, (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.when)('left', 'tab1') + '; padding: 0 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)(_PanelList2.default, { items: app.valueKey, title: 'Summary Statistics' })), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.when)('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.when)('left', 'tab3') + ']', { title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n            return (0, _mithril2.default)('tr', tr.map(function (td) {\n                return (0, _mithril2.default)('td', { onmouseover: setBackgroundColor('aliceblue'), onmouseout: setBackgroundColor('f9f9f9') }, td);\n            }));\n        })))));\n    } else {\n        return (0, _mithril2.default)(_Panel2.default, { side: 'left',\n            title: 'Data Selection',\n            buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnVariables',\n                id2: 'tab1',\n                title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2' }, 'Subset'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSelect',\n                classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n                onclick: function onclick(_) {\n                    return app.subsetSelect('btnSelect');\n                },\n                style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n                title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Select'))] }, (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.when)('left', 'tab1') + '; padding: 0 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)(_PanelList2.default, { items: app.valueKey, title: 'Summary Statistics' })), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.when)('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.when)('left', 'tab3') + ']', { title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n            return (0, _mithril2.default)('tr', tr.map(function (td) {\n                return (0, _mithril2.default)('td', { onmouseover: setBackgroundColor('aliceblue'), onmouseout: setBackgroundColor('f9f9f9') }, td);\n            }));\n        })))));\n    }\n}\n\nvar righttab = function righttab(id, btnId, task, title, probDesc) {\n    return (0, _mithril2.default)('#' + id + '[style=display: ' + (0, _PanelButton.when)('right', btnId) + '; padding: 6px 12px; text-align: center]', (0, _mithril2.default)(_PanelList2.default, { items: Object.keys(task || {}),\n        title: title + ' Description',\n        content: function content(v) {\n            return task[v][1];\n        },\n        probDesc: probDesc }));\n};\n\nfunction rightpanel(mode) {\n    var thumbnail = function thumbnail(idx, id, title) {\n        return (0, _mithril2.default)(\"th\", (0, _mithril2.default)(\"figure\", { style: { float: \"left\" } }, (0, _mithril2.default)('img#' + id + '_img[alt=' + id + '][src=/static/images/thumb' + idx + '.png]', { style: { width: \"75%\", height: \"75%\", border: \"1px solid #ddd\", \"border-radius\": \"3px\", padding: \"5px\", margin: \"3%\", cursor: \"pointer\" } }), (0, _mithril2.default)(\"figcaption\", { style: { \"text-align\": \"center\" } }, title)));\n    };\n    return mode ? (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Result Exploration',\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnUnivariate' }, 'Univariate'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnBivariate' }, 'Bivariate')] }, (0, _mithril2.default)('#modelView_Container', { style: 'width: 100%; height: auto; background-color: white; float: left; overflow-x: auto; overflow-y: hidden; white-space: nowrap;' }, (0, _mithril2.default)('#modelView', { style: 'width: 100%; height: 100%; background-color: white; float: left; overflow: auto; margin-top: 2px;' })), (0, _mithril2.default)('#decisionTree[style=width: 100%; height: 100%; background: #ff5932]'), (0, _mithril2.default)('#result_left', { style: { \"width\": \"50%\", \"height\": \"90%\", \"float\": \"left\", \"background-color\": \"white\", \"border-right\": \"ridge\", \"border-bottom\": \"ridge\", \"overflow\": \"auto\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)('#left_thumbnail', { style: { \"width\": \"100%\", \"height\": \"20%\", \"background-color\": \"white\", \"margin-top\": \"3%\", \"margin-right\": \"3%\", \"border-bottom\": \"ridge\", \"overflow\": \"auto\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)(\"table\", (0, _mithril2.default)(\"tbody\", (0, _mithril2.default)(\"tr\", thumbnail(1, 'scatterplot', \"Scatter Plot\"), thumbnail(2, 'heatmap', \"Heatpmap\"), thumbnail(3, 'linechart', \"Linechart\"))))), (0, _mithril2.default)('#result_left1', { style: { width: \"100%\", height: \"60%\", \"text-align\": \"center\", \"margin-top\": \"3%\", \"background-color\": \"white\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)(\".container3[id=scatterplot]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"background-color\": \"white\", \"float\": \"left\", \"overflow\": \"hidden\", \"margin\": \"5% \" } }), (0, _mithril2.default)(\".container4[id=heatchart]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"float\": \"left\", \"overflow\": \"hidden\", \"background-color\": \"#FFEBEE\", \"margin\": \"5%  \" } }), (0, _mithril2.default)(\".container4[id=linechart]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"background-color\": \"white\", \"float\": \"left\", \"overflow\": \"hidden\", \"margin\": \"5% \" } })), (0, _mithril2.default)(\"div\", { style: { \"border-bottom\": \"ridge\", \"display\": \"inline-block\", \"width\": \"100%\", \"margin-bottom\": \"2%\", \"text-align\": \"center\" } }, (0, _mithril2.default)(\"h5#NAcount\", { style: { \" margin-bottom\": \"0\" } })), (0, _mithril2.default)(\".container2[id='resultsView_statistics']\", { style: { \"width\": \"100%\", \"height\": \"15%\", \"background-color\": \"white\", \"float\": \"left\", \"white-space\": \"nowrap\", \"margin-bottom\": \"3%\", \"border-bottom\": \"ridge\" } })), (0, _mithril2.default)('#result_right', { style: { width: \"50%\", height: \"90%\", float: \"right\", \"background-color\": \"white\", \"border-right\": \"groove\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)('#resultsView_tabular.container1', { style: { width: \"100%\", height: \"100%\", \"background-color\": \"white\", float: \"left\", overflow: \"auto\", \"white-space\": \"nowrap\", \"border-right\": \"groove\", \"border-bottom\": \"groove\" } }, (0, _mithril2.default)('#SelectionData', { style: { width: \"100%\", height: \"55%\", overflow: \"auto\", \"margin-top\": \"10px\", \"border-bottom-style\": \"inset\" } }, (0, _mithril2.default)(\"fieldset\", { style: { margin: \"3%\" } }, (0, _mithril2.default)(\"h4\", { style: { \"text-align\": \"center\" } }, \"Data Distribution Selection\"), (0, _mithril2.default)(\"p\", { style: { \"font-family\": \"Arial, Helvetica, sans-serif\", \"font-size\": \"12px\" } }, \"Enter number for each variable to specify the break points\"), (0, _mithril2.default)('p#boldstuff', { style: { color: \"#2a6496\", \"font-family\": \"Arial, Helvetica, sans-serif\", \"font-size\": \"12px\" } }, \"Select between Equidistant and Equimass\")), (0, _mithril2.default)('#forPlotA', { style: { display: 'block', \"margin\": \"2%\" } }, (0, _mithril2.default)(\"input#input1[name='fname'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotA.tooltiptext[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\")), (0, _mithril2.default)('#forPlotB', { style: { display: \"block\", margin: \"2%\" } }, (0, _mithril2.default)(\"input#input2[name='fname1'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotB.tooltiptext1[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\")), (0, _mithril2.default)(\"#plotA_status[style=margin-top: 1%; margin-left: 2%]\"), (0, _mithril2.default)(\"#plotB_status[style=margin-top: 1%; margin-left: 2%]\"), (0, _mithril2.default)('h5[style=color: #ac2925; margin-top: 1%; margin-left: 2%]', 'Selection History'), (0, _mithril2.default)('#breakspace[style=display: inline-block; overflow: auto; width: 100%]')), (0, _mithril2.default)('#tabular_1', { style: { width: \"100%\", height: \"30%\", \"border-bottom-style\": \"inset\", \"margin-top\": \"3%\" } }, (0, _mithril2.default)(\"button.btn.btn-default.btn-sm[id='SelectionData1'][type='button']\", { style: { display: \"block\", margin: \"0 auto\", position: \"relative\" } }, \"Create\"), (0, _mithril2.default)('#plotA', { style: { width: exp.get_width('plotA') + '%', height: \"100%\", float: \"left\", overflow: \"hidden\" } }, \"plotA\"), (0, _mithril2.default)('#plotB', { style: { width: exp.get_width('plotB') + '%', height: \"100%\", float: \"right\", overflow: \"hidden\" } }, \"plotB\")), (0, _mithril2.default)('#tabular_2', { style: { width: \"100%\", height: \"50%\", \"border-bottom-style\": \"inset\", overflow: \"hidden\" } }))), (0, _mithril2.default)(\"p#resultsHolder\", { style: { padding: \".5em 1em\" } }), (0, _mithril2.default)('#setx[style=display: none; margin-top: .5em]')) :\n    // mode == null (model mode)\n    (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Model Selection',\n        buttons: (!app.IS_D3M_DOMAIN ? [] : [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnModels' }, 'Models'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx' }, 'Set Covar.'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults' }, 'Results')]).concat([(0, _mithril2.default)(_PanelButton2.default, { id: 'btnType' }, 'Task Type'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubtype' }, 'Subtype'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnMetrics' }, 'Metrics')]) }, (0, _mithril2.default)('#results[style=display: ' + (0, _PanelButton.when)('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")), (0, _mithril2.default)('#setx[style=display: ' + (0, _PanelButton.when)('right', 'btnSetx') + ']', (0, _mithril2.default)('#setxLeftAll[style=display:block; float: left; width: 30%; height:100%; background-color: white]', (0, _mithril2.default)('#setxLeft[style=display:block; float: left; width: 100%; height:95%; overflow: auto; background-color: white]')), (0, _mithril2.default)('#setxRightAll[style=display:block; float: left; width: 70%; height:100%; background-color: white]', (0, _mithril2.default)('#setxRightTop[style=display:block; float: left; width: 100%; height:65%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxMiddle[style=display:block; float: left; width: 70%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 30%; height:100%; background-color: white]'))), (0, _mithril2.default)('#setxRightBottom[style=display:block; float: left; width: 100%; height:35%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxRightBottomLeft[style=display:block; float: left; width: 75%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRightBottomMiddle[style=display:block; float: left; width: 15%; height:100%; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, { id: 'btnExecutePipe',\n        classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n        onclick: function onclick(_) {\n            return app.executepipeline('btnExecutePipe');\n        },\n        style: 'display:inline; float: left; margin-right: 10px',\n        title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute'))), (0, _mithril2.default)('#setxRightBottomRight[style=display:block; float: left; width: 10%; height:100%; background-color: white]'))), righttab('models', 'btnModels'), righttab('types', 'btnType', app.d3mTaskType, 'Task', 'taskType'), righttab('subtypes', 'btnSubtype', app.d3mTaskSubtype, 'Task Subtype', 'taskSubtype'), righttab('metrics', 'btnMetrics', app.d3mMetrics, 'Metric', 'metric'));\n}\n\nvar ticker = function ticker(mode) {\n    var link = function link(name) {\n        return (0, _mithril2.default)('a' + (name === mode ? '.active' : '') + '[href=/' + name + '][style=margin-right: 0.5em]', { oncreate: _mithril2.default.route.link }, name[0].toUpperCase() + name.slice(1));\n    };\n    return (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', link('model'), link('explore'), link('results'), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank][style=margin-right: 0.5em]\", \"Replication\"),\n    // dev links...\n    (0, _mithril2.default)(\"a[href='/dev-raven-links'][target=_blank][style=margin-right: 0.5em]\", \"raven-links\"), (0, _mithril2.default)(\"a[style=margin-right: 0.5em]\", { onclick: app.record_user_metadata }, \"record-metadata\"));\n};\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oninit',\n        value: function oninit() {\n            this.about = false;\n            this.usertasks = false;\n            this.cite = false;\n            this.citeHidden = false;\n            this.last_mode = null;\n        }\n    }, {\n        key: 'oncreate',\n        value: function oncreate() {\n            var extract = function extract(name, key, offset, replace) {\n                key = key + '=';\n                var loc = window.location.toString();\n                var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n                var idx = val.indexOf('&');\n                val = idx > 0 ? val.substring(0, idx) : val;\n                val = val.replace('#!/model', '');\n                console.log(name, ': ', val);\n                if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n                return val;\n            };\n            app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var mode = vnode.attrs.mode;\n\n            var explore = mode === 'explore';\n            app.is_results_mode = mode === 'results';\n            var _navBtn = function _navBtn(id, left, right, onclick, args, min) {\n                return (0, _mithril2.default)('button#' + id + '.btn.navbar-right', { onclick: onclick,\n                    style: { 'margin-left': left + 'em',\n                        'margin-right': right + 'em',\n                        'min-width': min } }, args);\n            };\n            var navBtn = function navBtn(id, left, right, onclick, args, min) {\n                return _navBtn(id + '.ladda-button[data-spinner-color=#000000][data-style=zoom-in]', left, right, onclick, args, min);\n            };\n            var navBtn1 = function navBtn1(id, onclick, args, title) {\n                return _navBtn(id + '.btn-default[title=' + title + ']', 2, 0, onclick, args);\n            };\n            var glyph = function glyph(icon, unstyled) {\n                return (0, _mithril2.default)('span.glyphicon.glyphicon-' + icon + (unstyled ? '' : '[style=color: #818181; font-size: 1em; pointer-events: none]'));\n            };\n            var transformation = function transformation(id, list) {\n                return (0, _mithril2.default)('ul#' + id, {\n                    style: { display: 'none', 'background-color': app.varColor },\n                    onclick: function onclick(evt) {\n                        // if interact is selected, show variable list again\n                        if ($(this).text() === 'interact(d,e)') {\n                            $('#tInput').val(tvar.concat('*'));\n                            selInteract = true;\n                            $(this).parent().fadeOut(100);\n                            $('#transSel').fadeIn(100);\n                            evt.stopPropagation();\n                            return;\n                        }\n\n                        var tvar = $('#tInput').val();\n                        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n                        var tcall = $(this).text().replace(\"d\", tvar);\n                        $('#tInput').val(tcall);\n                        $(this).parent().fadeOut(100);\n                        evt.stopPropagation();\n                        transform(tvar, tfunc, typeTransform = false);\n                    }\n                }, list.map(function (x) {\n                    return (0, _mithril2.default)('li', x);\n                }));\n            };\n            var spaceBtn = function spaceBtn(id, onclick, title, icon) {\n                return (0, _mithril2.default)('button#' + id + '.btn.btn-default', { onclick: onclick, title: title }, glyph(icon, true));\n            };\n\n            if (mode != this.last_mode) {\n                app.restart && app.restart(null, explore);\n                this.last_mode = mode;\n            }\n\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", { style: mode === 'explore' && 'background-image: -webkit-linear-gradient(top, #fff 0, rgb(227, 242, 254) 100%)' }, (0, _mithril2.default)(\"a.navbar-brand\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 1em; margin-top: -0.5em]\", { onmouseover: function onmouseover(_) {\n                    return _this.about = true;\n                }, onmouseout: function onmouseout(_) {\n                    return _this.about = false;\n                } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', { onclick: function onclick(_) {\n                    return _this.cite = _this.citeHidden = !_this.citeHidden;\n                },\n                onmouseout: function onmouseout(_) {\n                    return _this.citeHidden || (_this.cite = false);\n                },\n                onmouseover: function onmouseover(_) {\n                    return _this.cite = true;\n                } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default', { style: 'display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50' }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)('span', (0, _mithril2.default)('.dropdown[style=float: right; padding-right: 1em]', (0, _mithril2.default)('#drop.button.btn[type=button][data-toggle=dropdown][aria-haspopup=true][aria-expanded=false]', [username, glyph('heart-empty')]), (0, _mithril2.default)('ul.dropdown-menu[role=menu][aria-labelledby=drop]', (0, _mithril2.default)('li[style=padding: 0.5em]', 'something here 1'), (0, _mithril2.default)('li[style=padding: 0.5em]', 'something here 2'))),\n            /*m('h5#userName[style=float: right; padding-right: 0.5em]',\n              {onmouseover: _ => this.usertasks = true, onmouseout: _ => this.usertasks = false},\n              [username, glyph('heart-empty')],  // const username defined in templates/index.html\n              m(`#usertasks.panel.panel-default[style=display: ${this.usertasks ? 'block' : 'none'}; position: absolute; z-index: 50]`,\n                m('.panel-body[style=text-align: left; padding: 1em]','logout'))),*/\n            navBtn('btnEstimate.btn-success', 2, 1, explore ? exp.explore : app.estimate, (0, _mithril2.default)(\"span.ladda-label\", explore ? 'Explore' : 'Solve This Problem'), '150px'), navBtn('btnTA2.btn-default', .5, 1, function (_) {\n                return app.helpmaterials('manual');\n            }, ['Help Manual ', glyph('book')]), navBtn('btnTA2.btn-default', 2, .5, function (_) {\n                return app.helpmaterials('video');\n            }, ['Help Video ', glyph('expand')]), navBtn1(\"btnReset\", app.reset, glyph('repeat'), 'Reset'), navBtn1('btnEndSession', app.endsession, (0, _mithril2.default)(\"span.ladda-label\", 'Mark Problem Finished'), 'Mark Problem Finished')), (0, _mithril2.default)('#tInput', {\n                style: { display: 'none' },\n                onclick: function onclick(_) {\n                    if (byId('transSel').style.display !== 'none') {\n                        // if variable list is displayed when input is clicked...\n                        $('#transSel').fadeOut(100);\n                        return false;\n                    }\n                    if (byId('transList').style.display !== 'none') {\n                        // if function list is displayed when input is clicked...\n                        $('#transList').fadeOut(100);\n                        return false;\n                    }\n\n                    // highlight the text\n                    $(_this).select();\n                    var pos = $('#tInput').offset();\n                    pos.top += $('#tInput').width();\n                    $('#transSel').fadeIn(100);\n                    return false;\n                },\n                keyup: function keyup(evt) {\n                    var t = byId('transSel').style.display;\n                    var t1 = byId('transList').style.display;\n                    if (t !== 'none') {\n                        $('#transSel').fadeOut(100);\n                    } else if (t1 !== 'none') {\n                        $('#transList').fadeOut(100);\n                    }\n\n                    if (evt.keyCode == 13) {\n                        // keyup on Enter\n                        var _t = transParse($('#tInput').val());\n                        if (!_t) {\n                            return;\n                        }\n                        transform(_t.slice(0, _t.length - 1), _t[_t.length - 1], typeTransform = false);\n                    }\n                }\n            }), (0, _mithril2.default)('#transformations.transformTool', {\n                title: 'Construct transformations of existing variables using valid R syntax.\\n                              For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }, transformation('transSel', ['a', 'b']), transformation('transList', app.transformList)))), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: hidden]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", spaceBtn('btnLock.active', app.lockDescription, 'Lock selection of problem description', 'pencil'), spaceBtn('btnJoin', function (_) {\n                var _ref;\n\n                var links = [];\n                if (explore) {\n                    var is_unique = function is_unique(n, n1) {\n                        return links.map(function (l) {\n                            return l.target === n1 && l.source === n;\n                        }).length == 0;\n                    };\n                    links = app.nodes.map(function (n) {\n                        return app.nodes.filter(function (n1) {\n                            return n !== n1 && is_unique(n, n1);\n                        }).map(function (n1) {\n                            return {\n                                left: false,\n                                right: false,\n                                target: n,\n                                source: n1\n                            };\n                        });\n                    });\n                } else {\n                    var dvs = app.nodes.filter(function (n) {\n                        return app.zparams.zdv.includes(n.name);\n                    });\n                    var ivs = app.nodes.filter(function (n) {\n                        return !dvs.includes(n);\n                    });\n                    links = dvs.map(function (dv) {\n                        return ivs.map(function (iv) {\n                            return {\n                                left: true,\n                                right: false,\n                                target: iv,\n                                source: dv\n                            };\n                        });\n                    });\n                }\n                app.restart((_ref = []).concat.apply(_ref, _toConsumableArray(links)));\n            }, 'Make all possible connections between nodes', 'link'), spaceBtn('btnDisconnect', function (_) {\n                return app.restart([]);\n            }, 'Delete all connections between nodes', 'remove-circle'), spaceBtn('btnForce', app.forceSwitch, 'Pin the variable pebbles to the page', 'pushpin'), spaceBtn('btnEraser', app.erase, 'Wipe all variables from the modeling space', 'magnet')), (0, _mithril2.default)(_Subpanel2.default, { title: \"Legend\",\n                buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), ticker(mode), leftpanel(mode), rightpanel(mode)));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n    '/model': { render: function render() {\n            return (0, _mithril2.default)(Body);\n        } },\n    '/explore': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'explore' });\n        } },\n    '/results': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'results' });\n        } }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYXNzZXRzL2FwcC9pbmRleC5qcz83OGMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY3NzL2FwcC5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3MnO1xuXG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4vYXBwJztcbmltcG9ydCAqIGFzIGV4cCBmcm9tICcuL2V4cGxvcmUnO1xuaW1wb3J0ICogYXMgcGxvdHMgZnJvbSAnLi9wbG90cyc7XG5pbXBvcnQgUGFuZWwgZnJvbSAnLi92aWV3cy9QYW5lbCc7XG5pbXBvcnQgQnV0dG9uLCB7d2hlbn0gZnJvbSAnLi92aWV3cy9QYW5lbEJ1dHRvbic7XG5pbXBvcnQgTGlzdCBmcm9tICcuL3ZpZXdzL1BhbmVsTGlzdCc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vdmlld3MvU2VhcmNoJztcbmltcG9ydCBTdWJwYW5lbCBmcm9tICcuL3ZpZXdzL1N1YnBhbmVsJztcblxuZnVuY3Rpb24gc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSBjb2xvcjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBsZWZ0cGFuZWwobW9kZSkge1xuICAgIGlmKG1vZGUgPT0gXCJyZXN1bHRzXCIpe1xuICAgICAgICByZXR1cm4gbShcbiAgICAgICAgICAgIFBhbmVsLFxuICAgICAgICAgICAge3NpZGU6ICdsZWZ0JyxcbiAgICAgICAgICAgICB0aXRsZTogJ1BpcGVsaW5lcycsXG4gICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICBtKEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICB7aWQ6ICdidG5WYXJpYWJsZXMnLFxuICAgICAgICAgICAgICAgICAgICBpZDI6ICd0YWIxJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDbGljayB2YXJpYWJsZSBuYW1lIHRvIGFkZCBvciByZW1vdmUgdGhlIHZhcmlhYmxlIHBlYmJsZSBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZS4nfSxcbiAgICAgICAgICAgICAgICAgICAnVmFyaWFibGVzJyksXG4gICAgICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TdWJzZXQnLCBpZDI6ICd0YWIyJ30sICdTdWJzZXQnKSxcbiAgICAgICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgICAgICAge2lkOiAnYnRuU2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogJ2J0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9IzAwMDAwMF1bZGF0YS1zdHlsZT16b29tLWluXScsXG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnN1YnNldFNlbGVjdCgnYnRuU2VsZWN0JyksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZGlzcGxheTogJHthcHAuc3Vic2V0ID8gJ2Jsb2NrJyA6ICdub25lJ307IGZsb2F0OiByaWdodDsgbWFyZ2luLXJpZ2h0OiAxMHB4YCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWJzZXQgZGF0YSBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBzZWxlY3RlZCB2YWx1ZXMuJ30sXG4gICAgICAgICAgICAgICAgICAgbSgnc3Bhbi5sYWRkYS1sYWJlbFtzdHlsZT1wb2ludGVyLWV2ZW50czogbm9uZV0nLCAnU2VsZWN0JykpXX0sXG4gICAgICAgICAgICBtKGAjdGFiMVtzdHlsZT1kaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMScpfTsgcGFkZGluZzogMCA4cHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLFxuICAgICAgICAgICAgICBtKFNlYXJjaCwge3BsYWNlaG9sZGVyOiAnU2VhcmNoIHZhcmlhYmxlcyBhbmQgbGFiZWxzJ30pLFxuICAgICAgICAgICAgICBtKExpc3QsIHtpdGVtczogYXBwLnZhbHVlS2V5LCB0aXRsZTogJ1N1bW1hcnkgU3RhdGlzdGljcyd9KSksXG4gICAgICAgICAgICBtKGAjdGFiMltzdHlsZT1kaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMicpfTsgbWFyZ2luLXRvcDogLjVlbV1gKSxcbiAgICAgICAgICAgIG0oJyN0YWIzW3N0eWxlPWhlaWdodDogMzUwcHhdJyxcbiAgICAgICAgICAgICAgbShgcFtzdHlsZT1wYWRkaW5nOiAuNWVtIDFlbTsgZGlzcGxheTogJHt3aGVuKCdsZWZ0JywgJ3RhYjMnKX1dYCxcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiU2VsZWN0IGEgdmFyaWFibGUgZnJvbSB3aXRoaW4gdGhlIHZpc3VhbGl6YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbCB0byB2aWV3IGl0cyBzdW1tYXJ5IHN0YXRpc3RpY3MuXCJ9LFxuICAgICAgICAgICAgICAgIG0oJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICBtKCdiJywgYXBwLnN1bW1hcnkubmFtZSksXG4gICAgICAgICAgICAgICAgICBtKCdicicpLFxuICAgICAgICAgICAgICAgICAgbSgnaScsIGFwcC5zdW1tYXJ5LmxhYmwpKSxcbiAgICAgICAgICAgICAgICBtKCd0YWJsZScsIGFwcC5zdW1tYXJ5LmRhdGEubWFwKFxuICAgICAgICAgICAgICAgICAgICB0ciA9PiBtKCd0cicsIHRyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkID0+IG0oJ3RkJywge29ubW91c2VvdmVyOiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2FsaWNlYmx1ZScpLCBvbm1vdXNlb3V0OiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2Y5ZjlmOScpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGQpKSkpKSkpKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBtKFxuICAgICAgICBQYW5lbCxcbiAgICAgICAge3NpZGU6ICdsZWZ0JyxcbiAgICAgICAgIHRpdGxlOiAnRGF0YSBTZWxlY3Rpb24nLFxuICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgIG0oQnV0dG9uLFxuICAgICAgICAgICAgICAge2lkOiAnYnRuVmFyaWFibGVzJyxcbiAgICAgICAgICAgICAgICBpZDI6ICd0YWIxJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLid9LFxuICAgICAgICAgICAgICAgJ1ZhcmlhYmxlcycpLFxuICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TdWJzZXQnLCBpZDI6ICd0YWIyJ30sICdTdWJzZXQnKSxcbiAgICAgICAgICAgICBtKEJ1dHRvbixcbiAgICAgICAgICAgICAgIHtpZDogJ2J0blNlbGVjdCcsXG4gICAgICAgICAgICAgICAgY2xhc3NlczogJ2J0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9IzAwMDAwMF1bZGF0YS1zdHlsZT16b29tLWluXScsXG4gICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuc3Vic2V0U2VsZWN0KCdidG5TZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBzdHlsZTogYGRpc3BsYXk6ICR7YXBwLnN1YnNldCA/ICdibG9jaycgOiAnbm9uZSd9OyBmbG9hdDogcmlnaHQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdTdWJzZXQgZGF0YSBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBzZWxlY3RlZCB2YWx1ZXMuJ30sXG4gICAgICAgICAgICAgICBtKCdzcGFuLmxhZGRhLWxhYmVsW3N0eWxlPXBvaW50ZXItZXZlbnRzOiBub25lXScsICdTZWxlY3QnKSldfSxcbiAgICAgICAgbShgI3RhYjFbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdsZWZ0JywgJ3RhYjEnKX07IHBhZGRpbmc6IDAgOHB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCxcbiAgICAgICAgICBtKFNlYXJjaCwge3BsYWNlaG9sZGVyOiAnU2VhcmNoIHZhcmlhYmxlcyBhbmQgbGFiZWxzJ30pLFxuICAgICAgICAgIG0oTGlzdCwge2l0ZW1zOiBhcHAudmFsdWVLZXksIHRpdGxlOiAnU3VtbWFyeSBTdGF0aXN0aWNzJ30pKSxcbiAgICAgICAgbShgI3RhYjJbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdsZWZ0JywgJ3RhYjInKX07IG1hcmdpbi10b3A6IC41ZW1dYCksXG4gICAgICAgIG0oJyN0YWIzW3N0eWxlPWhlaWdodDogMzUwcHhdJyxcbiAgICAgICAgICBtKGBwW3N0eWxlPXBhZGRpbmc6IC41ZW0gMWVtOyBkaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMycpfV1gLFxuICAgICAgICAgICAge3RpdGxlOiBcIlNlbGVjdCBhIHZhcmlhYmxlIGZyb20gd2l0aGluIHRoZSB2aXN1YWxpemF0aW9uIGluIHRoZSBjZW50ZXIgcGFuZWwgdG8gdmlldyBpdHMgc3VtbWFyeSBzdGF0aXN0aWNzLlwifSxcbiAgICAgICAgICAgIG0oJ2NlbnRlcicsXG4gICAgICAgICAgICAgIG0oJ2InLCBhcHAuc3VtbWFyeS5uYW1lKSxcbiAgICAgICAgICAgICAgbSgnYnInKSxcbiAgICAgICAgICAgICAgbSgnaScsIGFwcC5zdW1tYXJ5LmxhYmwpKSxcbiAgICAgICAgICAgIG0oJ3RhYmxlJywgYXBwLnN1bW1hcnkuZGF0YS5tYXAoXG4gICAgICAgICAgICAgICAgdHIgPT4gbSgndHInLCB0ci5tYXAoXG4gICAgICAgICAgICAgICAgICAgIHRkID0+IG0oJ3RkJywge29ubW91c2VvdmVyOiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2FsaWNlYmx1ZScpLCBvbm1vdXNlb3V0OiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2Y5ZjlmOScpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZCkpKSkpKSkpO1xuICAgIH1cbn1cblxubGV0IHJpZ2h0dGFiID0gKGlkLCBidG5JZCwgdGFzaywgdGl0bGUsIHByb2JEZXNjKSA9PiBtKFxuICAgIGAjJHtpZH1bc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdyaWdodCcsIGJ0bklkKX07IHBhZGRpbmc6IDZweCAxMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCxcbiAgICBtKExpc3QsXG4gICAgICB7aXRlbXM6IE9iamVjdC5rZXlzKHRhc2sgfHwge30pLFxuICAgICAgIHRpdGxlOiB0aXRsZSArICcgRGVzY3JpcHRpb24nLFxuICAgICAgIGNvbnRlbnQ6IHYgPT4gdGFza1t2XVsxXSxcbiAgICAgICBwcm9iRGVzYzogcHJvYkRlc2N9KSk7XG5cbmZ1bmN0aW9uIHJpZ2h0cGFuZWwobW9kZSkge1xuICAgIGxldCB0aHVtYm5haWwgPSAoaWR4LCBpZCwgdGl0bGUpID0+XG4gICAgICAgIG0oXCJ0aFwiLFxuICAgICAgICAgIG0oXCJmaWd1cmVcIiwge3N0eWxlOiB7ZmxvYXQ6IFwibGVmdFwifX0sXG4gICAgICAgICAgICBtKGBpbWcjJHtpZH1faW1nW2FsdD0ke2lkfV1bc3JjPS9zdGF0aWMvaW1hZ2VzL3RodW1iJHtpZHh9LnBuZ11gLFxuICAgICAgICAgICAgICB7c3R5bGU6IHt3aWR0aDogXCI3NSVcIiwgaGVpZ2h0OiBcIjc1JVwiLCBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIiwgXCJib3JkZXItcmFkaXVzXCI6IFwiM3B4XCIsIHBhZGRpbmc6IFwiNXB4XCIsIG1hcmdpbjogXCIzJVwiLCBjdXJzb3I6IFwicG9pbnRlclwifX0pLFxuICAgICAgICAgICAgbShcImZpZ2NhcHRpb25cIiwge3N0eWxlOiB7XCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJ9fSwgdGl0bGUpKSk7XG4gICAgcmV0dXJuIG1vZGUgP1xuICAgICAgICBtKFBhbmVsLFxuICAgICAgICAgIHtzaWRlOiAncmlnaHQnLFxuICAgICAgICAgICB0aXRsZTogJ1Jlc3VsdCBFeHBsb3JhdGlvbicsXG4gICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5Vbml2YXJpYXRlJ30sICdVbml2YXJpYXRlJyksXG4gICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuQml2YXJpYXRlJ30sICdCaXZhcmlhdGUnKV19LFxuICAgICAgICAgIG0oJyNtb2RlbFZpZXdfQ29udGFpbmVyJywge3N0eWxlOiAnd2lkdGg6IDEwMCU7IGhlaWdodDogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IGZsb2F0OiBsZWZ0OyBvdmVyZmxvdy14OiBhdXRvOyBvdmVyZmxvdy15OiBoaWRkZW47IHdoaXRlLXNwYWNlOiBub3dyYXA7J30sXG4gICAgICAgICAgICBtKCcjbW9kZWxWaWV3Jywge3N0eWxlOiAnd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IGZsb2F0OiBsZWZ0OyBvdmVyZmxvdzogYXV0bzsgbWFyZ2luLXRvcDogMnB4Oyd9KSksXG4gICAgICAgICAgbSgnI2RlY2lzaW9uVHJlZVtzdHlsZT13aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBiYWNrZ3JvdW5kOiAjZmY1OTMyXScpLFxuICAgICAgICAgIG0oJyNyZXN1bHRfbGVmdCcsXG4gICAgICAgICAgICB7c3R5bGU6IHtcIndpZHRoXCI6IFwiNTAlXCIsIFwiaGVpZ2h0XCI6IFwiOTAlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyLXJpZ2h0XCI6IFwicmlkZ2VcIiwgXCJib3JkZXItYm90dG9tXCI6IFwicmlkZ2VcIiwgXCJvdmVyZmxvd1wiOiBcImF1dG9cIiwgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwifX0sXG4gICAgICAgICAgICBtKCcjbGVmdF90aHVtYm5haWwnLFxuICAgICAgICAgICAgICB7c3R5bGU6IHtcIndpZHRoXCI6IFwiMTAwJVwiLCBcImhlaWdodFwiOiBcIjIwJVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcIm1hcmdpbi10b3BcIjogXCIzJVwiLCBcIm1hcmdpbi1yaWdodFwiOiBcIjMlXCIsIFwiYm9yZGVyLWJvdHRvbVwiOiBcInJpZGdlXCIsIFwib3ZlcmZsb3dcIjogXCJhdXRvXCIsIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIn19LFxuICAgICAgICAgICAgICBtKFwidGFibGVcIixcbiAgICAgICAgICAgICAgICBtKFwidGJvZHlcIixcbiAgICAgICAgICAgICAgICAgIG0oXCJ0clwiLFxuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwoMSwgJ3NjYXR0ZXJwbG90JywgXCJTY2F0dGVyIFBsb3RcIiksXG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbCgyLCAnaGVhdG1hcCcsIFwiSGVhdHBtYXBcIiksXG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbCgzLCAnbGluZWNoYXJ0JywgXCJMaW5lY2hhcnRcIikpKSkpLFxuICAgICAgICAgICAgbSgnI3Jlc3VsdF9sZWZ0MScsIHtzdHlsZToge3dpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjYwJVwiLCBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIiwgXCJtYXJnaW4tdG9wXCI6IFwiMyVcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwifX0sXG4gICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyM1tpZD1zY2F0dGVycGxvdF1cIiwge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjUwMHB4XCIsIFwiaGVpZ2h0XCI6IFwiODAlXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIiwgXCJtYXJnaW5cIjogXCI1JSBcIn19KSxcbiAgICAgICAgICAgICAgbShcIi5jb250YWluZXI0W2lkPWhlYXRjaGFydF1cIiwge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjUwMHB4XCIsIFwiaGVpZ2h0XCI6IFwiODAlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiI0ZGRUJFRVwiLCBcIm1hcmdpblwiOiBcIjUlICBcIn19KSxcbiAgICAgICAgICAgICAgbShcIi5jb250YWluZXI0W2lkPWxpbmVjaGFydF1cIiwge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjUwMHB4XCIsIFwiaGVpZ2h0XCI6IFwiODAlXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIiwgXCJtYXJnaW5cIjogXCI1JSBcIn19KSksXG4gICAgICAgICAgICBtKFwiZGl2XCIsIHtzdHlsZToge1wiYm9yZGVyLWJvdHRvbVwiOiBcInJpZGdlXCIsIFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcIm1hcmdpbi1ib3R0b21cIjogXCIyJVwiLCBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIn19LFxuICAgICAgICAgICAgICBtKFwiaDUjTkFjb3VudFwiLCB7c3R5bGU6IHtcIiBtYXJnaW4tYm90dG9tXCI6IFwiMFwifX0pKSxcbiAgICAgICAgICAgIG0oXCIuY29udGFpbmVyMltpZD0ncmVzdWx0c1ZpZXdfc3RhdGlzdGljcyddXCIsXG4gICAgICAgICAgICAgIHtzdHlsZToge1wid2lkdGhcIjogXCIxMDAlXCIsIFwiaGVpZ2h0XCI6IFwiMTUlXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIiwgXCJtYXJnaW4tYm90dG9tXCI6IFwiMyVcIiwgXCJib3JkZXItYm90dG9tXCI6IFwicmlkZ2VcIn19KSksXG4gICAgICAgICAgbSgnI3Jlc3VsdF9yaWdodCcsXG4gICAgICAgICAgICB7c3R5bGU6IHt3aWR0aDogXCI1MCVcIiwgaGVpZ2h0OiBcIjkwJVwiLCBmbG9hdDogXCJyaWdodFwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlci1yaWdodFwiOiBcImdyb292ZVwiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJ9fSxcbiAgICAgICAgICAgIG0oJyNyZXN1bHRzVmlld190YWJ1bGFyLmNvbnRhaW5lcjEnLFxuICAgICAgICAgICAgICB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIGZsb2F0OiBcImxlZnRcIiwgb3ZlcmZsb3c6IFwiYXV0b1wiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCIsIFwiYm9yZGVyLXJpZ2h0XCI6IFwiZ3Jvb3ZlXCIsIFwiYm9yZGVyLWJvdHRvbVwiOiBcImdyb292ZVwifX0sXG4gICAgICAgICAgICAgIG0oJyNTZWxlY3Rpb25EYXRhJywge3N0eWxlOiB7d2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiNTUlXCIsIG92ZXJmbG93OiBcImF1dG9cIiwgXCJtYXJnaW4tdG9wXCI6IFwiMTBweFwiLCBcImJvcmRlci1ib3R0b20tc3R5bGVcIjogXCJpbnNldFwifX0sXG4gICAgICAgICAgICAgICAgbShcImZpZWxkc2V0XCIsIHtzdHlsZToge21hcmdpbjogXCIzJVwifX0sXG4gICAgICAgICAgICAgICAgICBtKFwiaDRcIiwge3N0eWxlOiB7XCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJ9fSwgXCJEYXRhIERpc3RyaWJ1dGlvbiBTZWxlY3Rpb25cIiksXG4gICAgICAgICAgICAgICAgICBtKFwicFwiLCB7c3R5bGU6IHtcImZvbnQtZmFtaWx5XCI6IFwiQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZlwiLCBcImZvbnQtc2l6ZVwiOiBcIjEycHhcIn19LFxuICAgICAgICAgICAgICAgICAgICBcIkVudGVyIG51bWJlciBmb3IgZWFjaCB2YXJpYWJsZSB0byBzcGVjaWZ5IHRoZSBicmVhayBwb2ludHNcIiksXG4gICAgICAgICAgICAgICAgICBtKCdwI2JvbGRzdHVmZicsIHtzdHlsZToge2NvbG9yOiBcIiMyYTY0OTZcIiwgXCJmb250LWZhbWlseVwiOiBcIkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWZcIiwgXCJmb250LXNpemVcIjogXCIxMnB4XCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3QgYmV0d2VlbiBFcXVpZGlzdGFudCBhbmQgRXF1aW1hc3NcIikpLFxuICAgICAgICAgICAgICAgIG0oJyNmb3JQbG90QScsIHtzdHlsZToge2Rpc3BsYXk6ICdibG9jaycsIFwibWFyZ2luXCI6IFwiMiVcIn19LFxuICAgICAgICAgICAgICAgICAgbShcImlucHV0I2lucHV0MVtuYW1lPSdmbmFtZSddW3R5cGU9J3RleHQnXVwiLCB7c3R5bGU6IHtcIm1hcmdpbi1sZWZ0XCI6IFwiMiVcIn19KSxcbiAgICAgICAgICAgICAgICAgIG0oJ3NwYW4jdG9vbHRpcFBsb3RBLnRvb2x0aXB0ZXh0W3N0eWxlPXZpc2liaWxpdHk6IGhpZGRlbl0nKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNFcXVpZGlzdGFuY2UxW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgXCJFUVVJRElTVEFOQ0VcIiksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjRXF1aW1hc3MxW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgXCJFUVVJTUFTU1wiKSksXG4gICAgICAgICAgICAgICAgbSgnI2ZvclBsb3RCJywge3N0eWxlOiB7ZGlzcGxheTogXCJibG9ja1wiLCBtYXJnaW46IFwiMiVcIn19LFxuICAgICAgICAgICAgICAgICAgbShcImlucHV0I2lucHV0MltuYW1lPSdmbmFtZTEnXVt0eXBlPSd0ZXh0J11cIiwge3N0eWxlOiB7XCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSksXG4gICAgICAgICAgICAgICAgICBtKCdzcGFuI3Rvb2x0aXBQbG90Qi50b29sdGlwdGV4dDFbc3R5bGU9dmlzaWJpbGl0eTogaGlkZGVuXScpLFxuICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQuYnRuLXhzI0VxdWlkaXN0YW5jZTJbdHlwZT0nYnV0dG9uJ11cIiwge3N0eWxlOiB7ZmxvYXQ6IFwibGVmdFwiLCBcIm1hcmdpbi1sZWZ0XCI6IFwiMiVcIn19LCBcIkVRVUlESVNUQU5DRVwiKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNFcXVpbWFzczJbdHlwZT0nYnV0dG9uJ11cIiwge3N0eWxlOiB7ZmxvYXQ6IFwibGVmdFwiLCBcIm1hcmdpbi1sZWZ0XCI6IFwiMiVcIn19LCBcIkVRVUlNQVNTXCIpKSxcbiAgICAgICAgICAgICAgICBtKFwiI3Bsb3RBX3N0YXR1c1tzdHlsZT1tYXJnaW4tdG9wOiAxJTsgbWFyZ2luLWxlZnQ6IDIlXVwiKSxcbiAgICAgICAgICAgICAgICBtKFwiI3Bsb3RCX3N0YXR1c1tzdHlsZT1tYXJnaW4tdG9wOiAxJTsgbWFyZ2luLWxlZnQ6IDIlXVwiKSxcbiAgICAgICAgICAgICAgICBtKCdoNVtzdHlsZT1jb2xvcjogI2FjMjkyNTsgbWFyZ2luLXRvcDogMSU7IG1hcmdpbi1sZWZ0OiAyJV0nLCAnU2VsZWN0aW9uIEhpc3RvcnknKSxcbiAgICAgICAgICAgICAgICBtKCcjYnJlYWtzcGFjZVtzdHlsZT1kaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG92ZXJmbG93OiBhdXRvOyB3aWR0aDogMTAwJV0nKSksXG4gICAgICAgICAgICAgIG0oJyN0YWJ1bGFyXzEnLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIzMCVcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCI6IFwiaW5zZXRcIiwgXCJtYXJnaW4tdG9wXCI6IFwiMyVcIn19LFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi1zbVtpZD0nU2VsZWN0aW9uRGF0YTEnXVt0eXBlPSdidXR0b24nXVwiLCB7c3R5bGU6IHtkaXNwbGF5OiBcImJsb2NrXCIsIG1hcmdpbjogXCIwIGF1dG9cIiwgcG9zaXRpb246IFwicmVsYXRpdmVcIn19LFxuICAgICAgICAgICAgICAgICAgXCJDcmVhdGVcIiksXG4gICAgICAgICAgICAgICAgbSgnI3Bsb3RBJywge3N0eWxlOiB7d2lkdGg6IGV4cC5nZXRfd2lkdGgoJ3Bsb3RBJykgKyAnJScsIGhlaWdodDogXCIxMDAlXCIsIGZsb2F0OiBcImxlZnRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSwgXCJwbG90QVwiKSxcbiAgICAgICAgICAgICAgICBtKCcjcGxvdEInLCB7c3R5bGU6IHt3aWR0aDogZXhwLmdldF93aWR0aCgncGxvdEInKSArICclJywgaGVpZ2h0OiBcIjEwMCVcIiwgZmxvYXQ6IFwicmlnaHRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSwgXCJwbG90QlwiKSksXG4gICAgICAgICAgICAgIG0oJyN0YWJ1bGFyXzInLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCI1MCVcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCI6IFwiaW5zZXRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSkpKSxcbiAgICAgICAgICBtKFwicCNyZXN1bHRzSG9sZGVyXCIsIHtzdHlsZToge3BhZGRpbmc6IFwiLjVlbSAxZW1cIn19KSxcbiAgICAgICAgICBtKCcjc2V0eFtzdHlsZT1kaXNwbGF5OiBub25lOyBtYXJnaW4tdG9wOiAuNWVtXScpKSA6XG4gICAgLy8gbW9kZSA9PSBudWxsIChtb2RlbCBtb2RlKVxuICAgIG0oUGFuZWwsXG4gICAgICB7c2lkZTogJ3JpZ2h0JyxcbiAgICAgICB0aXRsZTogJ01vZGVsIFNlbGVjdGlvbicsXG4gICAgICAgYnV0dG9uczogKCFhcHAuSVNfRDNNX0RPTUFJTiA/IFtdIDogW1xuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTW9kZWxzJ30sICdNb2RlbHMnKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blNldHgnfSwgJ1NldCBDb3Zhci4nKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blJlc3VsdHMnfSwgJ1Jlc3VsdHMnKSxcbiAgICAgICBdKS5jb25jYXQoW1xuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuVHlwZSd9LCAnVGFzayBUeXBlJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TdWJ0eXBlJ30sICdTdWJ0eXBlJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5NZXRyaWNzJ30sICdNZXRyaWNzJyldKX0sXG4gICAgICBtKGAjcmVzdWx0c1tzdHlsZT1kaXNwbGF5OiAke3doZW4oJ3JpZ2h0JywgJ2J0blJlc3VsdHMnKX07IG1hcmdpbi10b3A6IC41ZW1dYCxcbiAgICAgICAgbShcIiNyZXN1bHRzVmlldy5jb250YWluZXJbc3R5bGU9ZmxvYXQ6IHJpZ2h0OyBvdmVyZmxvdzogYXV0bzsgd2lkdGg6IDgwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IHdoaXRlLXNwYWNlOiBub3dyYXBdXCIpLFxuICAgICAgICBtKCcjbW9kZWxWaWV3W3N0eWxlPWRpc3BsYXk6IG5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMjAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSxcbiAgICAgICAgbShcInAjcmVzdWx0c0hvbGRlcltzdHlsZT1wYWRkaW5nOiAuNWVtIDFlbV1cIikpLFxuICAgICAgbShgI3NldHhbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdyaWdodCcsICdidG5TZXR4Jyl9XWAsXG4gICAgICAgIG0oJyNzZXR4TGVmdEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDMwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhMZWZ0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0Ojk1JTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSxcbiAgICAgICAgbSgnI3NldHhSaWdodEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhSaWdodFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo2NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKCcjc2V0eE1pZGRsZVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgbSgnI3NldHhSaWdodFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogcmlnaHQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSkpLFxuICAgICAgICBtKCcjc2V0eFJpZ2h0Qm90dG9tW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0OjM1JTsgb3ZlcmZsb3c6YXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICBtKCcjc2V0eFJpZ2h0Qm90dG9tTGVmdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDc1JTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21NaWRkbGVbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAxNSU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgIHtpZDogJ2J0bkV4ZWN1dGVQaXBlJyxcbiAgICAgICAgICAgICAgIGNsYXNzZXM6ICdidG4tZGVmYXVsdC5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl0nLFxuICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuZXhlY3V0ZXBpcGVsaW5lKCdidG5FeGVjdXRlUGlwZScpLFxuICAgICAgICAgICAgICAgc3R5bGU6IGBkaXNwbGF5OmlubGluZTsgZmxvYXQ6IGxlZnQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICB0aXRsZTogJ0V4ZWN1dGUgcGlwZWxpbmUuJ30sXG4gICAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ0V4ZWN1dGUnKSkpLFxuICAgICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21SaWdodFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSksXG4gICAgICByaWdodHRhYignbW9kZWxzJywgJ2J0bk1vZGVscycpLFxuICAgICAgcmlnaHR0YWIoJ3R5cGVzJywgJ2J0blR5cGUnLCBhcHAuZDNtVGFza1R5cGUsICdUYXNrJywgJ3Rhc2tUeXBlJyksXG4gICAgICByaWdodHRhYignc3VidHlwZXMnLCAnYnRuU3VidHlwZScsIGFwcC5kM21UYXNrU3VidHlwZSwgJ1Rhc2sgU3VidHlwZScsICd0YXNrU3VidHlwZScpLFxuICAgICAgcmlnaHR0YWIoJ21ldHJpY3MnLCAnYnRuTWV0cmljcycsIGFwcC5kM21NZXRyaWNzLCAnTWV0cmljJywgJ21ldHJpYycpKTtcbn1cblxubGV0IHRpY2tlciA9IG1vZGUgPT4ge1xuICAgIGxldCBsaW5rID0gbmFtZSA9PiBtKGBhJHtuYW1lID09PSBtb2RlID8gJy5hY3RpdmUnIDogJyd9W2hyZWY9LyR7bmFtZX1dW3N0eWxlPW1hcmdpbi1yaWdodDogMC41ZW1dYCwge29uY3JlYXRlOiBtLnJvdXRlLmxpbmt9LCBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gbSgnI3RpY2tlcltzdHlsZT1iYWNrZ3JvdW5kOiAjRjlGOUY5OyBib3R0b206IDA7IGhlaWdodDogNDBweDsgcG9zaXRpb246IGZpeGVkOyB3aWR0aDogMTAwJTsgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNBREFEQURdJyxcbiAgICAgICAgbGluaygnbW9kZWwnKSxcbiAgICAgICAgbGluaygnZXhwbG9yZScpLFxuICAgICAgICBsaW5rKCdyZXN1bHRzJyksXG4gICAgICAgIG0oXCJhI2xvZ0lEW2hyZWY9c29tZWxpbmtdW3RhcmdldD1fYmxhbmtdW3N0eWxlPW1hcmdpbi1yaWdodDogMC41ZW1dXCIsIFwiUmVwbGljYXRpb25cIiksXG4gICAgICAgIC8vIGRldiBsaW5rcy4uLlxuICAgICAgICBtKFwiYVtocmVmPScvZGV2LXJhdmVuLWxpbmtzJ11bdGFyZ2V0PV9ibGFua11bc3R5bGU9bWFyZ2luLXJpZ2h0OiAwLjVlbV1cIiwgXCJyYXZlbi1saW5rc1wiKSxcbiAgICAgICAgbShcImFbc3R5bGU9bWFyZ2luLXJpZ2h0OiAwLjVlbV1cIixcbiAgICAgICAgICB7b25jbGljazogYXBwLnJlY29yZF91c2VyX21ldGFkYXRhfSxcbiAgICAgICAgICBcInJlY29yZC1tZXRhZGF0YVwiKSk7XG59O1xuXG5jbGFzcyBCb2R5IHtcbiAgICBvbmluaXQoKSB7XG4gICAgICAgIHRoaXMuYWJvdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VydGFza3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2l0ZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RfbW9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAgIGxldCBleHRyYWN0ID0gKG5hbWUsIGtleSwgb2Zmc2V0LCByZXBsYWNlKSA9PiB7XG4gICAgICAgICAgICBrZXkgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICBsZXQgbG9jID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgdmFsID0gbG9jLmluZGV4T2Yoa2V5KSA+IDAgPyBsb2Muc3Vic3RyaW5nKGxvYy5pbmRleE9mKGtleSkgKyBvZmZzZXQpIDogJyc7XG4gICAgICAgICAgICBsZXQgaWR4ID0gdmFsLmluZGV4T2YoJyYnKTtcbiAgICAgICAgICAgIHZhbCA9IGlkeCA+IDAgPyB2YWwuc3Vic3RyaW5nKDAsIGlkeCkgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgnIyEvbW9kZWwnLCAnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnOiAnLCB2YWwpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHZhbCA9IHZhbFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMjUvZywgJyUnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvZywgJzonKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIGFwcC5tYWluKFxuICAgICAgICAgICAgZXh0cmFjdCgnZmlsZWlkJywgJ2RmSWQnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2hvc3RuYW1lJywgJ2hvc3QnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RkaXVybCcsICdkZGl1cmwnLCA3LCB0cnVlKSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RhdGF1cmwnLCAnZGF0YXVybCcsIDgsIHRydWUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnYXBpa2V5JywgJ2tleScsIDQpKTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7bW9kZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgbGV0IGV4cGxvcmUgPSBtb2RlID09PSAnZXhwbG9yZSc7XG4gICAgICAgIGFwcC5pc19yZXN1bHRzX21vZGUgPSBtb2RlID09PSAncmVzdWx0cyc7XG4gICAgICAgIGxldCBfbmF2QnRuID0gKGlkLCBsZWZ0LCByaWdodCwgb25jbGljaywgYXJncywgbWluKSA9PiBtKFxuICAgICAgICAgICAgYGJ1dHRvbiMke2lkfS5idG4ubmF2YmFyLXJpZ2h0YCxcbiAgICAgICAgICAgIHtvbmNsaWNrOiBvbmNsaWNrLFxuICAgICAgICAgICAgIHN0eWxlOiB7J21hcmdpbi1sZWZ0JzogbGVmdCArICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogcmlnaHQgKyAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgJ21pbi13aWR0aCc6IG1pbn19LFxuICAgICAgICAgICAgYXJncyk7XG4gICAgICAgIGxldCBuYXZCdG4gPSAoaWQsIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pID0+IF9uYXZCdG4oXG4gICAgICAgICAgICBpZCArICcubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pO1xuICAgICAgICBsZXQgbmF2QnRuMSA9IChpZCwgb25jbGljaywgYXJncywgdGl0bGUpID0+IF9uYXZCdG4oXG4gICAgICAgICAgICBgJHtpZH0uYnRuLWRlZmF1bHRbdGl0bGU9JHt0aXRsZX1dYCwgMiwgMCwgb25jbGljaywgYXJncyk7XG4gICAgICAgIGxldCBnbHlwaCA9IChpY29uLCB1bnN0eWxlZCkgPT4gbShcbiAgICAgICAgICAgIGBzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tJHtpY29ufWAgKyAodW5zdHlsZWQgPyAnJyA6ICdbc3R5bGU9Y29sb3I6ICM4MTgxODE7IGZvbnQtc2l6ZTogMWVtOyBwb2ludGVyLWV2ZW50czogbm9uZV0nKSk7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IChpZCwgbGlzdCkgPT4gbShcbiAgICAgICAgICAgIGB1bCMke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBzdHlsZToge2Rpc3BsYXk6ICdub25lJywgJ2JhY2tncm91bmQtY29sb3InOiBhcHAudmFyQ29sb3J9LFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbnRlcmFjdCBpcyBzZWxlY3RlZCwgc2hvdyB2YXJpYWJsZSBsaXN0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnRleHQoKSA9PT0gJ2ludGVyYWN0KGQsZSknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHR2YXIuY29uY2F0KCcqJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsSW50ZXJhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0dmFyID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKHR2YXIsIHRmdW5jLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0Lm1hcCh4ID0+IG0oJ2xpJywgeCkpKTtcbiAgICAgICAgbGV0IHNwYWNlQnRuID0gKGlkLCBvbmNsaWNrLCB0aXRsZSwgaWNvbikgPT4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLmJ0bi1kZWZhdWx0YCwge29uY2xpY2ssIHRpdGxlfSwgZ2x5cGgoaWNvbiwgdHJ1ZSkpO1xuXG4gICAgICAgIGlmIChtb2RlICE9IHRoaXMubGFzdF9tb2RlKSB7XG4gICAgICAgICAgICBhcHAucmVzdGFydCAmJiBhcHAucmVzdGFydChudWxsLCBleHBsb3JlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdF9tb2RlID0gbW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgJ21haW4nLFxuICAgICAgICAgICAgbShcIm5hdiNuYXZiYXIubmF2YmFyLm5hdmJhci1kZWZhdWx0Lm5hdmJhci1maXhlZC10b3Bbcm9sZT1uYXZpZ2F0aW9uXVwiLFxuICAgICAgICAgICAgICB7c3R5bGU6IG1vZGUgPT09ICdleHBsb3JlJyAmJiAnYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAjZmZmIDAsIHJnYigyMjcsIDI0MiwgMjU0KSAxMDAlKSd9LFxuICAgICAgICAgICAgICBtKFwiYS5uYXZiYXItYnJhbmRcIixcbiAgICAgICAgICAgICAgICBtKFwiaW1nW3NyYz0vc3RhdGljL2ltYWdlcy9Ud29SYXZlbnMucG5nXVthbHQ9VHdvUmF2ZW5zXVt3aWR0aD0xMDBdW3N0eWxlPW1hcmdpbi1sZWZ0OiAxZW07IG1hcmdpbi10b3A6IC0wLjVlbV1cIixcbiAgICAgICAgICAgICAgICAgIHtvbm1vdXNlb3ZlcjogXyA9PiB0aGlzLmFib3V0ID0gdHJ1ZSwgb25tb3VzZW91dDogXyA9PiB0aGlzLmFib3V0ID0gZmFsc2V9KSksXG4gICAgICAgICAgICAgIG0oJyNuYXZiYXJOYXZbc3R5bGU9cGFkZGluZzogMC41ZW1dJyxcbiAgICAgICAgICAgICAgICBtKCcjZGF0YUZpZWxkLmZpZWxkW3N0eWxlPW1hcmdpbi10b3A6IDAuNWVtOyB0ZXh0LWFsaWduOiBjZW50ZXJdJyxcbiAgICAgICAgICAgICAgICAgIG0oJ2g0I2RhdGFOYW1lW3N0eWxlPWRpc3BsYXk6IGlubGluZV0nLFxuICAgICAgICAgICAgICAgICAgICB7b25jbGljazogXyA9PiB0aGlzLmNpdGUgPSB0aGlzLmNpdGVIaWRkZW4gPSAhdGhpcy5jaXRlSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogXyA9PiB0aGlzLmNpdGVIaWRkZW4gfHwgKHRoaXMuY2l0ZSA9IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuY2l0ZSA9IHRydWV9LFxuICAgICAgICAgICAgICAgICAgICBcIkRhdGFzZXQgTmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgIG0oJyNjaXRlLnBhbmVsLnBhbmVsLWRlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICB7c3R5bGU6IGBkaXNwbGF5OiAke3RoaXMuY2l0ZSA/ICdibG9jaycgOiAnbm9uZSd9OyBwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1MCU7IHdpZHRoOiAzODBweDsgdGV4dC1hbGlnbjogbGVmdDsgei1pbmRleDogNTBgfSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIpKSxcbiAgICAgICAgICAgICAgICAgIG0oJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICBtKCcuZHJvcGRvd25bc3R5bGU9ZmxvYXQ6IHJpZ2h0OyBwYWRkaW5nLXJpZ2h0OiAxZW1dJyxcbiAgICAgICAgICAgICAgICAgICAgICBtKCcjZHJvcC5idXR0b24uYnRuW3R5cGU9YnV0dG9uXVtkYXRhLXRvZ2dsZT1kcm9wZG93bl1bYXJpYS1oYXNwb3B1cD10cnVlXVthcmlhLWV4cGFuZGVkPWZhbHNlXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdXNlcm5hbWUsIGdseXBoKCdoZWFydC1lbXB0eScpXSksXG4gICAgICAgICAgICAgICAgICAgICAgbSgndWwuZHJvcGRvd24tbWVudVtyb2xlPW1lbnVdW2FyaWEtbGFiZWxsZWRieT1kcm9wXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKCdsaVtzdHlsZT1wYWRkaW5nOiAwLjVlbV0nLCAnc29tZXRoaW5nIGhlcmUgMScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbSgnbGlbc3R5bGU9cGFkZGluZzogMC41ZW1dJywgJ3NvbWV0aGluZyBoZXJlIDInKSkpLFxuICAgICAgICAgICAgICAgICAgICAvKm0oJ2g1I3VzZXJOYW1lW3N0eWxlPWZsb2F0OiByaWdodDsgcGFkZGluZy1yaWdodDogMC41ZW1dJyxcbiAgICAgICAgICAgICAgICAgICAgICB7b25tb3VzZW92ZXI6IF8gPT4gdGhpcy51c2VydGFza3MgPSB0cnVlLCBvbm1vdXNlb3V0OiBfID0+IHRoaXMudXNlcnRhc2tzID0gZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgIFt1c2VybmFtZSwgZ2x5cGgoJ2hlYXJ0LWVtcHR5JyldLCAgLy8gY29uc3QgdXNlcm5hbWUgZGVmaW5lZCBpbiB0ZW1wbGF0ZXMvaW5kZXguaHRtbFxuICAgICAgICAgICAgICAgICAgICAgIG0oYCN1c2VydGFza3MucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMudXNlcnRhc2tzID8gJ2Jsb2NrJyA6ICdub25lJ307IHBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTBdYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oJy5wYW5lbC1ib2R5W3N0eWxlPXRleHQtYWxpZ246IGxlZnQ7IHBhZGRpbmc6IDFlbV0nLCdsb2dvdXQnKSkpLCovXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bignYnRuRXN0aW1hdGUuYnRuLXN1Y2Nlc3MnLCAyLCAxLCBleHBsb3JlID8gZXhwLmV4cGxvcmUgOiBhcHAuZXN0aW1hdGUsIG0oXCJzcGFuLmxhZGRhLWxhYmVsXCIsIGV4cGxvcmUgPyAnRXhwbG9yZScgOiAnU29sdmUgVGhpcyBQcm9ibGVtJyksICcxNTBweCcpLFxuICAgICAgICAgICAgICAgICAgICBuYXZCdG4oJ2J0blRBMi5idG4tZGVmYXVsdCcsIC41LCAxLCBfID0+IGFwcC5oZWxwbWF0ZXJpYWxzKCdtYW51YWwnKSwgWydIZWxwIE1hbnVhbCAnLCBnbHlwaCgnYm9vaycpXSksXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bignYnRuVEEyLmJ0bi1kZWZhdWx0JywgMiwgLjUsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ3ZpZGVvJyksIFsnSGVscCBWaWRlbyAnLCBnbHlwaCgnZXhwYW5kJyldKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuMShcImJ0blJlc2V0XCIsIGFwcC5yZXNldCwgZ2x5cGgoJ3JlcGVhdCcpLCAnUmVzZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuMSgnYnRuRW5kU2Vzc2lvbicsIGFwcC5lbmRzZXNzaW9uLCBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLCAnTWFyayBQcm9ibGVtIEZpbmlzaGVkJyksICdNYXJrIFByb2JsZW0gRmluaXNoZWQnKSksXG4gICAgICAgICAgICAgICAgICBtKCcjdElucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogJ25vbmUnfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7IC8vIGlmIHZhcmlhYmxlIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHsgLy8gaWYgZnVuY3Rpb24gbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSAkKCcjdElucHV0Jykub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50b3AgKz0gJCgnI3RJbnB1dCcpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBrZXl1cDogZXZ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSBieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0MSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09IDEzKSB7IC8vIGtleXVwIG9uIEVudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRyYW5zUGFyc2UoJCgnI3RJbnB1dCcpLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSh0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbSgnI3RyYW5zZm9ybWF0aW9ucy50cmFuc2Zvcm1Ub29sJywge1xuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBgQ29uc3RydWN0IHRyYW5zZm9ybWF0aW9ucyBvZiBleGlzdGluZyB2YXJpYWJsZXMgdXNpbmcgdmFsaWQgUiBzeW50YXguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSB2YXJpYWJsZSBuYW1lZCBkLCB5b3UgY2FuIGVudGVyIFwibG9nKGQpXCIgb3IgXCJkXjJcIi5gfSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24oJ3RyYW5zU2VsJywgWydhJywgJ2InXSksXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uKCd0cmFuc0xpc3QnLCBhcHAudHJhbnNmb3JtTGlzdCkpKSksXG4gICAgICAgICAgICAgIG0oYCNhYm91dC5wYW5lbC5wYW5lbC1kZWZhdWx0W3N0eWxlPWRpc3BsYXk6ICR7dGhpcy5hYm91dCA/ICdibG9jaycgOiAnbm9uZSd9OyBsZWZ0OiAxNDBweDsgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogNTAwcHg7IHotaW5kZXg6IDUwXWAsXG4gICAgICAgICAgICAgICAgbSgnLnBhbmVsLWJvZHknLFxuICAgICAgICAgICAgICAgICAgJ1R3b1JhdmVucyB2MC4xIFwiRGFsbGFzXCIgLS0gVGhlIE5vcnNlIGdvZCBPZGluIGhhZCB0d28gdGFsa2luZyByYXZlbnMgYXMgYWR2aXNvcnMsIHdobyB3b3VsZCBmbHkgb3V0IGludG8gdGhlIHdvcmxkIGFuZCByZXBvcnQgYmFjayBhbGwgdGhleSBvYnNlcnZlZC4gSW4gdGhlIE5vcnNlLCB0aGVpciBuYW1lcyB3ZXJlIFwiVGhvdWdodFwiIGFuZCBcIk1lbW9yeVwiLiBJbiBvdXIgY29taW5nIHJlbGVhc2UsIG91ciB0aG91Z2h0LXJhdmVuIGF1dG9tYXRpY2FsbHkgYWR2aXNlcyBvbiBzdGF0aXN0aWNhbCBtb2RlbCBzZWxlY3Rpb24sIHdoaWxlIG91ciBtZW1vcnktcmF2ZW4gYWNjdW11bGF0ZXMgcHJldmlvdXMgc3RhdGlzdGljYWwgbW9kZWxzIGZyb20gRGF0YXZlcnNlLCB0byBwcm92aWRlIGN1bW11bGF0aXZlIGd1aWRhbmNlIGFuZCBtZXRhLWFuYWx5c2lzLicpKSksXG4gICAgICAgICAgICBtKGAjbWFpbi5sZWZ0LmNhcm91c2VsLnNsaWRlLnN2Zy1sZWZ0cGFuZWwuc3ZnLXJpZ2h0cGFuZWxbc3R5bGU9b3ZlcmZsb3c6IGhpZGRlbl1gLFxuICAgICAgICAgICAgICBtKFwiI2lubmVyY2Fyb3VzZWwuY2Fyb3VzZWwtaW5uZXJcIixcbiAgICAgICAgICAgICAgICBtKCcjbTAuaXRlbS5hY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgbSgnc3ZnI3doaXRlc3BhY2UnKSkpLFxuICAgICAgICAgICAgICBtKFwiI3NwYWNldG9vbHMuc3BhY2VUb29sW3N0eWxlPXotaW5kZXg6IDE2XVwiLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5Mb2NrLmFjdGl2ZScsIGFwcC5sb2NrRGVzY3JpcHRpb24sICdMb2NrIHNlbGVjdGlvbiBvZiBwcm9ibGVtIGRlc2NyaXB0aW9uJywgJ3BlbmNpbCcpLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5Kb2luJywgXyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwbG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzX3VuaXF1ZSA9IChuLCBuMSkgPT4gbGlua3MubWFwKGwgPT4gbC50YXJnZXQgPT09IG4xICYmIGwuc291cmNlID09PSBuKS5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gYXBwLm5vZGVzLm1hcChuID0+IGFwcC5ub2Rlcy5maWx0ZXIobjEgPT4gbiAhPT0gbjEgJiYgaXNfdW5pcXVlKG4sIG4xKSkubWFwKG4xID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkdnMgPSBhcHAubm9kZXMuZmlsdGVyKG4gPT4gYXBwLnpwYXJhbXMuemR2LmluY2x1ZGVzKG4ubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl2cyA9IGFwcC5ub2Rlcy5maWx0ZXIobiA9PiAhZHZzLmluY2x1ZGVzKG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gZHZzLm1hcChkdiA9PiBpdnMubWFwKGl2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGR2LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcHAucmVzdGFydChbXS5jb25jYXQoLi4ubGlua3MpKTtcbiAgICAgICAgICAgICAgICB9LCAnTWFrZSBhbGwgcG9zc2libGUgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdsaW5rJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkRpc2Nvbm5lY3QnLCBfID0+IGFwcC5yZXN0YXJ0KFtdKSwgJ0RlbGV0ZSBhbGwgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdyZW1vdmUtY2lyY2xlJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkZvcmNlJywgYXBwLmZvcmNlU3dpdGNoLCAnUGluIHRoZSB2YXJpYWJsZSBwZWJibGVzIHRvIHRoZSBwYWdlJywgJ3B1c2hwaW4nKSxcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuRXJhc2VyJywgYXBwLmVyYXNlLCAnV2lwZSBhbGwgdmFyaWFibGVzIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlJywgJ21hZ25ldCcpKSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCxcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiTGVnZW5kXCIsXG4gICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgIFsndGltZUJ1dHRvbicsICd6dGltZScsICdUaW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2NzQnV0dG9uJywgJ3pjcm9zcycsICdDcm9zcyBTZWMnXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnZHZCdXR0b24nLCAnemR2JywgJ0RlcCBWYXInXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnbm9tQnV0dG9uJywgJ3pub20nLCAnTm9tIFZhciddLFxuICAgICAgICAgICAgICAgICAgICAgWydncjFCdXR0b24nLCAnemdyb3VwMScsICdHcm91cCAxJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2dyMkJ1dHRvbicsICd6Z3JvdXAyJywgJ0dyb3VwIDInXV19KSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCwge3RpdGxlOiBcIkhpc3RvcnlcIn0pLFxuICAgICAgICAgICAgICB0aWNrZXIobW9kZSksXG4gICAgICAgICAgICAgIGxlZnRwYW5lbChtb2RlKSxcbiAgICAgICAgICAgICAgcmlnaHRwYW5lbChtb2RlKSkpO1xuICAgIH1cbn1cblxubS5yb3V0ZShkb2N1bWVudC5ib2R5LCAnL21vZGVsJywge1xuICAgICcvbW9kZWwnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHkpfSxcbiAgICAnL2V4cGxvcmUnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHksIHttb2RlOiAnZXhwbG9yZSd9KX0sXG4gICAgJy9yZXN1bHRzJzoge3JlbmRlcjogKCkgPT4gbShCb2R5LCB7bW9kZTogJ3Jlc3VsdHMnfSl9LFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXNzZXRzL2FwcC9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFDQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBTUE7QUFHQTtBQUNBO0FBMkRBO0FBQ0E7QUFFQTtBQUNBO0FBd0JBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQU1BOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBc0JBO0FBQUE7QUF2QkE7QUF3QkE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFZQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXNDQTtBQWFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFXQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/* no static exports found */
/* all exports used */
/*!**********************************************!*\
  !*** ./~/hopscotch/dist/js/hopscotch.min.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**! hopscotch - v0.3.1\n*\n* Copyright 2017 LinkedIn Corp. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n!function(a,b){ true?module.exports=b():\"function\"==typeof define&&define.amd?define(b):a.hopscotch=b()}(this,function(){\"use strict\";var a,b,c,d,e,f,g,h,i,j,k,l,m,n=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&\"function\"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?\"symbol\":typeof a},o=\"bubble_default\",p=window.Sizzle||null,q=\"undefined\",r=!1,s=(\"undefined\"==typeof jQuery?\"undefined\":n(jQuery))!==q,t=!1,u=!1,v=/^[a-zA-Z]+[a-zA-Z0-9_-]*$/,w={left:\"right\",right:\"left\"};try{n(window.sessionStorage)!==q&&(t=!0,sessionStorage.setItem(\"hopscotch.test.storage\",\"ok\"),sessionStorage.removeItem(\"hopscotch.test.storage\"),u=!0)}catch(x){}l={smoothScroll:!0,scrollDuration:1e3,scrollTopMargin:200,showCloseButton:!0,showPrevButton:!1,showNextButton:!0,bubbleWidth:280,bubblePadding:15,arrowWidth:20,skipIfNoElement:!0,isRtl:!1,cookieName:\"hopscotch.tour.state\"},Array.isArray||(Array.isArray=function(a){return\"[object Array]\"===Object.prototype.toString.call(a)}),k=function(){r&&m.startTour()},h={addClass:function(a,b){var c,d,e,f;if(a.className){for(d=b.split(/\\s+/),c=\" \"+a.className+\" \",e=0,f=d.length;f>e;++e)c.indexOf(\" \"+d[e]+\" \")<0&&(c+=d[e]+\" \");a.className=c.replace(/^\\s+|\\s+$/g,\"\")}else a.className=b},removeClass:function(a,b){var c,d,e,f;for(d=b.split(/\\s+/),c=\" \"+a.className+\" \",e=0,f=d.length;f>e;++e)c=c.replace(\" \"+d[e]+\" \",\" \");a.className=c.replace(/^\\s+|\\s+$/g,\"\")},hasClass:function(a,b){var c;return a.className?(c=\" \"+a.className+\" \",-1!==c.indexOf(\" \"+b+\" \")):!1},getPixelValue:function(a){var b=\"undefined\"==typeof a?\"undefined\":n(a);return\"number\"===b?a:\"string\"===b?parseInt(a,10):0},valOrDefault:function(a,b){return(\"undefined\"==typeof a?\"undefined\":n(a))!==q?a:b},invokeCallbackArrayHelper:function(a){var b;return Array.isArray(a)&&(b=j[a[0]],\"function\"==typeof b)?b.apply(this,a.slice(1)):void 0},invokeCallbackArray:function(a){var b,c;if(Array.isArray(a)){if(\"string\"==typeof a[0])return h.invokeCallbackArrayHelper(a);for(b=0,c=a.length;c>b;++b)h.invokeCallback(a[b])}},invokeCallback:function(a){return\"function\"==typeof a?a():\"string\"==typeof a&&j[a]?j[a]():h.invokeCallbackArray(a)},invokeEventCallbacks:function(a,b){var c,d,e=i[a];if(b)return this.invokeCallback(b);for(c=0,d=e.length;d>c;++c)this.invokeCallback(e[c].cb)},getScrollTop:function(){var a;return a=n(window.pageYOffset)!==q?window.pageYOffset:document.documentElement.scrollTop},getScrollLeft:function(){var a;return a=n(window.pageXOffset)!==q?window.pageXOffset:document.documentElement.scrollLeft},getWindowHeight:function(){return window.innerHeight||document.documentElement.clientHeight},addEvtListener:function(a,b,c){return a?a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent(\"on\"+b,c):void 0},removeEvtListener:function(a,b,c){return a?a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent(\"on\"+b,c):void 0},documentIsReady:function(){return\"complete\"===document.readyState},evtPreventDefault:function(a){a.preventDefault?a.preventDefault():event&&(event.returnValue=!1)},extend:function(a,b){var c;for(c in b)b.hasOwnProperty(c)&&(a[c]=b[c])},getStepTargetHelper:function(a){var b=document.getElementById(a);if(b)return b;if(s)return b=jQuery(a),b.length?b[0]:null;if(p)return b=new p(a),b.length?b[0]:null;if(document.querySelector)try{return document.querySelector(a)}catch(c){}return/^#[a-zA-Z][\\w-_:.]*$/.test(a)?document.getElementById(a.substring(1)):null},getStepTarget:function(a){var b;if(!a||!a.target)return null;if(\"string\"==typeof a.target)return h.getStepTargetHelper(a.target);if(Array.isArray(a.target)){var c,d;for(c=0,d=a.target.length;d>c;c++)if(\"string\"==typeof a.target[c]&&(b=h.getStepTargetHelper(a.target[c])))return b;return null}return a.target},getI18NString:function(a){return e[a]||d[a]},setState:function(a,b,c){var d,e=\"\";if(t&&u)try{sessionStorage.setItem(a,b)}catch(f){u=!1,this.setState(a,b,c)}else t&&sessionStorage.removeItem(a),c&&(d=new Date,d.setTime(d.getTime()+24*c*60*60*1e3),e=\"; expires=\"+d.toGMTString()),document.cookie=a+\"=\"+b+e+\"; path=/\"},getState:function(a){var b,c,d,e=a+\"=\",f=document.cookie.split(\";\");if(t&&(d=sessionStorage.getItem(a)))return d;for(b=0;b<f.length;b++){for(c=f[b];\" \"===c.charAt(0);)c=c.substring(1,c.length);if(0===c.indexOf(e)){d=c.substring(e.length,c.length);break}}return d},clearState:function(a){t?sessionStorage.removeItem(a):this.setState(a,\"\",-1)},normalizePlacement:function(a){!a.placement&&a.orientation&&(a.placement=a.orientation)},flipPlacement:function(a){if(a.isRtl&&!a._isFlipped){var b,c,d=[\"orientation\",\"placement\"];a.xOffset&&(a.xOffset=-1*this.getPixelValue(a.xOffset));for(c in d)b=d[c],a.hasOwnProperty(b)&&w.hasOwnProperty(a[b])&&(a[b]=w[a[b]]);a._isFlipped=!0}}},h.addEvtListener(window,\"load\",k),i={next:[],prev:[],start:[],end:[],show:[],error:[],close:[]},j={},d={stepNums:null,nextBtn:\"Next\",prevBtn:\"Back\",doneBtn:\"Done\",skipBtn:\"Skip\",closeTooltip:\"Close\"},e={},b=function(a){this.init(a)},b.prototype={isShowing:!1,currStep:void 0,setPosition:function(a){var b,c,d,e,f,g,i,j=h.getStepTarget(a),k=this.element,l=this.arrowEl,m=a.isRtl?\"right\":\"left\";if(h.flipPlacement(a),h.normalizePlacement(a),c=k.offsetWidth,b=k.offsetHeight,h.removeClass(k,\"fade-in-down fade-in-up fade-in-left fade-in-right\"),d=j.getBoundingClientRect(),i=a.isRtl?d.right-c:d.left,\"top\"===a.placement)e=d.top-b-this.opt.arrowWidth,f=i;else if(\"bottom\"===a.placement)e=d.bottom+this.opt.arrowWidth,f=i;else if(\"left\"===a.placement)e=d.top,f=d.left-c-this.opt.arrowWidth;else{if(\"right\"!==a.placement)throw new Error(\"Bubble placement failed because step.placement is invalid or undefined!\");e=d.top,f=d.right+this.opt.arrowWidth}g=\"center\"!==a.arrowOffset?h.getPixelValue(a.arrowOffset):a.arrowOffset,g?\"top\"===a.placement||\"bottom\"===a.placement?(l.style.top=\"\",\"center\"===g?l.style[m]=Math.floor(c/2-l.offsetWidth/2)+\"px\":l.style[m]=g+\"px\"):(\"left\"===a.placement||\"right\"===a.placement)&&(l.style[m]=\"\",\"center\"===g?l.style.top=Math.floor(b/2-l.offsetHeight/2)+\"px\":l.style.top=g+\"px\"):(l.style.top=\"\",l.style[m]=\"\"),\"center\"===a.xOffset?f=d.left+j.offsetWidth/2-c/2:f+=h.getPixelValue(a.xOffset),\"center\"===a.yOffset?e=d.top+j.offsetHeight/2-b/2:e+=h.getPixelValue(a.yOffset),a.fixedElement||(e+=h.getScrollTop(),f+=h.getScrollLeft()),k.style.position=a.fixedElement?\"fixed\":\"absolute\",k.style.top=e+\"px\",k.style.left=f+\"px\"},render:function(a,b,c){var d,e,g,i,j,k,l,n,p,q,r=this.element;if(a?this.currStep=a:this.currStep&&(a=this.currStep),this.opt.isTourBubble?(i=m.getCurrTour(),i&&(e=i.customData,d=i.customRenderer,a.isRtl=a.hasOwnProperty(\"isRtl\")?a.isRtl:i.hasOwnProperty(\"isRtl\")?i.isRtl:this.opt.isRtl,g=i.unsafe,Array.isArray(i.steps)&&(j=i.steps.length,k=this._getStepI18nNum(this._getStepNum(j-1)),n=this._getStepNum(b)===this._getStepNum(j-1)))):(e=a.customData,d=a.customRenderer,g=a.unsafe,a.isRtl=a.hasOwnProperty(\"isRtl\")?a.isRtl:this.opt.isRtl),l=n?h.getI18NString(\"doneBtn\"):a.showSkip?h.getI18NString(\"skipBtn\"):h.getI18NString(\"nextBtn\"),h.flipPlacement(a),h.normalizePlacement(a),this.placement=a.placement,q={i18n:{prevBtn:h.getI18NString(\"prevBtn\"),nextBtn:l,closeTooltip:h.getI18NString(\"closeTooltip\"),stepNum:this._getStepI18nNum(this._getStepNum(b)),numSteps:k},buttons:{showPrev:h.valOrDefault(a.showPrevButton,this.opt.showPrevButton)&&this._getStepNum(b)>0,showNext:h.valOrDefault(a.showNextButton,this.opt.showNextButton),showCTA:h.valOrDefault(a.showCTAButton&&a.ctaLabel,!1),ctaLabel:a.ctaLabel,showClose:h.valOrDefault(this.opt.showCloseButton,!0)},step:{num:b,isLast:h.valOrDefault(n,!1),title:a.title||\"\",content:a.content||\"\",isRtl:a.isRtl,placement:a.placement,padding:h.valOrDefault(a.padding,this.opt.bubblePadding),width:h.getPixelValue(a.width)||this.opt.bubbleWidth,customData:a.customData||{}},tour:{isTour:this.opt.isTourBubble,numSteps:j,unsafe:h.valOrDefault(g,!1),customData:e||{}}},\"function\"==typeof d)r.innerHTML=d(q);else if(\"string\"==typeof d){if(!m.templates||\"function\"!=typeof m.templates[d])throw new Error('Bubble rendering failed - template \"'+d+'\" is not a function.');r.innerHTML=m.templates[d](q)}else if(f)r.innerHTML=f(q);else{if(!m.templates||\"function\"!=typeof m.templates[o])throw new Error('Bubble rendering failed - template \"'+o+'\" is not a function.');r.innerHTML=m.templates[o](q)}var s,t=r.children,u=t.length;for(p=0;u>p;p++)s=t[p],h.hasClass(s,\"hopscotch-arrow\")&&(this.arrowEl=s);return r.style.zIndex=\"number\"==typeof a.zindex?a.zindex:\"\",this._setArrow(a.placement),this.hide(!1),this.setPosition(a),c&&c(!a.fixedElement),this},_getStepNum:function(a){var b,c,d=0,e=m.getSkippedStepsIndexes(),f=e.length;for(c=0;f>c;c++)b=e[c],a>b&&d++;return a-d},_getStepI18nNum:function(a){var b=h.getI18NString(\"stepNums\");return b&&a<b.length?a=b[a]:a+=1,a},_setArrow:function(a){h.removeClass(this.arrowEl,\"down up right left\"),\"top\"===a?h.addClass(this.arrowEl,\"down\"):\"bottom\"===a?h.addClass(this.arrowEl,\"up\"):\"left\"===a?h.addClass(this.arrowEl,\"right\"):\"right\"===a&&h.addClass(this.arrowEl,\"left\")},_getArrowDirection:function(){return\"top\"===this.placement?\"down\":\"bottom\"===this.placement?\"up\":\"left\"===this.placement?\"right\":\"right\"===this.placement?\"left\":void 0},show:function(){var a=this,b=\"fade-in-\"+this._getArrowDirection(),c=1e3;return h.removeClass(this.element,\"hide\"),h.addClass(this.element,b),setTimeout(function(){h.removeClass(a.element,\"invisible\")},50),setTimeout(function(){h.removeClass(a.element,b)},c),this.isShowing=!0,this},hide:function(a){var b=this.element;return a=h.valOrDefault(a,!0),b.style.top=\"\",b.style.left=\"\",a?(h.addClass(b,\"hide\"),h.removeClass(b,\"invisible\")):(h.removeClass(b,\"hide\"),h.addClass(b,\"invisible\")),h.removeClass(b,\"animate fade-in-up fade-in-down fade-in-right fade-in-left\"),this.isShowing=!1,this},destroy:function(){var a=this.element;a&&a.parentNode.removeChild(a),h.removeEvtListener(a,\"click\",this.clickCb)},_handleBubbleClick:function(a){function b(c){return c===a.currentTarget?null:h.hasClass(c,\"hopscotch-cta\")?\"cta\":h.hasClass(c,\"hopscotch-next\")?\"next\":h.hasClass(c,\"hopscotch-prev\")?\"prev\":h.hasClass(c,\"hopscotch-close\")?\"close\":b(c.parentElement)}var c;a=a||window.event;var d=a.target||a.srcElement;if(c=b(d),\"cta\"===c)this.opt.isTourBubble||m.getCalloutManager().removeCallout(this.currStep.id),this.currStep.onCTA&&h.invokeCallback(this.currStep.onCTA);else if(\"next\"===c)m.nextStep(!0);else if(\"prev\"===c)m.prevStep(!0);else if(\"close\"===c){if(this.opt.isTourBubble){var e=m.getCurrStepNum(),f=m.getCurrTour(),g=e===f.steps.length-1;h.invokeEventCallbacks(\"close\"),m.endTour(!0,g)}else this.opt.onClose&&h.invokeCallback(this.opt.onClose),this.opt.id&&!this.opt.isTourBubble?m.getCalloutManager().removeCallout(this.opt.id):this.destroy();h.evtPreventDefault(a)}},init:function(a){var b,c,d,e,f=document.createElement(\"div\"),g=this,i=!1;this.element=f,e={showPrevButton:l.showPrevButton,showNextButton:l.showNextButton,bubbleWidth:l.bubbleWidth,bubblePadding:l.bubblePadding,arrowWidth:l.arrowWidth,isRtl:l.isRtl,showNumber:!0,isTourBubble:!0},a=(\"undefined\"==typeof a?\"undefined\":n(a))===q?{}:a,h.extend(e,a),this.opt=e,f.className=\"hopscotch-bubble animated\",e.isTourBubble?(d=m.getCurrTour(),d&&h.addClass(f,\"tour-\"+d.id)):h.addClass(f,\"hopscotch-callout no-number\"),b=function(){!i&&g.isShowing&&(i=!0,setTimeout(function(){g.setPosition(g.currStep),i=!1},100))},h.addEvtListener(window,\"resize\",b),this.clickCb=function(a){g._handleBubbleClick(a)},h.addEvtListener(f,\"click\",this.clickCb),this.hide(),h.documentIsReady()?document.body.appendChild(f):(document.addEventListener?(c=function(){document.removeEventListener(\"DOMContentLoaded\",c),window.removeEventListener(\"load\",c),document.body.appendChild(f)},document.addEventListener(\"DOMContentLoaded\",c,!1)):(c=function(){\"complete\"===document.readyState&&(document.detachEvent(\"onreadystatechange\",c),window.detachEvent(\"onload\",c),document.body.appendChild(f))},document.attachEvent(\"onreadystatechange\",c)),h.addEvtListener(window,\"load\",c))}},c=function(){var a={},c={};this.createCallout=function(d){var e;if(!d.id)throw new Error(\"Must specify a callout id.\");if(!v.test(d.id))throw new Error(\"Callout ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.\");if(a[d.id])throw new Error(\"Callout by that id already exists. Please choose a unique id.\");if(!h.getStepTarget(d))throw new Error(\"Must specify existing target element via 'target' option.\");return d.showNextButton=d.showPrevButton=!1,d.isTourBubble=!1,e=new b(d),a[d.id]=e,c[d.id]=d,e.render(d,null,function(){e.show(),d.onShow&&h.invokeCallback(d.onShow)}),e},this.getCallout=function(b){return a[b]},this.removeAllCallouts=function(){var b;for(b in a)a.hasOwnProperty(b)&&this.removeCallout(b)},this.removeCallout=function(b){var d=a[b];a[b]=null,c[b]=null,d&&d.destroy()},this.refreshCalloutPositions=function(){var b,d,e;for(b in a)a.hasOwnProperty(b)&&c.hasOwnProperty(b)&&(d=a[b],e=c[b],d&&e&&d.setPosition(e))}},a=function(a){var d,k,p,t,u,w,x,y,z=this,A={},B=[],C=function(a){return d&&d.element&&d.element.parentNode||(d=new b(p)),a&&h.extend(d.opt,{bubblePadding:E(\"bubblePadding\"),bubbleWidth:E(\"bubbleWidth\"),showNextButton:E(\"showNextButton\"),showPrevButton:E(\"showPrevButton\"),showCloseButton:E(\"showCloseButton\"),arrowWidth:E(\"arrowWidth\"),isRtl:E(\"isRtl\")}),d},D=function(){d&&(d.destroy(),d=null)},E=function(a){return\"undefined\"==typeof p?l[a]:h.valOrDefault(p[a],l[a])},F=function(){var a;return a=!t||0>u||u>=t.steps.length?null:t.steps[u]},G=function(){z.nextStep()},H=function(a){var b,c,d,e,f,g,i=C(),j=i.element,k=h.getPixelValue(j.style.top),l=k+h.getPixelValue(j.offsetHeight),m=h.getStepTarget(F()),o=m.getBoundingClientRect(),p=o.top+h.getScrollTop(),r=o.bottom+h.getScrollTop(),t=p>k?k:p,u=l>r?l:r,v=h.getScrollTop(),w=v+h.getWindowHeight(),x=t-E(\"scrollTopMargin\");t>=v&&(t<=v+E(\"scrollTopMargin\")||w>=u)?a&&a():E(\"smoothScroll\")?(\"undefined\"==typeof YAHOO?\"undefined\":n(YAHOO))!==q&&n(YAHOO.env)!==q&&n(YAHOO.env.ua)!==q&&n(YAHOO.util)!==q&&n(YAHOO.util.Scroll)!==q?(b=YAHOO.env.ua.webkit?document.body:document.documentElement,d=YAHOO.util.Easing?YAHOO.util.Easing.easeOut:void 0,c=new YAHOO.util.Scroll(b,{scroll:{to:[0,x]}},E(\"scrollDuration\")/1e3,d),c.onComplete.subscribe(a),c.animate()):s?jQuery(\"body, html\").animate({scrollTop:x},E(\"scrollDuration\"),a):(0>x&&(x=0),e=v>t?-1:1,f=Math.abs(v-x)/(E(\"scrollDuration\")/10),(g=function(){var b=h.getScrollTop(),c=b+e*f;return e>0&&c>=x||0>e&&x>=c?(c=x,a&&a(),void window.scrollTo(0,c)):(window.scrollTo(0,c),h.getScrollTop()===b?void(a&&a()):void setTimeout(g,10))})()):(window.scrollTo(0,x),a&&a())},I=function P(a,b){var c,d,e;u+a>=0&&u+a<t.steps.length?(u+=a,d=F(),e=function(){c=h.getStepTarget(d),c?(A[u]&&delete A[u],b(u)):(A[u]=!0,h.invokeEventCallbacks(\"error\"),P(a,b))},d.delay?setTimeout(e,d.delay):e()):b(-1)},J=function(a,b){var c,d,e,f,g=C(),i=this;if(g.hide(),a=h.valOrDefault(a,!0),c=F(),c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),\"click\",G),d=c,e=b>0?d.multipage:u>0&&t.steps[u-1].multipage,f=function(c){var f;if(-1===c)return this.endTour(!0);if(a&&(f=b>0?h.invokeEventCallbacks(\"next\",d.onNext):h.invokeEventCallbacks(\"prev\",d.onPrev)),c===u){if(e)return void N();f=h.valOrDefault(f,!0),f?this.showStep(c):this.endTour(!1)}},!e&&E(\"skipIfNoElement\"))I(b,function(a){f.call(i,a)});else if(u+b>=0&&u+b<t.steps.length){if(u+=b,c=F(),!h.getStepTarget(c)&&!e)return h.invokeEventCallbacks(\"error\"),this.endTour(!0,!1);f.call(this,u)}else if(u+b===t.steps.length)return this.endTour();return this},K=function(a){var b,c,d,e={};for(b in a)a.hasOwnProperty(b)&&\"id\"!==b&&\"steps\"!==b&&(e[b]=a[b]);return y.call(this,e,!0),c=h.getState(E(\"cookieName\")),c&&(d=c.split(\":\"),w=d[0],x=d[1],d.length>2&&(B=d[2].split(\",\")),x=parseInt(x,10)),this},L=function(a,b,c){var d,e;if(u=a||0,A=b||{},d=F(),e=h.getStepTarget(d))return void c(u);if(!e){if(h.invokeEventCallbacks(\"error\"),A[u]=!0,E(\"skipIfNoElement\"))return void I(1,c);u=-1,c(u)}},M=function(a){function b(){d.show(),h.invokeEventCallbacks(\"show\",c.onShow)}var c=t.steps[a],d=C(),e=h.getStepTarget(c);u!==a&&F().nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(F()),\"click\",G),u=a,d.hide(!1),d.render(c,a,function(a){a?H(b):b(),c.nextOnTargetClick&&h.addEvtListener(e,\"click\",G)}),N()},N=function(){var a=t.id+\":\"+u,b=m.getSkippedStepsIndexes();b&&b.length>0&&(a+=\":\"+b.join(\",\")),h.setState(E(\"cookieName\"),a,1)},O=function(a){a&&this.configure(a)};this.getCalloutManager=function(){return(\"undefined\"==typeof k?\"undefined\":n(k))===q&&(k=new c),k},this.startTour=function(a,b){var c,d,e={},f=this;if(!t){if(!a)throw new Error(\"Tour data is required for startTour.\");if(!a.id||!v.test(a.id))throw new Error(\"Tour ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.\");t=a,K.call(this,a)}if((\"undefined\"==typeof b?\"undefined\":n(b))!==q){if(b>=t.steps.length)throw new Error(\"Specified step number out of bounds.\");d=b}if(!h.documentIsReady())return r=!0,this;if(\"undefined\"==typeof d&&t.id===w&&(\"undefined\"==typeof x?\"undefined\":n(x))!==q){if(d=x,B.length>0)for(var g=0,i=B.length;i>g;g++)e[B[g]]=!0}else d||(d=0);return L(d,e,function(a){var b=-1!==a&&h.getStepTarget(t.steps[a]);return b?(h.invokeEventCallbacks(\"start\"),c=C(),c.hide(!1),f.isActive=!0,void(h.getStepTarget(F())?f.showStep(a):(h.invokeEventCallbacks(\"error\"),E(\"skipIfNoElement\")&&f.nextStep(!1)))):void f.endTour(!1,!1)}),this},this.showStep=function(a){var b=t.steps[a],c=u;return h.getStepTarget(b)?(b.delay?setTimeout(function(){M(a)},b.delay):M(a),this):(u=a,h.invokeEventCallbacks(\"error\"),void(u=c))},this.prevStep=function(a){return J.call(this,a,-1),this},this.nextStep=function(a){return J.call(this,a,1),this},this.endTour=function(a,b){var c,d=C();return a=h.valOrDefault(a,!0),b=h.valOrDefault(b,!0),t&&(c=F(),c&&c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),\"click\",G)),u=0,x=void 0,d.hide(),a&&h.clearState(E(\"cookieName\")),this.isActive&&(this.isActive=!1,t&&b&&h.invokeEventCallbacks(\"end\")),this.removeCallbacks(null,!0),this.resetDefaultOptions(),D(),t=null,this},this.getCurrTour=function(){return t},this.getCurrTarget=function(){return h.getStepTarget(F())},this.getCurrStepNum=function(){return u},this.getSkippedStepsIndexes=function(){var a,b=[];for(a in A)b.push(a);return b},this.refreshBubblePosition=function(){var a=F();return a&&C().setPosition(a),this.getCalloutManager().refreshCalloutPositions(),this},this.listen=function(a,b,c){return a&&i[a].push({cb:b,fromTour:c}),this},this.unlisten=function(a,b){var c,d,e=i[a];for(c=0,d=e.length;d>c;++c)e[c].cb===b&&e.splice(c,1);return this},this.removeCallbacks=function(a,b){var c,d,e,f;for(f in i)if(!a||a===f)if(b)for(c=i[f],d=0,e=c.length;e>d;++d)c[d].fromTour&&(c.splice(d--,1),--e);else i[f]=[];return this},this.registerHelper=function(a,b){\"string\"==typeof a&&\"function\"==typeof b&&(j[a]=b)},this.unregisterHelper=function(a){j[a]=null},this.invokeHelper=function(a){var b,c,d=[];for(b=1,c=arguments.length;c>b;++b)d.push(arguments[b]);j[a]&&j[a].call(null,d)},this.setCookieName=function(a){return p.cookieName=a,this},this.resetDefaultOptions=function(){return p={},this},this.resetDefaultI18N=function(){return e={},this},this.getState=function(){return h.getState(E(\"cookieName\"))},y=function(a,b){var c,d,f,g,i=[\"next\",\"prev\",\"start\",\"end\",\"show\",\"error\",\"close\"];for(p||this.resetDefaultOptions(),h.extend(p,a),a&&h.extend(e,a.i18n),f=0,g=i.length;g>f;++f)d=\"on\"+i[f].charAt(0).toUpperCase()+i[f].substring(1),a[d]&&this.listen(i[f],a[d],b);return c=C(!0),this},this.configure=function(a){return y.call(this,a,!1)},this.setRenderer=function(a){var b=\"undefined\"==typeof a?\"undefined\":n(a);return\"string\"===b?(o=a,f=void 0):\"function\"===b&&(f=a),this},this.setEscaper=function(a){return\"function\"==typeof a&&(g=a),this},O.call(this,a)},m=new a,function(){var a={};a.escape=function(a){return g?g(a):null==a?\"\":(\"\"+a).replace(new RegExp(\"[&<>\\\"']\",\"g\"),function(a){return\"&\"==a?\"&amp;\":\"<\"==a?\"&lt;\":\">\"==a?\"&gt;\":'\"'==a?\"&quot;\":\"'\"==a?\"&#x27;\":void 0})},this.templates=this.templates||{},this.templates.bubble_default=function(b){function c(b,c){return c?a.escape(b):b}var d,e=\"\";a.escape,Array.prototype.join;e+=\"\\n\";var f=b.i18n,g=b.buttons,h=b.step,i=b.tour;return e+='\\n<div class=\"hopscotch-bubble-container\" style=\"width: '+(null==(d=h.width)?\"\":d)+\"px; padding: \"+(null==(d=h.padding)?\"\":d)+'px;\">\\n  ',i.isTour&&(e+='<span class=\"hopscotch-bubble-number\">'+(null==(d=f.stepNum)?\"\":d)+\"</span>\"),e+='\\n  <div class=\"hopscotch-bubble-content\">\\n    ',\"\"!==h.title&&(e+='<h3 class=\"hopscotch-title\">'+(null==(d=c(h.title,i.unsafe))?\"\":d)+\"</h3>\"),e+=\"\\n    \",\"\"!==h.content&&(e+='<div class=\"hopscotch-content\">'+(null==(d=c(h.content,i.unsafe))?\"\":d)+\"</div>\"),e+='\\n  </div>\\n  <div class=\"hopscotch-actions\">\\n    ',g.showPrev&&(e+='<button class=\"hopscotch-nav-button prev hopscotch-prev\">'+(null==(d=f.prevBtn)?\"\":d)+\"</button>\"),e+=\"\\n    \",g.showCTA&&(e+='<button class=\"hopscotch-nav-button next hopscotch-cta\">'+(null==(d=g.ctaLabel)?\"\":d)+\"</button>\"),e+=\"\\n    \",g.showNext&&(e+='<button class=\"hopscotch-nav-button next hopscotch-next\">'+(null==(d=f.nextBtn)?\"\":d)+\"</button>\"),e+=\"\\n  </div>\\n  \",g.showClose&&(e+='<button class=\"hopscotch-bubble-close hopscotch-close\">'+(null==(d=f.closeTooltip)?\"\":d)+\"</button>\"),e+='\\n</div>\\n<div class=\"hopscotch-bubble-arrow-container hopscotch-arrow\">\\n  <div class=\"hopscotch-bubble-arrow-border\"></div>\\n  <div class=\"hopscotch-bubble-arrow\"></div>\\n</div>\\n'}}.call(m);var y=m;return y});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanM/Mzc0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohIGhvcHNjb3RjaCAtIHYwLjMuMVxuKlxuKiBDb3B5cmlnaHQgMjAxNyBMaW5rZWRJbiBDb3JwLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4hZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1iKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShiKTphLmhvcHNjb3RjaD1iKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGF9OmZ1bmN0aW9uKGEpe3JldHVybiBhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmEuY29uc3RydWN0b3I9PT1TeW1ib2wmJmEhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGF9LG89XCJidWJibGVfZGVmYXVsdFwiLHA9d2luZG93LlNpenpsZXx8bnVsbCxxPVwidW5kZWZpbmVkXCIscj0hMSxzPShcInVuZGVmaW5lZFwiPT10eXBlb2YgalF1ZXJ5P1widW5kZWZpbmVkXCI6bihqUXVlcnkpKSE9PXEsdD0hMSx1PSExLHY9L15bYS16QS1aXStbYS16QS1aMC05Xy1dKiQvLHc9e2xlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwifTt0cnl7bih3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIT09cSYmKHQ9ITAsc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcImhvcHNjb3RjaC50ZXN0LnN0b3JhZ2VcIixcIm9rXCIpLHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oXCJob3BzY290Y2gudGVzdC5zdG9yYWdlXCIpLHU9ITApfWNhdGNoKHgpe31sPXtzbW9vdGhTY3JvbGw6ITAsc2Nyb2xsRHVyYXRpb246MWUzLHNjcm9sbFRvcE1hcmdpbjoyMDAsc2hvd0Nsb3NlQnV0dG9uOiEwLHNob3dQcmV2QnV0dG9uOiExLHNob3dOZXh0QnV0dG9uOiEwLGJ1YmJsZVdpZHRoOjI4MCxidWJibGVQYWRkaW5nOjE1LGFycm93V2lkdGg6MjAsc2tpcElmTm9FbGVtZW50OiEwLGlzUnRsOiExLGNvb2tpZU5hbWU6XCJob3BzY290Y2gudG91ci5zdGF0ZVwifSxBcnJheS5pc0FycmF5fHwoQXJyYXkuaXNBcnJheT1mdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9KSxrPWZ1bmN0aW9uKCl7ciYmbS5zdGFydFRvdXIoKX0saD17YWRkQ2xhc3M6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZjtpZihhLmNsYXNzTmFtZSl7Zm9yKGQ9Yi5zcGxpdCgvXFxzKy8pLGM9XCIgXCIrYS5jbGFzc05hbWUrXCIgXCIsZT0wLGY9ZC5sZW5ndGg7Zj5lOysrZSljLmluZGV4T2YoXCIgXCIrZFtlXStcIiBcIik8MCYmKGMrPWRbZV0rXCIgXCIpO2EuY2xhc3NOYW1lPWMucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX1lbHNlIGEuY2xhc3NOYW1lPWJ9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7Zm9yKGQ9Yi5zcGxpdCgvXFxzKy8pLGM9XCIgXCIrYS5jbGFzc05hbWUrXCIgXCIsZT0wLGY9ZC5sZW5ndGg7Zj5lOysrZSljPWMucmVwbGFjZShcIiBcIitkW2VdK1wiIFwiLFwiIFwiKTthLmNsYXNzTmFtZT1jLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9LGhhc0NsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM7cmV0dXJuIGEuY2xhc3NOYW1lPyhjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLC0xIT09Yy5pbmRleE9mKFwiIFwiK2IrXCIgXCIpKTohMX0sZ2V0UGl4ZWxWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYT9cInVuZGVmaW5lZFwiOm4oYSk7cmV0dXJuXCJudW1iZXJcIj09PWI/YTpcInN0cmluZ1wiPT09Yj9wYXJzZUludChhLDEwKTowfSx2YWxPckRlZmF1bHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpKSE9PXE/YTpifSxpbnZva2VDYWxsYmFja0FycmF5SGVscGVyOmZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiBBcnJheS5pc0FycmF5KGEpJiYoYj1qW2FbMF1dLFwiZnVuY3Rpb25cIj09dHlwZW9mIGIpP2IuYXBwbHkodGhpcyxhLnNsaWNlKDEpKTp2b2lkIDB9LGludm9rZUNhbGxiYWNrQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGIsYztpZihBcnJheS5pc0FycmF5KGEpKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYVswXSlyZXR1cm4gaC5pbnZva2VDYWxsYmFja0FycmF5SGVscGVyKGEpO2ZvcihiPTAsYz1hLmxlbmd0aDtjPmI7KytiKWguaW52b2tlQ2FsbGJhY2soYVtiXSl9fSxpbnZva2VDYWxsYmFjazpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2EoKTpcInN0cmluZ1wiPT10eXBlb2YgYSYmalthXT9qW2FdKCk6aC5pbnZva2VDYWxsYmFja0FycmF5KGEpfSxpbnZva2VFdmVudENhbGxiYWNrczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT1pW2FdO2lmKGIpcmV0dXJuIHRoaXMuaW52b2tlQ2FsbGJhY2soYik7Zm9yKGM9MCxkPWUubGVuZ3RoO2Q+YzsrK2MpdGhpcy5pbnZva2VDYWxsYmFjayhlW2NdLmNiKX0sZ2V0U2Nyb2xsVG9wOmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGE9bih3aW5kb3cucGFnZVlPZmZzZXQpIT09cT93aW5kb3cucGFnZVlPZmZzZXQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcH0sZ2V0U2Nyb2xsTGVmdDpmdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPW4od2luZG93LnBhZ2VYT2Zmc2V0KSE9PXE/d2luZG93LnBhZ2VYT2Zmc2V0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fSxnZXRXaW5kb3dIZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fSxhZGRFdnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE/YS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITEpOmEuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6dm9pZCAwfSxyZW1vdmVFdnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE/YS5yZW1vdmVFdmVudExpc3RlbmVyP2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpOmEuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyk6dm9pZCAwfSxkb2N1bWVudElzUmVhZHk6ZnVuY3Rpb24oKXtyZXR1cm5cImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlfSxldnRQcmV2ZW50RGVmYXVsdDpmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpldmVudCYmKGV2ZW50LnJldHVyblZhbHVlPSExKX0sZXh0ZW5kOmZ1bmN0aW9uKGEsYil7dmFyIGM7Zm9yKGMgaW4gYiliLmhhc093blByb3BlcnR5KGMpJiYoYVtjXT1iW2NdKX0sZ2V0U3RlcFRhcmdldEhlbHBlcjpmdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtpZihiKXJldHVybiBiO2lmKHMpcmV0dXJuIGI9alF1ZXJ5KGEpLGIubGVuZ3RoP2JbMF06bnVsbDtpZihwKXJldHVybiBiPW5ldyBwKGEpLGIubGVuZ3RoP2JbMF06bnVsbDtpZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKXRyeXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhKX1jYXRjaChjKXt9cmV0dXJuL14jW2EtekEtWl1bXFx3LV86Ll0qJC8udGVzdChhKT9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhLnN1YnN0cmluZygxKSk6bnVsbH0sZ2V0U3RlcFRhcmdldDpmdW5jdGlvbihhKXt2YXIgYjtpZighYXx8IWEudGFyZ2V0KXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhLnRhcmdldClyZXR1cm4gaC5nZXRTdGVwVGFyZ2V0SGVscGVyKGEudGFyZ2V0KTtpZihBcnJheS5pc0FycmF5KGEudGFyZ2V0KSl7dmFyIGMsZDtmb3IoYz0wLGQ9YS50YXJnZXQubGVuZ3RoO2Q+YztjKyspaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEudGFyZ2V0W2NdJiYoYj1oLmdldFN0ZXBUYXJnZXRIZWxwZXIoYS50YXJnZXRbY10pKSlyZXR1cm4gYjtyZXR1cm4gbnVsbH1yZXR1cm4gYS50YXJnZXR9LGdldEkxOE5TdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuIGVbYV18fGRbYV19LHNldFN0YXRlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPVwiXCI7aWYodCYmdSl0cnl7c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShhLGIpfWNhdGNoKGYpe3U9ITEsdGhpcy5zZXRTdGF0ZShhLGIsYyl9ZWxzZSB0JiZzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGEpLGMmJihkPW5ldyBEYXRlLGQuc2V0VGltZShkLmdldFRpbWUoKSsyNCpjKjYwKjYwKjFlMyksZT1cIjsgZXhwaXJlcz1cIitkLnRvR01UU3RyaW5nKCkpLGRvY3VtZW50LmNvb2tpZT1hK1wiPVwiK2IrZStcIjsgcGF0aD0vXCJ9LGdldFN0YXRlOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPWErXCI9XCIsZj1kb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpO2lmKHQmJihkPXNlc3Npb25TdG9yYWdlLmdldEl0ZW0oYSkpKXJldHVybiBkO2ZvcihiPTA7YjxmLmxlbmd0aDtiKyspe2ZvcihjPWZbYl07XCIgXCI9PT1jLmNoYXJBdCgwKTspYz1jLnN1YnN0cmluZygxLGMubGVuZ3RoKTtpZigwPT09Yy5pbmRleE9mKGUpKXtkPWMuc3Vic3RyaW5nKGUubGVuZ3RoLGMubGVuZ3RoKTticmVha319cmV0dXJuIGR9LGNsZWFyU3RhdGU6ZnVuY3Rpb24oYSl7dD9zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGEpOnRoaXMuc2V0U3RhdGUoYSxcIlwiLC0xKX0sbm9ybWFsaXplUGxhY2VtZW50OmZ1bmN0aW9uKGEpeyFhLnBsYWNlbWVudCYmYS5vcmllbnRhdGlvbiYmKGEucGxhY2VtZW50PWEub3JpZW50YXRpb24pfSxmbGlwUGxhY2VtZW50OmZ1bmN0aW9uKGEpe2lmKGEuaXNSdGwmJiFhLl9pc0ZsaXBwZWQpe3ZhciBiLGMsZD1bXCJvcmllbnRhdGlvblwiLFwicGxhY2VtZW50XCJdO2EueE9mZnNldCYmKGEueE9mZnNldD0tMSp0aGlzLmdldFBpeGVsVmFsdWUoYS54T2Zmc2V0KSk7Zm9yKGMgaW4gZCliPWRbY10sYS5oYXNPd25Qcm9wZXJ0eShiKSYmdy5oYXNPd25Qcm9wZXJ0eShhW2JdKSYmKGFbYl09d1thW2JdXSk7YS5faXNGbGlwcGVkPSEwfX19LGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwibG9hZFwiLGspLGk9e25leHQ6W10scHJldjpbXSxzdGFydDpbXSxlbmQ6W10sc2hvdzpbXSxlcnJvcjpbXSxjbG9zZTpbXX0saj17fSxkPXtzdGVwTnVtczpudWxsLG5leHRCdG46XCJOZXh0XCIscHJldkJ0bjpcIkJhY2tcIixkb25lQnRuOlwiRG9uZVwiLHNraXBCdG46XCJTa2lwXCIsY2xvc2VUb29sdGlwOlwiQ2xvc2VcIn0sZT17fSxiPWZ1bmN0aW9uKGEpe3RoaXMuaW5pdChhKX0sYi5wcm90b3R5cGU9e2lzU2hvd2luZzohMSxjdXJyU3RlcDp2b2lkIDAsc2V0UG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGksaj1oLmdldFN0ZXBUYXJnZXQoYSksaz10aGlzLmVsZW1lbnQsbD10aGlzLmFycm93RWwsbT1hLmlzUnRsP1wicmlnaHRcIjpcImxlZnRcIjtpZihoLmZsaXBQbGFjZW1lbnQoYSksaC5ub3JtYWxpemVQbGFjZW1lbnQoYSksYz1rLm9mZnNldFdpZHRoLGI9ay5vZmZzZXRIZWlnaHQsaC5yZW1vdmVDbGFzcyhrLFwiZmFkZS1pbi1kb3duIGZhZGUtaW4tdXAgZmFkZS1pbi1sZWZ0IGZhZGUtaW4tcmlnaHRcIiksZD1qLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9YS5pc1J0bD9kLnJpZ2h0LWM6ZC5sZWZ0LFwidG9wXCI9PT1hLnBsYWNlbWVudCllPWQudG9wLWItdGhpcy5vcHQuYXJyb3dXaWR0aCxmPWk7ZWxzZSBpZihcImJvdHRvbVwiPT09YS5wbGFjZW1lbnQpZT1kLmJvdHRvbSt0aGlzLm9wdC5hcnJvd1dpZHRoLGY9aTtlbHNlIGlmKFwibGVmdFwiPT09YS5wbGFjZW1lbnQpZT1kLnRvcCxmPWQubGVmdC1jLXRoaXMub3B0LmFycm93V2lkdGg7ZWxzZXtpZihcInJpZ2h0XCIhPT1hLnBsYWNlbWVudCl0aHJvdyBuZXcgRXJyb3IoXCJCdWJibGUgcGxhY2VtZW50IGZhaWxlZCBiZWNhdXNlIHN0ZXAucGxhY2VtZW50IGlzIGludmFsaWQgb3IgdW5kZWZpbmVkIVwiKTtlPWQudG9wLGY9ZC5yaWdodCt0aGlzLm9wdC5hcnJvd1dpZHRofWc9XCJjZW50ZXJcIiE9PWEuYXJyb3dPZmZzZXQ/aC5nZXRQaXhlbFZhbHVlKGEuYXJyb3dPZmZzZXQpOmEuYXJyb3dPZmZzZXQsZz9cInRvcFwiPT09YS5wbGFjZW1lbnR8fFwiYm90dG9tXCI9PT1hLnBsYWNlbWVudD8obC5zdHlsZS50b3A9XCJcIixcImNlbnRlclwiPT09Zz9sLnN0eWxlW21dPU1hdGguZmxvb3IoYy8yLWwub2Zmc2V0V2lkdGgvMikrXCJweFwiOmwuc3R5bGVbbV09ZytcInB4XCIpOihcImxlZnRcIj09PWEucGxhY2VtZW50fHxcInJpZ2h0XCI9PT1hLnBsYWNlbWVudCkmJihsLnN0eWxlW21dPVwiXCIsXCJjZW50ZXJcIj09PWc/bC5zdHlsZS50b3A9TWF0aC5mbG9vcihiLzItbC5vZmZzZXRIZWlnaHQvMikrXCJweFwiOmwuc3R5bGUudG9wPWcrXCJweFwiKToobC5zdHlsZS50b3A9XCJcIixsLnN0eWxlW21dPVwiXCIpLFwiY2VudGVyXCI9PT1hLnhPZmZzZXQ/Zj1kLmxlZnQrai5vZmZzZXRXaWR0aC8yLWMvMjpmKz1oLmdldFBpeGVsVmFsdWUoYS54T2Zmc2V0KSxcImNlbnRlclwiPT09YS55T2Zmc2V0P2U9ZC50b3Arai5vZmZzZXRIZWlnaHQvMi1iLzI6ZSs9aC5nZXRQaXhlbFZhbHVlKGEueU9mZnNldCksYS5maXhlZEVsZW1lbnR8fChlKz1oLmdldFNjcm9sbFRvcCgpLGYrPWguZ2V0U2Nyb2xsTGVmdCgpKSxrLnN0eWxlLnBvc2l0aW9uPWEuZml4ZWRFbGVtZW50P1wiZml4ZWRcIjpcImFic29sdXRlXCIsay5zdHlsZS50b3A9ZStcInB4XCIsay5zdHlsZS5sZWZ0PWYrXCJweFwifSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZyxpLGosayxsLG4scCxxLHI9dGhpcy5lbGVtZW50O2lmKGE/dGhpcy5jdXJyU3RlcD1hOnRoaXMuY3VyclN0ZXAmJihhPXRoaXMuY3VyclN0ZXApLHRoaXMub3B0LmlzVG91ckJ1YmJsZT8oaT1tLmdldEN1cnJUb3VyKCksaSYmKGU9aS5jdXN0b21EYXRhLGQ9aS5jdXN0b21SZW5kZXJlcixhLmlzUnRsPWEuaGFzT3duUHJvcGVydHkoXCJpc1J0bFwiKT9hLmlzUnRsOmkuaGFzT3duUHJvcGVydHkoXCJpc1J0bFwiKT9pLmlzUnRsOnRoaXMub3B0LmlzUnRsLGc9aS51bnNhZmUsQXJyYXkuaXNBcnJheShpLnN0ZXBzKSYmKGo9aS5zdGVwcy5sZW5ndGgsaz10aGlzLl9nZXRTdGVwSTE4bk51bSh0aGlzLl9nZXRTdGVwTnVtKGotMSkpLG49dGhpcy5fZ2V0U3RlcE51bShiKT09PXRoaXMuX2dldFN0ZXBOdW0oai0xKSkpKTooZT1hLmN1c3RvbURhdGEsZD1hLmN1c3RvbVJlbmRlcmVyLGc9YS51bnNhZmUsYS5pc1J0bD1hLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/YS5pc1J0bDp0aGlzLm9wdC5pc1J0bCksbD1uP2guZ2V0STE4TlN0cmluZyhcImRvbmVCdG5cIik6YS5zaG93U2tpcD9oLmdldEkxOE5TdHJpbmcoXCJza2lwQnRuXCIpOmguZ2V0STE4TlN0cmluZyhcIm5leHRCdG5cIiksaC5mbGlwUGxhY2VtZW50KGEpLGgubm9ybWFsaXplUGxhY2VtZW50KGEpLHRoaXMucGxhY2VtZW50PWEucGxhY2VtZW50LHE9e2kxOG46e3ByZXZCdG46aC5nZXRJMThOU3RyaW5nKFwicHJldkJ0blwiKSxuZXh0QnRuOmwsY2xvc2VUb29sdGlwOmguZ2V0STE4TlN0cmluZyhcImNsb3NlVG9vbHRpcFwiKSxzdGVwTnVtOnRoaXMuX2dldFN0ZXBJMThuTnVtKHRoaXMuX2dldFN0ZXBOdW0oYikpLG51bVN0ZXBzOmt9LGJ1dHRvbnM6e3Nob3dQcmV2OmgudmFsT3JEZWZhdWx0KGEuc2hvd1ByZXZCdXR0b24sdGhpcy5vcHQuc2hvd1ByZXZCdXR0b24pJiZ0aGlzLl9nZXRTdGVwTnVtKGIpPjAsc2hvd05leHQ6aC52YWxPckRlZmF1bHQoYS5zaG93TmV4dEJ1dHRvbix0aGlzLm9wdC5zaG93TmV4dEJ1dHRvbiksc2hvd0NUQTpoLnZhbE9yRGVmYXVsdChhLnNob3dDVEFCdXR0b24mJmEuY3RhTGFiZWwsITEpLGN0YUxhYmVsOmEuY3RhTGFiZWwsc2hvd0Nsb3NlOmgudmFsT3JEZWZhdWx0KHRoaXMub3B0LnNob3dDbG9zZUJ1dHRvbiwhMCl9LHN0ZXA6e251bTpiLGlzTGFzdDpoLnZhbE9yRGVmYXVsdChuLCExKSx0aXRsZTphLnRpdGxlfHxcIlwiLGNvbnRlbnQ6YS5jb250ZW50fHxcIlwiLGlzUnRsOmEuaXNSdGwscGxhY2VtZW50OmEucGxhY2VtZW50LHBhZGRpbmc6aC52YWxPckRlZmF1bHQoYS5wYWRkaW5nLHRoaXMub3B0LmJ1YmJsZVBhZGRpbmcpLHdpZHRoOmguZ2V0UGl4ZWxWYWx1ZShhLndpZHRoKXx8dGhpcy5vcHQuYnViYmxlV2lkdGgsY3VzdG9tRGF0YTphLmN1c3RvbURhdGF8fHt9fSx0b3VyOntpc1RvdXI6dGhpcy5vcHQuaXNUb3VyQnViYmxlLG51bVN0ZXBzOmosdW5zYWZlOmgudmFsT3JEZWZhdWx0KGcsITEpLGN1c3RvbURhdGE6ZXx8e319fSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkKXIuaW5uZXJIVE1MPWQocSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgZCl7aWYoIW0udGVtcGxhdGVzfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBtLnRlbXBsYXRlc1tkXSl0aHJvdyBuZXcgRXJyb3IoJ0J1YmJsZSByZW5kZXJpbmcgZmFpbGVkIC0gdGVtcGxhdGUgXCInK2QrJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO3IuaW5uZXJIVE1MPW0udGVtcGxhdGVzW2RdKHEpfWVsc2UgaWYoZilyLmlubmVySFRNTD1mKHEpO2Vsc2V7aWYoIW0udGVtcGxhdGVzfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBtLnRlbXBsYXRlc1tvXSl0aHJvdyBuZXcgRXJyb3IoJ0J1YmJsZSByZW5kZXJpbmcgZmFpbGVkIC0gdGVtcGxhdGUgXCInK28rJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO3IuaW5uZXJIVE1MPW0udGVtcGxhdGVzW29dKHEpfXZhciBzLHQ9ci5jaGlsZHJlbix1PXQubGVuZ3RoO2ZvcihwPTA7dT5wO3ArKylzPXRbcF0saC5oYXNDbGFzcyhzLFwiaG9wc2NvdGNoLWFycm93XCIpJiYodGhpcy5hcnJvd0VsPXMpO3JldHVybiByLnN0eWxlLnpJbmRleD1cIm51bWJlclwiPT10eXBlb2YgYS56aW5kZXg/YS56aW5kZXg6XCJcIix0aGlzLl9zZXRBcnJvdyhhLnBsYWNlbWVudCksdGhpcy5oaWRlKCExKSx0aGlzLnNldFBvc2l0aW9uKGEpLGMmJmMoIWEuZml4ZWRFbGVtZW50KSx0aGlzfSxfZ2V0U3RlcE51bTpmdW5jdGlvbihhKXt2YXIgYixjLGQ9MCxlPW0uZ2V0U2tpcHBlZFN0ZXBzSW5kZXhlcygpLGY9ZS5sZW5ndGg7Zm9yKGM9MDtmPmM7YysrKWI9ZVtjXSxhPmImJmQrKztyZXR1cm4gYS1kfSxfZ2V0U3RlcEkxOG5OdW06ZnVuY3Rpb24oYSl7dmFyIGI9aC5nZXRJMThOU3RyaW5nKFwic3RlcE51bXNcIik7cmV0dXJuIGImJmE8Yi5sZW5ndGg/YT1iW2FdOmErPTEsYX0sX3NldEFycm93OmZ1bmN0aW9uKGEpe2gucmVtb3ZlQ2xhc3ModGhpcy5hcnJvd0VsLFwiZG93biB1cCByaWdodCBsZWZ0XCIpLFwidG9wXCI9PT1hP2guYWRkQ2xhc3ModGhpcy5hcnJvd0VsLFwiZG93blwiKTpcImJvdHRvbVwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcInVwXCIpOlwibGVmdFwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcInJpZ2h0XCIpOlwicmlnaHRcIj09PWEmJmguYWRkQ2xhc3ModGhpcy5hcnJvd0VsLFwibGVmdFwiKX0sX2dldEFycm93RGlyZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0b3BcIj09PXRoaXMucGxhY2VtZW50P1wiZG93blwiOlwiYm90dG9tXCI9PT10aGlzLnBsYWNlbWVudD9cInVwXCI6XCJsZWZ0XCI9PT10aGlzLnBsYWNlbWVudD9cInJpZ2h0XCI6XCJyaWdodFwiPT09dGhpcy5wbGFjZW1lbnQ/XCJsZWZ0XCI6dm9pZCAwfSxzaG93OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPVwiZmFkZS1pbi1cIit0aGlzLl9nZXRBcnJvd0RpcmVjdGlvbigpLGM9MWUzO3JldHVybiBoLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCxcImhpZGVcIiksaC5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsYiksc2V0VGltZW91dChmdW5jdGlvbigpe2gucmVtb3ZlQ2xhc3MoYS5lbGVtZW50LFwiaW52aXNpYmxlXCIpfSw1MCksc2V0VGltZW91dChmdW5jdGlvbigpe2gucmVtb3ZlQ2xhc3MoYS5lbGVtZW50LGIpfSxjKSx0aGlzLmlzU2hvd2luZz0hMCx0aGlzfSxoaWRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudDtyZXR1cm4gYT1oLnZhbE9yRGVmYXVsdChhLCEwKSxiLnN0eWxlLnRvcD1cIlwiLGIuc3R5bGUubGVmdD1cIlwiLGE/KGguYWRkQ2xhc3MoYixcImhpZGVcIiksaC5yZW1vdmVDbGFzcyhiLFwiaW52aXNpYmxlXCIpKTooaC5yZW1vdmVDbGFzcyhiLFwiaGlkZVwiKSxoLmFkZENsYXNzKGIsXCJpbnZpc2libGVcIikpLGgucmVtb3ZlQ2xhc3MoYixcImFuaW1hdGUgZmFkZS1pbi11cCBmYWRlLWluLWRvd24gZmFkZS1pbi1yaWdodCBmYWRlLWluLWxlZnRcIiksdGhpcy5pc1Nob3dpbmc9ITEsdGhpc30sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksaC5yZW1vdmVFdnRMaXN0ZW5lcihhLFwiY2xpY2tcIix0aGlzLmNsaWNrQ2IpfSxfaGFuZGxlQnViYmxlQ2xpY2s6ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihjKXtyZXR1cm4gYz09PWEuY3VycmVudFRhcmdldD9udWxsOmguaGFzQ2xhc3MoYyxcImhvcHNjb3RjaC1jdGFcIik/XCJjdGFcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtbmV4dFwiKT9cIm5leHRcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtcHJldlwiKT9cInByZXZcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtY2xvc2VcIik/XCJjbG9zZVwiOmIoYy5wYXJlbnRFbGVtZW50KX12YXIgYzthPWF8fHdpbmRvdy5ldmVudDt2YXIgZD1hLnRhcmdldHx8YS5zcmNFbGVtZW50O2lmKGM9YihkKSxcImN0YVwiPT09Yyl0aGlzLm9wdC5pc1RvdXJCdWJibGV8fG0uZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZW1vdmVDYWxsb3V0KHRoaXMuY3VyclN0ZXAuaWQpLHRoaXMuY3VyclN0ZXAub25DVEEmJmguaW52b2tlQ2FsbGJhY2sodGhpcy5jdXJyU3RlcC5vbkNUQSk7ZWxzZSBpZihcIm5leHRcIj09PWMpbS5uZXh0U3RlcCghMCk7ZWxzZSBpZihcInByZXZcIj09PWMpbS5wcmV2U3RlcCghMCk7ZWxzZSBpZihcImNsb3NlXCI9PT1jKXtpZih0aGlzLm9wdC5pc1RvdXJCdWJibGUpe3ZhciBlPW0uZ2V0Q3VyclN0ZXBOdW0oKSxmPW0uZ2V0Q3VyclRvdXIoKSxnPWU9PT1mLnN0ZXBzLmxlbmd0aC0xO2guaW52b2tlRXZlbnRDYWxsYmFja3MoXCJjbG9zZVwiKSxtLmVuZFRvdXIoITAsZyl9ZWxzZSB0aGlzLm9wdC5vbkNsb3NlJiZoLmludm9rZUNhbGxiYWNrKHRoaXMub3B0Lm9uQ2xvc2UpLHRoaXMub3B0LmlkJiYhdGhpcy5vcHQuaXNUb3VyQnViYmxlP20uZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZW1vdmVDYWxsb3V0KHRoaXMub3B0LmlkKTp0aGlzLmRlc3Ryb3koKTtoLmV2dFByZXZlbnREZWZhdWx0KGEpfX0saW5pdDpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZz10aGlzLGk9ITE7dGhpcy5lbGVtZW50PWYsZT17c2hvd1ByZXZCdXR0b246bC5zaG93UHJldkJ1dHRvbixzaG93TmV4dEJ1dHRvbjpsLnNob3dOZXh0QnV0dG9uLGJ1YmJsZVdpZHRoOmwuYnViYmxlV2lkdGgsYnViYmxlUGFkZGluZzpsLmJ1YmJsZVBhZGRpbmcsYXJyb3dXaWR0aDpsLmFycm93V2lkdGgsaXNSdGw6bC5pc1J0bCxzaG93TnVtYmVyOiEwLGlzVG91ckJ1YmJsZTohMH0sYT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpKT09PXE/e306YSxoLmV4dGVuZChlLGEpLHRoaXMub3B0PWUsZi5jbGFzc05hbWU9XCJob3BzY290Y2gtYnViYmxlIGFuaW1hdGVkXCIsZS5pc1RvdXJCdWJibGU/KGQ9bS5nZXRDdXJyVG91cigpLGQmJmguYWRkQ2xhc3MoZixcInRvdXItXCIrZC5pZCkpOmguYWRkQ2xhc3MoZixcImhvcHNjb3RjaC1jYWxsb3V0IG5vLW51bWJlclwiKSxiPWZ1bmN0aW9uKCl7IWkmJmcuaXNTaG93aW5nJiYoaT0hMCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zy5zZXRQb3NpdGlvbihnLmN1cnJTdGVwKSxpPSExfSwxMDApKX0saC5hZGRFdnRMaXN0ZW5lcih3aW5kb3csXCJyZXNpemVcIixiKSx0aGlzLmNsaWNrQ2I9ZnVuY3Rpb24oYSl7Zy5faGFuZGxlQnViYmxlQ2xpY2soYSl9LGguYWRkRXZ0TGlzdGVuZXIoZixcImNsaWNrXCIsdGhpcy5jbGlja0NiKSx0aGlzLmhpZGUoKSxoLmRvY3VtZW50SXNSZWFkeSgpP2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik6KGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI/KGM9ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLGMpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZil9LGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsYywhMSkpOihjPWZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmKGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsYyksd2luZG93LmRldGFjaEV2ZW50KFwib25sb2FkXCIsYyksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmKSl9LGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsYykpLGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwibG9hZFwiLGMpKX19LGM9ZnVuY3Rpb24oKXt2YXIgYT17fSxjPXt9O3RoaXMuY3JlYXRlQ2FsbG91dD1mdW5jdGlvbihkKXt2YXIgZTtpZighZC5pZCl0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgYSBjYWxsb3V0IGlkLlwiKTtpZighdi50ZXN0KGQuaWQpKXRocm93IG5ldyBFcnJvcihcIkNhbGxvdXQgSUQgaXMgdXNpbmcgYW4gaW52YWxpZCBmb3JtYXQuIFVzZSBhbHBoYW51bWVyaWMsIHVuZGVyc2NvcmVzLCBhbmQvb3IgaHlwaGVucyBvbmx5LiBGaXJzdCBjaGFyYWN0ZXIgbXVzdCBiZSBhIGxldHRlci5cIik7aWYoYVtkLmlkXSl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsb3V0IGJ5IHRoYXQgaWQgYWxyZWFkeSBleGlzdHMuIFBsZWFzZSBjaG9vc2UgYSB1bmlxdWUgaWQuXCIpO2lmKCFoLmdldFN0ZXBUYXJnZXQoZCkpdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IGV4aXN0aW5nIHRhcmdldCBlbGVtZW50IHZpYSAndGFyZ2V0JyBvcHRpb24uXCIpO3JldHVybiBkLnNob3dOZXh0QnV0dG9uPWQuc2hvd1ByZXZCdXR0b249ITEsZC5pc1RvdXJCdWJibGU9ITEsZT1uZXcgYihkKSxhW2QuaWRdPWUsY1tkLmlkXT1kLGUucmVuZGVyKGQsbnVsbCxmdW5jdGlvbigpe2Uuc2hvdygpLGQub25TaG93JiZoLmludm9rZUNhbGxiYWNrKGQub25TaG93KX0pLGV9LHRoaXMuZ2V0Q2FsbG91dD1mdW5jdGlvbihiKXtyZXR1cm4gYVtiXX0sdGhpcy5yZW1vdmVBbGxDYWxsb3V0cz1mdW5jdGlvbigpe3ZhciBiO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmdGhpcy5yZW1vdmVDYWxsb3V0KGIpfSx0aGlzLnJlbW92ZUNhbGxvdXQ9ZnVuY3Rpb24oYil7dmFyIGQ9YVtiXTthW2JdPW51bGwsY1tiXT1udWxsLGQmJmQuZGVzdHJveSgpfSx0aGlzLnJlZnJlc2hDYWxsb3V0UG9zaXRpb25zPWZ1bmN0aW9uKCl7dmFyIGIsZCxlO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmYy5oYXNPd25Qcm9wZXJ0eShiKSYmKGQ9YVtiXSxlPWNbYl0sZCYmZSYmZC5zZXRQb3NpdGlvbihlKSl9fSxhPWZ1bmN0aW9uKGEpe3ZhciBkLGsscCx0LHUsdyx4LHksej10aGlzLEE9e30sQj1bXSxDPWZ1bmN0aW9uKGEpe3JldHVybiBkJiZkLmVsZW1lbnQmJmQuZWxlbWVudC5wYXJlbnROb2RlfHwoZD1uZXcgYihwKSksYSYmaC5leHRlbmQoZC5vcHQse2J1YmJsZVBhZGRpbmc6RShcImJ1YmJsZVBhZGRpbmdcIiksYnViYmxlV2lkdGg6RShcImJ1YmJsZVdpZHRoXCIpLHNob3dOZXh0QnV0dG9uOkUoXCJzaG93TmV4dEJ1dHRvblwiKSxzaG93UHJldkJ1dHRvbjpFKFwic2hvd1ByZXZCdXR0b25cIiksc2hvd0Nsb3NlQnV0dG9uOkUoXCJzaG93Q2xvc2VCdXR0b25cIiksYXJyb3dXaWR0aDpFKFwiYXJyb3dXaWR0aFwiKSxpc1J0bDpFKFwiaXNSdGxcIil9KSxkfSxEPWZ1bmN0aW9uKCl7ZCYmKGQuZGVzdHJveSgpLGQ9bnVsbCl9LEU9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIHA/bFthXTpoLnZhbE9yRGVmYXVsdChwW2FdLGxbYV0pfSxGPWZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGE9IXR8fDA+dXx8dT49dC5zdGVwcy5sZW5ndGg/bnVsbDp0LnN0ZXBzW3VdfSxHPWZ1bmN0aW9uKCl7ei5uZXh0U3RlcCgpfSxIPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxpPUMoKSxqPWkuZWxlbWVudCxrPWguZ2V0UGl4ZWxWYWx1ZShqLnN0eWxlLnRvcCksbD1rK2guZ2V0UGl4ZWxWYWx1ZShqLm9mZnNldEhlaWdodCksbT1oLmdldFN0ZXBUYXJnZXQoRigpKSxvPW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscD1vLnRvcCtoLmdldFNjcm9sbFRvcCgpLHI9by5ib3R0b20raC5nZXRTY3JvbGxUb3AoKSx0PXA+az9rOnAsdT1sPnI/bDpyLHY9aC5nZXRTY3JvbGxUb3AoKSx3PXYraC5nZXRXaW5kb3dIZWlnaHQoKSx4PXQtRShcInNjcm9sbFRvcE1hcmdpblwiKTt0Pj12JiYodDw9ditFKFwic2Nyb2xsVG9wTWFyZ2luXCIpfHx3Pj11KT9hJiZhKCk6RShcInNtb290aFNjcm9sbFwiKT8oXCJ1bmRlZmluZWRcIj09dHlwZW9mIFlBSE9PP1widW5kZWZpbmVkXCI6bihZQUhPTykpIT09cSYmbihZQUhPTy5lbnYpIT09cSYmbihZQUhPTy5lbnYudWEpIT09cSYmbihZQUhPTy51dGlsKSE9PXEmJm4oWUFIT08udXRpbC5TY3JvbGwpIT09cT8oYj1ZQUhPTy5lbnYudWEud2Via2l0P2RvY3VtZW50LmJvZHk6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGQ9WUFIT08udXRpbC5FYXNpbmc/WUFIT08udXRpbC5FYXNpbmcuZWFzZU91dDp2b2lkIDAsYz1uZXcgWUFIT08udXRpbC5TY3JvbGwoYix7c2Nyb2xsOnt0bzpbMCx4XX19LEUoXCJzY3JvbGxEdXJhdGlvblwiKS8xZTMsZCksYy5vbkNvbXBsZXRlLnN1YnNjcmliZShhKSxjLmFuaW1hdGUoKSk6cz9qUXVlcnkoXCJib2R5LCBodG1sXCIpLmFuaW1hdGUoe3Njcm9sbFRvcDp4fSxFKFwic2Nyb2xsRHVyYXRpb25cIiksYSk6KDA+eCYmKHg9MCksZT12PnQ/LTE6MSxmPU1hdGguYWJzKHYteCkvKEUoXCJzY3JvbGxEdXJhdGlvblwiKS8xMCksKGc9ZnVuY3Rpb24oKXt2YXIgYj1oLmdldFNjcm9sbFRvcCgpLGM9YitlKmY7cmV0dXJuIGU+MCYmYz49eHx8MD5lJiZ4Pj1jPyhjPXgsYSYmYSgpLHZvaWQgd2luZG93LnNjcm9sbFRvKDAsYykpOih3aW5kb3cuc2Nyb2xsVG8oMCxjKSxoLmdldFNjcm9sbFRvcCgpPT09Yj92b2lkKGEmJmEoKSk6dm9pZCBzZXRUaW1lb3V0KGcsMTApKX0pKCkpOih3aW5kb3cuc2Nyb2xsVG8oMCx4KSxhJiZhKCkpfSxJPWZ1bmN0aW9uIFAoYSxiKXt2YXIgYyxkLGU7dSthPj0wJiZ1K2E8dC5zdGVwcy5sZW5ndGg/KHUrPWEsZD1GKCksZT1mdW5jdGlvbigpe2M9aC5nZXRTdGVwVGFyZ2V0KGQpLGM/KEFbdV0mJmRlbGV0ZSBBW3VdLGIodSkpOihBW3VdPSEwLGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSxQKGEsYikpfSxkLmRlbGF5P3NldFRpbWVvdXQoZSxkLmRlbGF5KTplKCkpOmIoLTEpfSxKPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZz1DKCksaT10aGlzO2lmKGcuaGlkZSgpLGE9aC52YWxPckRlZmF1bHQoYSwhMCksYz1GKCksYy5uZXh0T25UYXJnZXRDbGljayYmaC5yZW1vdmVFdnRMaXN0ZW5lcihoLmdldFN0ZXBUYXJnZXQoYyksXCJjbGlja1wiLEcpLGQ9YyxlPWI+MD9kLm11bHRpcGFnZTp1PjAmJnQuc3RlcHNbdS0xXS5tdWx0aXBhZ2UsZj1mdW5jdGlvbihjKXt2YXIgZjtpZigtMT09PWMpcmV0dXJuIHRoaXMuZW5kVG91cighMCk7aWYoYSYmKGY9Yj4wP2guaW52b2tlRXZlbnRDYWxsYmFja3MoXCJuZXh0XCIsZC5vbk5leHQpOmguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJwcmV2XCIsZC5vblByZXYpKSxjPT09dSl7aWYoZSlyZXR1cm4gdm9pZCBOKCk7Zj1oLnZhbE9yRGVmYXVsdChmLCEwKSxmP3RoaXMuc2hvd1N0ZXAoYyk6dGhpcy5lbmRUb3VyKCExKX19LCFlJiZFKFwic2tpcElmTm9FbGVtZW50XCIpKUkoYixmdW5jdGlvbihhKXtmLmNhbGwoaSxhKX0pO2Vsc2UgaWYodStiPj0wJiZ1K2I8dC5zdGVwcy5sZW5ndGgpe2lmKHUrPWIsYz1GKCksIWguZ2V0U3RlcFRhcmdldChjKSYmIWUpcmV0dXJuIGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSx0aGlzLmVuZFRvdXIoITAsITEpO2YuY2FsbCh0aGlzLHUpfWVsc2UgaWYodStiPT09dC5zdGVwcy5sZW5ndGgpcmV0dXJuIHRoaXMuZW5kVG91cigpO3JldHVybiB0aGlzfSxLPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXt9O2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJpZFwiIT09YiYmXCJzdGVwc1wiIT09YiYmKGVbYl09YVtiXSk7cmV0dXJuIHkuY2FsbCh0aGlzLGUsITApLGM9aC5nZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSksYyYmKGQ9Yy5zcGxpdChcIjpcIiksdz1kWzBdLHg9ZFsxXSxkLmxlbmd0aD4yJiYoQj1kWzJdLnNwbGl0KFwiLFwiKSkseD1wYXJzZUludCh4LDEwKSksdGhpc30sTD1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZih1PWF8fDAsQT1ifHx7fSxkPUYoKSxlPWguZ2V0U3RlcFRhcmdldChkKSlyZXR1cm4gdm9pZCBjKHUpO2lmKCFlKXtpZihoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksQVt1XT0hMCxFKFwic2tpcElmTm9FbGVtZW50XCIpKXJldHVybiB2b2lkIEkoMSxjKTt1PS0xLGModSl9fSxNPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtkLnNob3coKSxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwic2hvd1wiLGMub25TaG93KX12YXIgYz10LnN0ZXBzW2FdLGQ9QygpLGU9aC5nZXRTdGVwVGFyZ2V0KGMpO3UhPT1hJiZGKCkubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KEYoKSksXCJjbGlja1wiLEcpLHU9YSxkLmhpZGUoITEpLGQucmVuZGVyKGMsYSxmdW5jdGlvbihhKXthP0goYik6YigpLGMubmV4dE9uVGFyZ2V0Q2xpY2smJmguYWRkRXZ0TGlzdGVuZXIoZSxcImNsaWNrXCIsRyl9KSxOKCl9LE49ZnVuY3Rpb24oKXt2YXIgYT10LmlkK1wiOlwiK3UsYj1tLmdldFNraXBwZWRTdGVwc0luZGV4ZXMoKTtiJiZiLmxlbmd0aD4wJiYoYSs9XCI6XCIrYi5qb2luKFwiLFwiKSksaC5zZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSxhLDEpfSxPPWZ1bmN0aW9uKGEpe2EmJnRoaXMuY29uZmlndXJlKGEpfTt0aGlzLmdldENhbGxvdXRNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBrP1widW5kZWZpbmVkXCI6bihrKSk9PT1xJiYoaz1uZXcgYyksa30sdGhpcy5zdGFydFRvdXI9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9e30sZj10aGlzO2lmKCF0KXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJUb3VyIGRhdGEgaXMgcmVxdWlyZWQgZm9yIHN0YXJ0VG91ci5cIik7aWYoIWEuaWR8fCF2LnRlc3QoYS5pZCkpdGhyb3cgbmV3IEVycm9yKFwiVG91ciBJRCBpcyB1c2luZyBhbiBpbnZhbGlkIGZvcm1hdC4gVXNlIGFscGhhbnVtZXJpYywgdW5kZXJzY29yZXMsIGFuZC9vciBoeXBoZW5zIG9ubHkuIEZpcnN0IGNoYXJhY3RlciBtdXN0IGJlIGEgbGV0dGVyLlwiKTt0PWEsSy5jYWxsKHRoaXMsYSl9aWYoKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP1widW5kZWZpbmVkXCI6bihiKSkhPT1xKXtpZihiPj10LnN0ZXBzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGVjaWZpZWQgc3RlcCBudW1iZXIgb3V0IG9mIGJvdW5kcy5cIik7ZD1ifWlmKCFoLmRvY3VtZW50SXNSZWFkeSgpKXJldHVybiByPSEwLHRoaXM7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGQmJnQuaWQ9PT13JiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHg/XCJ1bmRlZmluZWRcIjpuKHgpKSE9PXEpe2lmKGQ9eCxCLmxlbmd0aD4wKWZvcih2YXIgZz0wLGk9Qi5sZW5ndGg7aT5nO2crKyllW0JbZ11dPSEwfWVsc2UgZHx8KGQ9MCk7cmV0dXJuIEwoZCxlLGZ1bmN0aW9uKGEpe3ZhciBiPS0xIT09YSYmaC5nZXRTdGVwVGFyZ2V0KHQuc3RlcHNbYV0pO3JldHVybiBiPyhoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwic3RhcnRcIiksYz1DKCksYy5oaWRlKCExKSxmLmlzQWN0aXZlPSEwLHZvaWQoaC5nZXRTdGVwVGFyZ2V0KEYoKSk/Zi5zaG93U3RlcChhKTooaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVycm9yXCIpLEUoXCJza2lwSWZOb0VsZW1lbnRcIikmJmYubmV4dFN0ZXAoITEpKSkpOnZvaWQgZi5lbmRUb3VyKCExLCExKX0pLHRoaXN9LHRoaXMuc2hvd1N0ZXA9ZnVuY3Rpb24oYSl7dmFyIGI9dC5zdGVwc1thXSxjPXU7cmV0dXJuIGguZ2V0U3RlcFRhcmdldChiKT8oYi5kZWxheT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TShhKX0sYi5kZWxheSk6TShhKSx0aGlzKToodT1hLGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSx2b2lkKHU9YykpfSx0aGlzLnByZXZTdGVwPWZ1bmN0aW9uKGEpe3JldHVybiBKLmNhbGwodGhpcyxhLC0xKSx0aGlzfSx0aGlzLm5leHRTdGVwPWZ1bmN0aW9uKGEpe3JldHVybiBKLmNhbGwodGhpcyxhLDEpLHRoaXN9LHRoaXMuZW5kVG91cj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9QygpO3JldHVybiBhPWgudmFsT3JEZWZhdWx0KGEsITApLGI9aC52YWxPckRlZmF1bHQoYiwhMCksdCYmKGM9RigpLGMmJmMubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KGMpLFwiY2xpY2tcIixHKSksdT0wLHg9dm9pZCAwLGQuaGlkZSgpLGEmJmguY2xlYXJTdGF0ZShFKFwiY29va2llTmFtZVwiKSksdGhpcy5pc0FjdGl2ZSYmKHRoaXMuaXNBY3RpdmU9ITEsdCYmYiYmaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVuZFwiKSksdGhpcy5yZW1vdmVDYWxsYmFja3MobnVsbCwhMCksdGhpcy5yZXNldERlZmF1bHRPcHRpb25zKCksRCgpLHQ9bnVsbCx0aGlzfSx0aGlzLmdldEN1cnJUb3VyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHRoaXMuZ2V0Q3VyclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBoLmdldFN0ZXBUYXJnZXQoRigpKX0sdGhpcy5nZXRDdXJyU3RlcE51bT1mdW5jdGlvbigpe3JldHVybiB1fSx0aGlzLmdldFNraXBwZWRTdGVwc0luZGV4ZXM9ZnVuY3Rpb24oKXt2YXIgYSxiPVtdO2ZvcihhIGluIEEpYi5wdXNoKGEpO3JldHVybiBifSx0aGlzLnJlZnJlc2hCdWJibGVQb3NpdGlvbj1mdW5jdGlvbigpe3ZhciBhPUYoKTtyZXR1cm4gYSYmQygpLnNldFBvc2l0aW9uKGEpLHRoaXMuZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZWZyZXNoQ2FsbG91dFBvc2l0aW9ucygpLHRoaXN9LHRoaXMubGlzdGVuPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYSYmaVthXS5wdXNoKHtjYjpiLGZyb21Ub3VyOmN9KSx0aGlzfSx0aGlzLnVubGlzdGVuPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWlbYV07Zm9yKGM9MCxkPWUubGVuZ3RoO2Q+YzsrK2MpZVtjXS5jYj09PWImJmUuc3BsaWNlKGMsMSk7cmV0dXJuIHRoaXN9LHRoaXMucmVtb3ZlQ2FsbGJhY2tzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7Zm9yKGYgaW4gaSlpZighYXx8YT09PWYpaWYoYilmb3IoYz1pW2ZdLGQ9MCxlPWMubGVuZ3RoO2U+ZDsrK2QpY1tkXS5mcm9tVG91ciYmKGMuc3BsaWNlKGQtLSwxKSwtLWUpO2Vsc2UgaVtmXT1bXTtyZXR1cm4gdGhpc30sdGhpcy5yZWdpc3RlckhlbHBlcj1mdW5jdGlvbihhLGIpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoalthXT1iKX0sdGhpcy51bnJlZ2lzdGVySGVscGVyPWZ1bmN0aW9uKGEpe2pbYV09bnVsbH0sdGhpcy5pbnZva2VIZWxwZXI9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPVtdO2ZvcihiPTEsYz1hcmd1bWVudHMubGVuZ3RoO2M+YjsrK2IpZC5wdXNoKGFyZ3VtZW50c1tiXSk7althXSYmalthXS5jYWxsKG51bGwsZCl9LHRoaXMuc2V0Q29va2llTmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gcC5jb29raWVOYW1lPWEsdGhpc30sdGhpcy5yZXNldERlZmF1bHRPcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHA9e30sdGhpc30sdGhpcy5yZXNldERlZmF1bHRJMThOPWZ1bmN0aW9uKCl7cmV0dXJuIGU9e30sdGhpc30sdGhpcy5nZXRTdGF0ZT1mdW5jdGlvbigpe3JldHVybiBoLmdldFN0YXRlKEUoXCJjb29raWVOYW1lXCIpKX0seT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZixnLGk9W1wibmV4dFwiLFwicHJldlwiLFwic3RhcnRcIixcImVuZFwiLFwic2hvd1wiLFwiZXJyb3JcIixcImNsb3NlXCJdO2ZvcihwfHx0aGlzLnJlc2V0RGVmYXVsdE9wdGlvbnMoKSxoLmV4dGVuZChwLGEpLGEmJmguZXh0ZW5kKGUsYS5pMThuKSxmPTAsZz1pLmxlbmd0aDtnPmY7KytmKWQ9XCJvblwiK2lbZl0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkraVtmXS5zdWJzdHJpbmcoMSksYVtkXSYmdGhpcy5saXN0ZW4oaVtmXSxhW2RdLGIpO3JldHVybiBjPUMoITApLHRoaXN9LHRoaXMuY29uZmlndXJlPWZ1bmN0aW9uKGEpe3JldHVybiB5LmNhbGwodGhpcyxhLCExKX0sdGhpcy5zZXRSZW5kZXJlcj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYT9cInVuZGVmaW5lZFwiOm4oYSk7cmV0dXJuXCJzdHJpbmdcIj09PWI/KG89YSxmPXZvaWQgMCk6XCJmdW5jdGlvblwiPT09YiYmKGY9YSksdGhpc30sdGhpcy5zZXRFc2NhcGVyPWZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEmJihnPWEpLHRoaXN9LE8uY2FsbCh0aGlzLGEpfSxtPW5ldyBhLGZ1bmN0aW9uKCl7dmFyIGE9e307YS5lc2NhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGc/ZyhhKTpudWxsPT1hP1wiXCI6KFwiXCIrYSkucmVwbGFjZShuZXcgUmVnRXhwKFwiWyY8PlxcXCInXVwiLFwiZ1wiKSxmdW5jdGlvbihhKXtyZXR1cm5cIiZcIj09YT9cIiZhbXA7XCI6XCI8XCI9PWE/XCImbHQ7XCI6XCI+XCI9PWE/XCImZ3Q7XCI6J1wiJz09YT9cIiZxdW90O1wiOlwiJ1wiPT1hP1wiJiN4Mjc7XCI6dm9pZCAwfSl9LHRoaXMudGVtcGxhdGVzPXRoaXMudGVtcGxhdGVzfHx7fSx0aGlzLnRlbXBsYXRlcy5idWJibGVfZGVmYXVsdD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGIsYyl7cmV0dXJuIGM/YS5lc2NhcGUoYik6Yn12YXIgZCxlPVwiXCI7YS5lc2NhcGUsQXJyYXkucHJvdG90eXBlLmpvaW47ZSs9XCJcXG5cIjt2YXIgZj1iLmkxOG4sZz1iLmJ1dHRvbnMsaD1iLnN0ZXAsaT1iLnRvdXI7cmV0dXJuIGUrPSdcXG48ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jb250YWluZXJcIiBzdHlsZT1cIndpZHRoOiAnKyhudWxsPT0oZD1oLndpZHRoKT9cIlwiOmQpK1wicHg7IHBhZGRpbmc6IFwiKyhudWxsPT0oZD1oLnBhZGRpbmcpP1wiXCI6ZCkrJ3B4O1wiPlxcbiAgJyxpLmlzVG91ciYmKGUrPSc8c3BhbiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtbnVtYmVyXCI+JysobnVsbD09KGQ9Zi5zdGVwTnVtKT9cIlwiOmQpK1wiPC9zcGFuPlwiKSxlKz0nXFxuICA8ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jb250ZW50XCI+XFxuICAgICcsXCJcIiE9PWgudGl0bGUmJihlKz0nPGgzIGNsYXNzPVwiaG9wc2NvdGNoLXRpdGxlXCI+JysobnVsbD09KGQ9YyhoLnRpdGxlLGkudW5zYWZlKSk/XCJcIjpkKStcIjwvaDM+XCIpLGUrPVwiXFxuICAgIFwiLFwiXCIhPT1oLmNvbnRlbnQmJihlKz0nPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1jb250ZW50XCI+JysobnVsbD09KGQ9YyhoLmNvbnRlbnQsaS51bnNhZmUpKT9cIlwiOmQpK1wiPC9kaXY+XCIpLGUrPSdcXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1hY3Rpb25zXCI+XFxuICAgICcsZy5zaG93UHJldiYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLW5hdi1idXR0b24gcHJldiBob3BzY290Y2gtcHJldlwiPicrKG51bGw9PShkPWYucHJldkJ0bik/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz1cIlxcbiAgICBcIixnLnNob3dDVEEmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLWN0YVwiPicrKG51bGw9PShkPWcuY3RhTGFiZWwpP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gICAgXCIsZy5zaG93TmV4dCYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLW5hdi1idXR0b24gbmV4dCBob3BzY290Y2gtbmV4dFwiPicrKG51bGw9PShkPWYubmV4dEJ0bik/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz1cIlxcbiAgPC9kaXY+XFxuICBcIixnLnNob3dDbG9zZSYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jbG9zZSBob3BzY290Y2gtY2xvc2VcIj4nKyhudWxsPT0oZD1mLmNsb3NlVG9vbHRpcCk/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz0nXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3ctY29udGFpbmVyIGhvcHNjb3RjaC1hcnJvd1wiPlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3ctYm9yZGVyXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1hcnJvd1wiPjwvZGl2PlxcbjwvZGl2Plxcbid9fS5jYWxsKG0pO3ZhciB5PW07cmV0dXJuIHl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaG9wc2NvdGNoL2Rpc3QvanMvaG9wc2NvdGNoLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/* no static exports found */
/* all exports used */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 4), __webpack_require__(/*! ./../process/browser.js */ 16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/* no static exports found */
/* all exports used */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 17);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ })
/******/ ]);